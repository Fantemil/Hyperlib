local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library.CreateLib("Dark Universal ScriptHub", "DarkTheme")
local Tab = Window:NewTab("Home")
local SectionHome = Tab:NewSection("Home")
SectionHome:NewLabel("Dark Universal ScriptHub")
SectionHome:NewLabel("Welcome, "..game.Players.LocalPlayer.name)
-----------ScriptHubs----------------
local UniversalScriptHub = Window:NewTab("Universal ScriptHubs")
local UniversalScriptHubs = UniversalScriptHub:NewSection("Universal ScriptHubs")
----------------------------------------
local Tab6 = Window:NewTab("Universal Scripts")
local Scripts = Tab6:NewSection("Universal Scripts")
----------------------------------------
local Tab4 = Window:NewTab("UI Settings")
local Tab7 = Tab4:NewSection("Settings")
local Tab5 = Window:NewTab("Credits")
local Tab56 = Tab5:NewSection("Credits")

-- Universal Script Hubs --
UniversalScriptHubs:NewButton("Universal FE Script Hub", "Execute the Universal FE Script Hub", function()
loadstring(game:HttpGet('https://raw.githubusercontent.com/Dvrknvss/UniversalFEScriptHub/main/Script'))()
end)

UniversalScriptHubs:NewButton("Domain X", "Execute the Domain X", function()
loadstring(game:HttpGet('https://shlex.dev/release/domainx/latest.lua',true))()
end)

UniversalScriptHubs:NewButton("Equinox Hub", "Execute the Equinox Hub", function()
loadstring(game:HttpGet('https://pastebin.com/raw/wzB1Qh78',true))()
end)

UniversalScriptHubs:NewButton("HatHub V2", "Execute the HatHub V2", function()
loadstring(game:HttpGet("https://pastebin.com/raw/1Cjz1RMH"))()
end)

UniversalScriptHubs:NewButton("Syntax ScriptHub V3", "Execute the Syntax V3, Key is SyntaxV3Free", function()
shared.colors = {
    Icons = Color3.fromRGB(0,255,149),
    Version = Color3.fromRGB(0,255,149),
    Text = Color3.fromRGB(255,255,255),
    Description = Color3.fromRGB(125,125,125),
    TabList = Color3.fromRGB(30,30,30),
    Scripts = Color3.fromRGB(30,30,30),
    Back = Color3.fromRGB(25,25,25),
    Glow = Color3.fromRGB(0,0,0),
}
shared.transparency = {
    Version = 0,
    Text = 0,
    Description = 0,
    Icons = 0,
    Back = 0,
    Glow = 0.5,
    TabList = 0,
    Scripts = 1,
}

loadstring(game:HttpGet("https://raw.githubusercontent.com/Memeboiyot/Syntax-V3-Free/main/Syntax%20v3", true))()
end)

UniversalScriptHubs:NewButton("Nullware Hub V3", "Execute the Nullware", function()
getgenv().Theme = "Blue" -- To change the UI Theme, set this to one of the following options: "Red", "Purple", "Blue", "Green", "Yellow"
loadstring(game:HttpGet("https://gist.githubusercontent.com/M6HqVBcddw2qaN4s/2d722888a388017c18028cd434c43a25/raw/dcccf1027fe4b90780e47767aaf584389c9d7771/EULma3fU90PUOKUn?identifier=".. (function()local a=""for b=1,256 do local c=math.random(1,3)a=a..string.char(c==1 and math.random(48,57)or c==2 and math.random(97,122)or c==3 and math.random(65,90))end;return a end)()))()
end)

UniversalScriptHubs:NewButton("Cuuby Hub", "Execute the Cuuby Hub", function()
loadstring(game:HttpGet("https://pastebin.com/raw/M8bgTBYX", true))()
end)

UniversalScriptHubs:NewButton("Cuuby Hub", "Execute the Cuuby Hub", function()
loadstring(game:HttpGet("https://pastebin.com/raw/M8bgTBYX", true))()
end)

UniversalScriptHubs:NewButton("VHub", "Execute the VHub", function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/Quan8008/V-Hub/Master/Launch-Screen.lua"))();
end)

UniversalScriptHubs:NewButton("Nightmare Hub V2", "Execute the Nightmare Hub V2", function()
loadstring(game:HttpGet(('https://pastefy.ga/lrjtanrp/raw'),true))()
end)

UniversalScriptHubs:NewButton("x2hub V2", "Execute the x2hub V2", function()
local Material = loadstring(game:HttpGet("https://raw.githubusercontent.com/Kinlei/MaterialLua/master/Module.lua"))()

local X = Material.Load({
	Title = "x2hub V.2 (beta)",
	Style = 3,
	SizeX = 500,
	SizeY = 350,
	Theme = "Dark",
	ColorOverrides = {
		MainFrame = Color3.fromRGB(60,60,60)
	}
})

local Main = X.New({
	Title = "Main"
})


local A = Main.Button({
	Text = "Fe john doe (free)",
	Callback = function()
		--Hats Needed
 
-- https://www.roblox.com/catalog/7548993875/Slasher
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
local NotificationBindable = Instance.new("BindableFunction")
NotificationBindable.OnInvoke = callback
--
game.StarterGui:SetCore("SendNotification",  {
 Title = "Hi Welcome ";
 Text = "my john doe fe script is  beta";
 Icon = "";
 Duration = 5;
 Button1 = "Run FE";
 Button2 = "NO RUN FE";
 Callback = NotificationBindable;
})
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
wait(3)
Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
game:GetService("RunService").Heartbeat:connect(function()
v.Velocity = Vector3.new(0,30,0)
wait(0.5)
end)
end
end
warn("Netless Activated!")
 
local IsDead = false
local StateMover = true
 
local playerss = workspace.non
local SwordAcc = playerss["Back_AccAccessory"].Handle
SwordAcc.Massless = true
SwordAcc.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
 
Bypass = "Death"
plr = game.Players.LocalPlayer
dead = false
char = plr.Character
 
 
 
bullet = workspace[plr.Name]["HumanoidRootPart"]
bullet.Transparency = 1
bhandle = bullet
bullet.Massless = true
 
mouse = plr:GetMouse()
head = char.Head
camera = workspace.CurrentCamera
lt = true
ltt = false
 
local function IsFirstPerson()
     return (head.CFrame.p - camera.CFrame.p).Magnitude < 1
end
 
     bbv = Instance.new("BodyPosition",bhandle)
     bbv.Position = char.Torso.CFrame.p
 
 
 
     mouse.Button1Down:Connect(function()
         if dead == false then
        lt = false
        ltt = false
     bbav = Instance.new("BodyAngularVelocity",bhandle)
     bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
     bbav.P = 1000000000000000000000000000
     bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
     game:GetService("Debris"):AddItem(bbav,0.1)
        if game.Players:GetPlayerFromCharacter(mouse.Target.Parent) then
            if mouse.Target.Parent.Name == char.Name or mouse.Target.Parent.Name == "non" then return end
              --repeat 
            game:GetService("RunService").RenderStepped:Wait()
            bbv.Position = (CFrame.new(mouse.Target.Parent.HumanoidRootPart.CFrame.p,char.Torso.CFrame.p) * CFrame.new(0,0,0)).p
            bhandle.Position = (CFrame.new(mouse.Target.Parent.HumanoidRootPart.CFrame.p,char.Torso.CFrame.p) * CFrame.new(0,0,0)).p
            wait(1)
            --until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
        elseif game.Players:GetPlayerFromCharacter(mouse.Target.Parent.Parent) then
            if mouse.Target.Parent.Name == char.Name or mouse.Target.Parent.Name == "non" then return end
            --repeat 
            game:GetService("RunService").RenderStepped:Wait()
            bbv.Position = (CFrame.new(mouse.Target.Parent.Parent.HumanoidRootPart.CFrame.p,char.Torso.CFrame.p) * CFrame.new(0,0,0)).p
            bhandle.Position = (CFrame.new(mouse.Target.Parent.Parent.HumanoidRootPart.CFrame.p,char.Torso.CFrame.p) * CFrame.new(0,0,0)).p
            wait(1)
            --until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
 
            else
       -- repeat 
        game:GetService("RunService").RenderStepped:Wait()
        wait(1)
        --until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
        end
        wait()
        lt = true
         end
         end)
 
    spawn(
        function()
            while true do
                game:GetService("RunService").Heartbeat:Wait()
                bullet.Velocity = Vector3.new(0,26,0)
         end
    end)
 
 plr:GetMouse().Button1Down:Connect(function()
attackingwithhrp = true	
end)
 
 
plr:GetMouse().Button1Up:Connect(function()
attackingwithhrp = false
end)
 
plr:GetMouse().Button1Down:Connect(function()
repeat wait() until attackingwithhrp == true
repeat
game:GetService("RunService").Heartbeat:Wait()
if plr:GetMouse().Target ~= nil then
bullet.Position = game:GetService("Players").LocalPlayer:GetMouse().Hit.p
end
until attackingwithhrp == false
end)
 
--Player Stuff--
player = game:GetService("Players").LocalPlayer
chara = playerss
 
ch = chara:GetChildren()
for i = 1, #ch do
if ch[i].Name == "Torso" then
ch[i].roblox.Transparency = 1
elseif ch[i].Name == "Head" then
ch[i].face.Transparency = 1
ch[i].Transparency = 1
elseif ch[i].ClassName == "Accessory" or ch[i].ClassName == "Shirt" or ch[i].ClassName == "Pants" or ch[i].ClassName == "ShirtGraphic" then
-- ch[i]:Destroy()
end
end
 
chara["Left Arm"].BrickColor = BrickColor.new("Cool yellow")
chara["Right Arm"].BrickColor = BrickColor.new("Cool yellow")
chara["Left Leg"].BrickColor = BrickColor.new("Medium blue")
chara["Right Leg"].BrickColor = BrickColor.new("Medium blue")
chara.Torso.BrickColor = BrickColor.new("Bright yellow")
 
--Outfit--
New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
 
function ScatterEff(part)
local eff1 = Instance.new("ParticleEmitter",part)
eff1.Size = NumberSequence.new(.1)
eff1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(.9,0),NumberSequenceKeypoint.new(1,1)})
eff1.LightEmission = 1
eff1.Lifetime = NumberRange.new(1)
eff1.Speed = NumberRange.new(1)
eff1.Rate = 100
eff1.VelocitySpread = 10000
eff1.Texture = "rbxassetid://347504241"
eff1.Color = ColorSequence.new(Color3.new(1,0,0))
local eff2 = Instance.new("ParticleEmitter",part)
eff2.Size = NumberSequence.new(.1)
eff2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(.9,0),NumberSequenceKeypoint.new(1,1)})
eff2.LightEmission = 1
eff2.Lifetime = NumberRange.new(1)
eff2.Speed = NumberRange.new(1)
eff2.Rate = 100
eff2.VelocitySpread = 10000
eff2.Texture = "rbxassetid://347504259"
eff2.Color = ColorSequence.new(Color3.new(1,0,0))
end
 
function BurningEff(part)
local eff1 = Instance.new("ParticleEmitter",part)
eff1.Size = NumberSequence.new(.1)
eff1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(.2,0),NumberSequenceKeypoint.new(1,1)})
eff1.LightEmission = 1
eff1.Lifetime = NumberRange.new(1)
eff1.Speed = NumberRange.new(0)
eff1.Rate = 100
eff1.Texture = "rbxassetid://347504241"
eff1.Acceleration = Vector3.new(0,10,0)
eff1.Color = ColorSequence.new(Color3.new(1,0,0))
local eff2 = Instance.new("ParticleEmitter",part)
eff2.Size = NumberSequence.new(.1)
eff2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(.2,0),NumberSequenceKeypoint.new(1,1)})
eff2.LightEmission = 1
eff2.Lifetime = NumberRange.new(1)
eff2.Speed = NumberRange.new(0)
eff2.Rate = 100
eff2.Texture = "rbxassetid://347504259"
eff2.Acceleration = Vector3.new(0,10,0)
eff2.Color = ColorSequence.new(Color3.new(1,0,0))
local eff3 = Instance.new("ParticleEmitter",part)
eff3.Size = NumberSequence.new(1)
eff3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)})
eff3.LightEmission = 1
eff3.Lifetime = NumberRange.new(1)
eff3.Speed = NumberRange.new(0)
eff3.Rate = 100
eff3.Texture = "rbxasset://textures/particles/fire_main.dds"
eff3.Acceleration = Vector3.new(0,10,0)
eff3.Color = ColorSequence.new(Color3.new(1,0,0))
end
 
FakeHead = New("Model",chara,"FakeHead",{})
MainPart = New("Part",FakeHead,"MainPart",{FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(2, 1, 1),CFrame = CFrame.new(2.29537678, 7.81603718, 0.746068954, 0.00980896503, 0.00110200304, 0.999957919, -0.000536994543, 1.00000548, -0.00109680078, -0.99994874, -0.0005262224, 0.00980964955),CanCollide = false,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("SpecialMesh",MainPart,"Mesh",{Scale = Vector3.new(1.25, 1.25, 1.25),})
face = New("Decal",MainPart,"face",{Texture = "rbxasset://textures/face.png",})
Weld = New("ManualWeld",MainPart,"Weld",{Part0 = MainPart,Part1 = chara.Head,C0 = CFrame.new(0, 0, 0, 0.00980896503, -0.000536994543, -0.99994874, 0.00110200304, 1.00000548, -0.0005262224, 0.999957919, -0.00109680078, 0.00980964955),C1 = CFrame.new(5.96046448e-008, -8.58306885e-006, 0, 0.00980896503, -0.000536994543, -0.99994874, 0.00110200304, 1.00000548, -0.0005262224, 0.999957919, -0.00109680078, 0.00980964955),})
FakeHead.MainPart.BrickColor = BrickColor.new("Cool yellow")
EyeFire = New("Part",FakeHead,"EyeFire",{BrickColor = BrickColor.new("Really red"),Material = Enum.Material.Neon,Size = Vector3.new(0.400000006, 0.200000003, 0.200000003),CFrame = CFrame.new(1.69668579, 8.11665249, 0.640022159, -0.00107900088, 0.999958038, -0.00980941113, -1.0000056, -0.00107390946, 0.000525554642, 0.000515007298, 0.00981007144, 0.999948859),CanCollide = false,Color = Color3.new(1, 0, 0),})
Mesh = New("CylinderMesh",EyeFire,"Mesh",{Offset = Vector3.new(0.0500000007, 0, -0.0399999991),Scale = Vector3.new(1, 0.150000006, 1),})
Weld = New("ManualWeld",EyeFire,"Weld",{Part0 = EyeFire,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.0010790003, -0.999999344, 0.000515000196, 0.999951363, -0.0010738963, 0.00981000345, -0.00980944186, 0.000525560055, 0.99995178),C1 = CFrame.new(0.100008011, 0.300009251, -0.600027919, 0.00980899762, -0.000536999898, -0.99995178, 0.00110200245, 0.999999344, -0.000526215415, 0.999951363, -0.00109678751, 0.00980958249),})
Chest = New("Model",chara,"Chest",{})
MainPart = New("Part",Chest,"MainPart",{Transparency = 1,Transparency = 1,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(2, 2, 1),CFrame = CFrame.new(2.2937007, 6.31611967, 0.746871948, 0.00980956201, 0.00110224239, 0.999954581, -0.000537135813, 1.00000238, -0.00109703222, -0.99995023, -0.000526354474, 0.00981019717),CanCollide = false,LeftSurface = Enum.SurfaceType.Weld,RightSurface = Enum.SurfaceType.Weld,})
Weld = New("ManualWeld",MainPart,"Weld",{Part0 = MainPart,Part1 = chara.Torso,C0 = CFrame.new(0, 0, 0, 0.009809535, -0.000537137908, -0.99994725, 0.00110225554, 1.00000858, -0.000526368851, 0.999961257, -0.00109705783, 0.00981026888),C1 = CFrame.new(5.96046448e-008, -9.05990601e-006, -2.38418579e-007, 0.00980956666, -0.000537143264, -0.99995023, 0.00110225484, 1.00000238, -0.000526361808, 0.999954581, -0.00109704456, 0.00981020182),})
CorruptedPart = New("Part",Chest,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.400000006, 0.800000072, 1),CFrame = CFrame.new(2.28977966, 7.11656427, 1.34486222, -0.00110228383, -0.00980954897, -0.9999578, -1.00000536, 0.000536905834, 0.00109708123, 0.000526248943, 0.99994868, -0.00981033035),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.0011022957, -0.999999225, 0.000526249292, -0.00980958622, 0.000536918582, 0.99995172, -0.999951243, 0.0010970803, -0.00981026702),C1 = CFrame.new(-0.598430753, 0.800122261, 0.00106739998, 0.00980956666, -0.000537143264, -0.99995023, 0.00110225484, 1.00000238, -0.000526361808, 0.999954581, -0.00109704456, 0.00981020182),})
CorruptedPart = New("Part",Chest,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.400000006, 0.400000066, 1),CFrame = CFrame.new(2.29174757, 6.71645212, 1.54485857, -0.00110228383, -0.00980954897, -0.9999578, -1.00000536, 0.000536905834, 0.00109708123, 0.000526248943, 0.99994868, -0.00981033035),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.0011022957, -0.999999225, 0.000526249292, -0.00980958622, 0.000536918582, 0.99995172, -0.999951243, 0.0010970803, -0.00981026702),C1 = CFrame.new(-0.798183441, 0.399908543, 0.00543618202, 0.00980956666, -0.000537143264, -0.99995023, 0.00110225484, 1.00000238, -0.000526361808, 0.999954581, -0.00109704456, 0.00981020182),})
LeftArm = New("Model",chara,"LeftArm",{})
MainPart = New("Part",LeftArm,"MainPart",{Transparency = 1,Transparency = 1,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(1, 2, 1),CFrame = CFrame.new(1.90889204, 6.31596565, 3.24640989, -0.0484240092, -0.0324009918, 0.998301268, -0.00117100019, 0.999474883, 0.0323822871, -0.998826265, 0.000399069104, -0.0484365262),CanCollide = false,})
Weld = New("ManualWeld",MainPart,"Weld",{Part0 = MainPart,Part1 = chara["Left Arm"],C0 = CFrame.new(0, 0, 0, -0.0484240092, -0.00117100019, -0.998826265, -0.0324009918, 0.999474883, 0.000399069104, 0.998301268, 0.0323822871, -0.0484365262),C1 = CFrame.new(0, -8.10623169e-006, -2.38418579e-007, -0.0484240092, -0.00117100019, -0.998826265, -0.0324009918, 0.999474883, 0.000399069104, 0.998301268, 0.0323822871, -0.0484365262),})
CorruptedPart = New("Part",LeftArm,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.400000006, 0.200000003),CFrame = CFrame.new(1.48370504, 6.50245714, 2.8663168, -0.048417028, -0.0324150361, 0.998301387, -0.00116700074, 0.999474525, 0.03239654, -0.998826742, 0.000403525919, -0.0484294258),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.048417028, -0.00116700074, -0.998826623, -0.0324150361, 0.999474466, 0.000403525832, 0.998301208, 0.0323965363, -0.0484294109),C1 = CFrame.new(0.400017738, 0.200018406, -0.400015235, -0.0484240092, -0.00117100019, -0.998826265, -0.0324009918, 0.999474883, 0.000399069104, 0.998301268, 0.0323822871, -0.0484365262),})
CorruptedPart = New("Part",LeftArm,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.600000024, 0.200000003),CFrame = CFrame.new(1.51924801, 6.60332775, 3.66543078, -0.048417028, -0.0324150361, 0.998301387, -0.00116700074, 0.999474525, 0.03239654, -0.998826742, 0.000403525919, -0.0484294258),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.048417028, -0.00116700074, -0.998826623, -0.0324150361, 0.999474466, 0.000403525832, 0.998301208, 0.0323965363, -0.0484294109),C1 = CFrame.new(-0.399997473, 0.300003052, -0.399972558, -0.0484240092, -0.00117100019, -0.998826265, -0.0324009918, 0.999474883, 0.000399069104, 0.998301268, 0.0323822871, -0.0484365262),})
EffCorruptedPart = New("Part",LeftArm,"EffCorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(1, 1, 1),CFrame = CFrame.new(1.92512023, 5.81624889, 3.24619365, -0.048417028, -0.0324150361, 0.998301387, -0.00116700074, 0.999474525, 0.03239654, -0.998826742, 0.000403525919, -0.0484294258),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",EffCorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",EffCorruptedPart,"Weld",{Part0 = EffCorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.048417028, -0.00116700074, -0.998826623, -0.0324150361, 0.999474466, 0.000403525832, 0.998301208, 0.0323965363, -0.0484294109),C1 = CFrame.new(1.52587891e-005, -0.49998045, 2.90870667e-005, -0.0484240092, -0.00117100019, -0.998826265, -0.0324009918, 0.999474883, 0.000399069104, 0.998301268, 0.0323822871, -0.0484365262),})
CorruptedPart = New("Part",LeftArm,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.800000072, 0.200000003),CFrame = CFrame.new(2.31463432, 6.72918367, 3.62673688, -0.048417028, -0.0324150361, 0.998301387, -0.00116700074, 0.999474525, 0.03239654, -0.998826742, 0.000403525919, -0.0484294258),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.048417028, -0.00116700074, -0.998826623, -0.0324150361, 0.999474466, 0.000403525832, 0.998301208, 0.0323965363, -0.0484294109),C1 = CFrame.new(-0.400012016, 0.400006294, 0.400012136, -0.0484240092, -0.00117100019, -0.998826265, -0.0324009918, 0.999474883, 0.000399069104, 0.998301268, 0.0323822871, -0.0484365262),})
CorruptedPart = New("Part",LeftArm,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.200000003, 0.200000003),CFrame = CFrame.new(1.50631011, 6.40297413, 3.26581192, -0.048417028, -0.0324150361, 0.998301387, -0.00116700074, 0.999474525, 0.03239654, -0.998826742, 0.000403525919, -0.0484294258),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.048417028, -0.00116700074, -0.998826623, -0.0324150361, 0.999474466, 0.000403525832, 0.998301208, 0.0323965363, -0.0484294109),C1 = CFrame.new(1.3589859e-005, 0.100014687, -0.400020242, -0.0484240092, -0.00117100019, -0.998826265, -0.0324009918, 0.999474883, 0.000399069104, 0.998301268, 0.0323822871, -0.0484365262),})
CorruptedPart = New("Part",LeftArm,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.400000036, 0.200000003),CFrame = CFrame.new(1.92179501, 6.51633835, 3.64602208, -0.048417028, -0.0324150361, 0.998301387, -0.00116700074, 0.999474525, 0.03239654, -0.998826742, 0.000403525919, -0.0484294258),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.048417028, -0.00116700074, -0.998826623, -0.0324150361, 0.999474466, 0.000403525832, 0.998301208, 0.0323965363, -0.0484294109),C1 = CFrame.new(-0.40000248, 0.200008869, 1.37090683e-005, -0.0484240092, -0.00117100019, -0.998826265, -0.0324009918, 0.999474883, 0.000399069104, 0.998301268, 0.0323822871, -0.0484365262),})
BurningEff(EffCorruptedPart)
LeftLeg = New("Model",chara,"LeftLeg",{})
MainPart = New("Part",LeftLeg,"MainPart",{Transparency = 1,Transparency = 1,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(1, 2, 1),CFrame = CFrame.new(2.2865479, 1.31659603, 1.24781799, 0.00980953407, 0.00110225566, 0.999961138, -0.000537137908, 1.00000858, -0.00109705783, -0.99994719, -0.000526368851, 0.00981026888),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,})
Weld = New("ManualWeld",MainPart,"Weld",{Part0 = MainPart,Part1 = chara["Left Leg"],C0 = CFrame.new(0, 0, 0, 0.00980953407, -0.000537137908, -0.99994719, 0.00110225566, 1.00000858, -0.000526368851, 0.999961138, -0.00109705783, 0.00981026888),C1 = CFrame.new(0, -8.58306885e-006, -2.38418579e-007, 0.00980953407, -0.000537137908, -0.99994719, 0.00110225566, 1.00000858, -0.000526368851, 0.999961138, -0.00109705783, 0.00981026888),})
EffCorruptedPart = New("Part",LeftLeg,"EffCorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(1, 0.200000048, 1),CFrame = CFrame.new(2.28007793, 0.400032878, 1.25993299, 1.00001979, -3.03611159e-007, -5.47617674e-007, 5.67175448e-007, 1.00001717, -5.60779881e-007, -1.86450779e-006, 9.50574758e-007, 0.99998951),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",EffCorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",EffCorruptedPart,"Weld",{Part0 = EffCorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 1, 5.86369708e-007, -2.15602267e-006, -2.8440752e-007, 0.999998569, 9.76819592e-007, -8.39119252e-007, -5.34477465e-007, 0.999998569),C1 = CFrame.new(-0.0116856098, -0.916567385, -0.00534534454, 0.00980953407, -0.000537137908, -0.99994719, 0.00110225566, 1.00000858, -0.000526368851, 0.999961138, -0.00109705783, 0.00981026888),})
CorruptedPart = New("Part",LeftLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.600000024, 0.200000003),CFrame = CFrame.new(1.88013697, 0.800038397, 0.859943509, 1.00001979, -3.03611159e-007, -5.47617674e-007, 5.67175448e-007, 1.00001717, -5.60779881e-007, -1.86450779e-006, 9.50574758e-007, 0.99998951),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 1, 5.86369708e-007, -2.15602267e-006, -2.8440752e-007, 0.999998569, 9.76819592e-007, -8.39119252e-007, -5.34477465e-007, 0.999998569),C1 = CFrame.new(0.3841483, -0.516796231, -0.40962553, 0.00980953407, -0.000537137908, -0.99994719, 0.00110225566, 1.00000858, -0.000526368851, 0.999961138, -0.00109705783, 0.00981026888),})
CorruptedPart = New("Part",LeftLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.800000012, 0.200000003),CFrame = CFrame.new(2.69002914, 0.915953577, 0.851962805, 0.999971032, 0.0011022269, -0.00980960391, -0.00109704852, 1.00001776, 0.000537177373, 0.00981036108, -0.000526409131, 0.999942601),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 0.999951303, -0.0010970087, 0.00981015898, 0.00110222446, 0.999999166, -0.000526388001, -0.00980970077, 0.00053719338, 0.99995172),C1 = CFrame.new(0.400011122, -0.399985313, 0.400013685, 0.00980953407, -0.000537137908, -0.99994719, 0.00110225566, 1.00000858, -0.000526368851, 0.999961138, -0.00109705783, 0.00981026888),})
CorruptedPart = New("Part",LeftLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.800000012, 0.200000003),CFrame = CFrame.new(1.88013721, 0.900040269, 1.65993917, 1.00001979, -3.03611159e-007, -5.47617674e-007, 5.67175448e-007, 1.00001717, -5.60779881e-007, -1.86450779e-006, 9.50574758e-007, 0.99998951),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 1, 5.86369708e-007, -2.15602267e-006, -2.8440752e-007, 0.999998569, 9.76819592e-007, -8.39119252e-007, -5.34477465e-007, 0.999998569),C1 = CFrame.new(-0.415866137, -0.41721642, -0.40188694, 0.00980953407, -0.000537137908, -0.99994719, 0.00110225566, 1.00000858, -0.000526368851, 0.999961138, -0.00109705783, 0.00981026888),})
CorruptedPart = New("Part",LeftLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.200000003, 0.200000003),CFrame = CFrame.new(1.88013721, 0.600035727, 1.25993288, 1.00001979, -3.03611159e-007, -5.47617674e-007, 5.67175448e-007, 1.00001717, -5.60779881e-007, -1.86450779e-006, 9.50574758e-007, 0.99998951),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 1, 5.86369708e-007, -2.15602267e-006, -2.8440752e-007, 0.999998569, 9.76819592e-007, -8.39119252e-007, -5.34477465e-007, 0.999998569),C1 = CFrame.new(-0.0157161951, -0.717007458, -0.405481935, 0.00980953407, -0.000537137908, -0.99994719, 0.00110225566, 1.00000858, -0.000526368851, 0.999961138, -0.00109705783, 0.00981026888),})
CorruptedPart = New("Part",LeftLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.400000006, 0.200000003),CFrame = CFrame.new(2.28007793, 0.700037479, 1.65993929, 1.00001967, -3.84054147e-007, 3.90969217e-006, 6.35045581e-007, 1.00001717, -5.60838998e-007, -6.19795173e-006, 9.32147486e-007, 0.99998951),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 1, 6.5424797e-007, -6.48946025e-006, -3.64865258e-007, 0.999998629, 9.58411874e-007, 3.61912225e-006, -5.34497644e-007, 0.999998629),C1 = CFrame.new(-0.411835551, -0.616776347, -0.00175023079, 0.00980953407, -0.000537137908, -0.99994719, 0.00110225566, 1.00000858, -0.000526368851, 0.999961138, -0.00109705783, 0.00981026888),})
CorruptedPart = New("Part",LeftLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 1.20000005, 0.200000003),CFrame = CFrame.new(2.68018699, 1.10004401, 1.65993941, 1.00001967, -3.84054147e-007, 3.90969217e-006, 6.35045581e-007, 1.00001717, -5.60838998e-007, -6.19795173e-006, 9.32147486e-007, 0.99998951),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 1, 6.5424797e-007, -6.48946025e-006, -3.64865258e-007, 0.999998629, 9.58411874e-007, 3.61912225e-006, -5.34497644e-007, 0.999998629),C1 = CFrame.new(-0.408125639, -0.216332912, 0.397896528, 0.00980953407, -0.000537137908, -0.99994719, 0.00110225566, 1.00000858, -0.000526368851, 0.999961138, -0.00109705783, 0.00981026888),})
CorruptedPart = New("Part",LeftLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.600000024, 0.200000003),CFrame = CFrame.new(2.68596959, 0.816166699, 1.25195313, 0.999971032, 0.0011022269, -0.00980960391, -0.00109704852, 1.00001776, 0.000537177373, 0.00981036108, -0.000526409131, 0.999942601),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 0.999951303, -0.0010970087, 0.00981015898, 0.00110222446, 0.999999166, -0.000526388001, -0.00980970077, 0.00053719338, 0.99995172),C1 = CFrame.new(5.20944595e-005, -0.499986172, 0.399987936, 0.00980953407, -0.000537137908, -0.99994719, 0.00110225566, 1.00000858, -0.000526368851, 0.999961138, -0.00109705783, 0.00981026888),})
ScatterEff(EffCorruptedPart)
RightArm = New("Model",chara,"RightArm",{})
MainPart = New("Part",RightArm,"MainPart",{Transparency = 1,Transparency = 1,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(1, 2, 1),CFrame = CFrame.new(2.011096, 6.31690788, -3.92582893, 0.00918400101, -0.262283146, 0.964947343, 0.259330034, 0.932596445, 0.251021653, -0.965745091, 0.247934431, 0.0765828639),CanCollide = false,})
 
local A0 = Instance.new("Attachment",MainPart)
A0.Position = Vector3.new(0.5,-1,0)
local A1 = Instance.new("Attachment",MainPart)
A1.Rotation = Vector3.new(0,90,45)
 
MainPart.Attachment.Name = "Attachment2"
 
SwordAcc:FindFirstChildOfClass("AlignOrientation").Attachment1 = MainPart.Attachment
SwordAcc:FindFirstChildOfClass("AlignPosition").Attachment1 = MainPart.Attachment2
 
Weld = New("ManualWeld",MainPart,"Weld",{Part0 = MainPart,Part1 = chara["Right Arm"],C0 = CFrame.new(0, 0, 0, 0.00918400101, 0.259330034, -0.965745091, -0.262283146, 0.932596445, 0.247934431, 0.964947343, 0.251021653, 0.0765828639),C1 = CFrame.new(-2.86102295e-006, -9.05990601e-006, -2.38418579e-006, 0.00918400101, 0.259330034, -0.965745091, -0.262283146, 0.932596445, 0.247934431, 0.964947343, 0.251021653, 0.0765828639),})
Hitbox = New("Part",RightArm,"Hitbox",{BrickColor = BrickColor.new("Really black"),Transparency = 1,Transparency = 1,Size = Vector3.new(1, 4, 1),CFrame = CFrame.new(22.2733669, 5.0842762, -22.1737366, -0.964945257, -0.262290984, 0.00919180829, -0.251027077, 0.93259424, 0.259333313, -0.0765930116, 0.247935042, -0.965744138),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Weld = New("ManualWeld",Hitbox,"Weld",{Part0 = Hitbox,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.964945257, -0.251027077, -0.0765930116, -0.262290984, 0.93259424, 0.247935042, 0.00919180829, 0.259333313, -0.965744138),C1 = CFrame.new(-1.52587891e-005, -1.00003147, -1.71661377e-005, 0.0091838371, 0.259330064, -0.965745151, -0.262283117, 0.932596445, 0.247934505, 0.964947283, 0.251021653, 0.0765827149),})
CorruptedPart = New("Part",RightArm,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(1, 2, 1),CFrame = CFrame.new(2.011096, 6.3169179, -3.92581391, -0.964945257, -0.262290984, 0.00919180829, -0.251027077, 0.93259424, 0.259333313, -0.0765930116, 0.247935042, -0.965744138),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.964945138, -0.251027018, -0.0765930042, -0.262290984, 0.932594121, 0.247935027, 0.00919180084, 0.259333313, -0.965744197),C1 = CFrame.new(-1.1920929e-005, 1.28746033e-005, 3.57627869e-006, 0.00918400101, 0.259330034, -0.965745091, -0.262283146, 0.932596445, 0.247934431, 0.964947343, 0.251021653, 0.0765828639),})
CorruptedPart = New("Part",RightArm,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(1, 0.600000024, 0.400000036),CFrame = CFrame.new(2.14866924, 6.03215551, -4.72580194, -0.964945078, 0.262291819, -0.00918725226, -0.251029015, -0.932593465, -0.259333432, -0.0765890032, -0.247936144, 0.965744317),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),MeshType = Enum.MeshType.Wedge,})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.964944899, -0.251028955, -0.0765889958, 0.262291819, -0.932593465, -0.247936144, -0.00918724574, -0.259333432, 0.965744257),C1 = CFrame.new(0.699988842, -0.499982834, 7.62939453e-006, 0.00918400101, 0.259330034, -0.965745091, -0.262283146, 0.932596445, 0.247934431, 0.964947343, 0.251021653, 0.0765828639),})
CorruptedPart = New("Part",RightArm,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(1, 1.20000005, 0.600000024),CFrame = CFrame.new(2.63876629, 4.02682734, -4.32773018, -0.964945078, 0.262291819, -0.00918725226, -0.251029015, -0.932593465, -0.259333432, -0.0765890032, -0.247936144, 0.965744317),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),MeshType = Enum.MeshType.Wedge,})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.964944899, -0.251028955, -0.0765889958, 0.262291819, -0.932593465, -0.247936144, -0.00918724574, -0.259333432, 0.965744257),C1 = CFrame.new(-0.199987888, -2.39999342, 3.02791595e-005, 0.00918400101, 0.259330034, -0.965745091, -0.262283146, 0.932596445, 0.247934431, 0.964947343, 0.251021653, 0.0765828639),})
CorruptedPart = New("Part",RightArm,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(1, 1, 0.600000024),CFrame = CFrame.new(1.62134135, 7.81954479, -3.94021821, 0.964945078, -0.262291819, -0.00918725226, 0.251029015, 0.932593465, -0.259333432, 0.0765890032, 0.247936144, 0.965744317),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),MeshType = Enum.MeshType.Wedge,})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 0.964944899, 0.251028955, 0.0765889958, -0.262291819, 0.932593465, 0.247936144, -0.00918724574, -0.259333432, 0.965744257),C1 = CFrame.new(0.399995804, 1.5000124, -2.38418579e-007, 0.00918400101, 0.259330034, -0.965745091, -0.262283146, 0.932596445, 0.247934431, 0.964947343, 0.251021653, 0.0765828639),})
CorruptedPart = New("Part",RightArm,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(1, 0.600000024, 0.400000036),CFrame = CFrame.new(2.35483098, 5.18234444, -4.53787422, -0.964945078, 0.262291819, -0.00918725226, -0.251029015, -0.932593465, -0.259333432, -0.0765890032, -0.247936144, 0.965744317),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),MeshType = Enum.MeshType.Wedge,})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.964944899, -0.251028955, -0.0765889958, 0.262291819, -0.932593465, -0.247936144, -0.00918724574, -0.259333432, 0.965744257),C1 = CFrame.new(0.300010204, -1.29999256, 1.40666962e-005, 0.00918400101, 0.259330034, -0.965745091, -0.262283146, 0.932596445, 0.247934431, 0.964947343, 0.251021653, 0.0765828639),})
CorruptedPart = New("Part",RightArm,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(1, 1, 0.600000024),CFrame = CFrame.new(1.88730097, 6.99068737, -4.57445002, -0.964945078, 0.262291819, -0.00918725226, -0.251029015, -0.932593465, -0.259333432, -0.0765890032, -0.247936144, 0.965744317),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("SpecialMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),MeshType = Enum.MeshType.Wedge,})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.964944899, -0.251028955, -0.0765889958, 0.262291819, -0.932593465, -0.247936144, -0.00918724574, -0.259333432, 0.965744257),C1 = CFrame.new(0.799996853, 0.50001812, 4.29153442e-006, 0.00918400101, 0.259330034, -0.965745091, -0.262283146, 0.932596445, 0.247934431, 0.964947343, 0.251021653, 0.0765828639),})
CorruptedPart = New("Part",RightArm,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(1, 0.800000072, 0.600000024),CFrame = CFrame.new(2.37646794, 4.9594202, -4.07979012, -0.964945316, -0.262290984, 0.00918756705, -0.251028091, 0.932593942, 0.259333163, -0.0765890256, 0.247935995, -0.965744197),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, -0.964945138, -0.251028031, -0.0765890107, -0.262290955, 0.932593882, 0.247935966, 0.0091875596, 0.259333193, -0.965744257),C1 = CFrame.new(-0.199994564, -1.39999104, 1.52587891e-005, 0.00918400101, 0.259330034, -0.965745091, -0.262283146, 0.932596445, 0.247934431, 0.964947343, 0.251021653, 0.0765828639),})
RightLeg = New("Model",chara,"RightLeg",{})
MainPart = New("Part",RightLeg,"MainPart",{Transparency = 1,Transparency = 1,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(1, 2, 1),CFrame = CFrame.new(2.29641008, 1.31540966, 0.248092994, 0.00933599845, 0.00110999751, 0.999955773, -0.0030579993, 0.999994755, -0.00108149007, -0.99995178, -0.0030477671, 0.00933934376),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,})
Weld = New("ManualWeld",MainPart,"Weld",{Part0 = MainPart,Part1 = chara["Right Leg"],C0 = CFrame.new(0, 0, 0, 0.00933599845, -0.0030579993, -0.99995178, 0.00110999751, 0.999994755, -0.0030477671, 0.999955773, -0.00108149007, 0.00933934376),C1 = CFrame.new(2.98023224e-008, -8.58306885e-006, 2.38418579e-007, 0.00933599845, -0.0030579993, -0.99995178, 0.00110999751, 0.999994755, -0.0030477671, 0.999955773, -0.00108149007, 0.00933934376),})
CorruptedPart = New("Part",RightLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.200000003, 0.200000003),CFrame = CFrame.new(2.70045996, 1.61376095, -0.149078026, 0.999955833, 0.00111049914, -0.0093326522, -0.00108199986, 0.999994755, 0.00305823679, 0.00933599938, -0.00304800388, 0.999951839),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 0.999955893, -0.00108199986, 0.00933599938, 0.00111049926, 0.999994755, -0.00304800388, -0.0093326522, 0.00305823679, 0.99995178),C1 = CFrame.new(0.400011688, 0.300008655, 0.400000095, 0.00933599845, -0.0030579993, -0.99995178, 0.00110999751, 0.999994755, -0.0030477671, 0.999955773, -0.00108149007, 0.00933934376),})
CorruptedPart = New("Part",RightLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.600000024, 0.200000003),CFrame = CFrame.new(1.90071809, 1.81462395, -0.157150015, 0.999955714, 0.00111050205, -0.0093366541, -0.00108199974, 0.999994755, 0.00305724167, 0.00933999754, -0.00304700364, 0.999951899),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 0.999955773, -0.00108199974, 0.00933999848, 0.00111050217, 0.999994755, -0.00304700388, -0.00933665317, 0.00305724121, 0.99995178),C1 = CFrame.new(0.400002658, 0.50000751, -0.399999142, 0.00933599845, -0.0030579993, -0.99995178, 0.00110999751, 0.999994755, -0.0030477671, 0.999955773, -0.00108149007, 0.00933934376),})
CorruptedPart = New("Part",RightLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.400000036, 0.200000003),CFrame = CFrame.new(1.896873, 1.71584904, 0.243133992, 0.999955714, 0.00111050205, -0.0093366541, -0.00108199974, 0.999994755, 0.00305724167, 0.00933999754, -0.00304700364, 0.999951899),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 0.999955773, -0.00108199974, 0.00933999848, 0.00111050217, 0.999994755, -0.00304700388, -0.00933665317, 0.00305724121, 0.99995178),C1 = CFrame.new(4.14252281e-006, 0.400008917, -0.399998784, 0.00933599845, -0.0030579993, -0.99995178, 0.00110999751, 0.999994755, -0.0030477671, 0.999955773, -0.00108149007, 0.00933934376),})
CorruptedPart = New("Part",RightLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.800000072, 0.200000003),CFrame = CFrame.new(1.89314091, 1.71706903, 0.643112063, 0.999955714, 0.00111050205, -0.0093366541, -0.00108199974, 0.999994755, 0.00305724167, 0.00933999754, -0.00304700364, 0.999951899),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 0.999955773, -0.00108199974, 0.00933999848, 0.00111050217, 0.999994755, -0.00304700388, -0.00933665317, 0.00305724121, 0.99995178),C1 = CFrame.new(-0.399993181, 0.400005698, -0.399996519, 0.00933599845, -0.0030579993, -0.99995178, 0.00110999751, 0.999994755, -0.0030477671, 0.999955773, -0.00108149007, 0.00933934376),})
EffCorruptedPart = New("Part",RightLeg,"EffCorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(1, 1.20000005, 1),CFrame = CFrame.new(2.29597116, 0.915416002, 0.249298006, 0.999955714, 0.00111051137, -0.00933665317, -0.00108199974, 0.999994755, 0.00305824191, 0.00933999754, -0.00304800365, 0.999951899),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",EffCorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",EffCorruptedPart,"Weld",{Part0 = EffCorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 0.999955773, -0.00108199974, 0.00933999848, 0.00111051148, 0.999994755, -0.00304800388, -0.00933665223, 0.00305824145, 0.99995178),C1 = CFrame.new(1.41263008e-005, -0.399995744, 5.00679016e-006, 0.00933599845, -0.0030579993, -0.99995178, 0.00110999751, 0.999994755, -0.0030477671, 0.999955773, -0.00108149007, 0.00933934376),})
CorruptedPart = New("Part",RightLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.400000006, 0.200000003),CFrame = CFrame.new(2.300596, 1.71419013, -0.153122023, 0.999955714, 0.00111051137, -0.00933665317, -0.00108199974, 0.999994755, 0.00305824191, 0.00933999754, -0.00304800365, 0.999951899),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 0.999955773, -0.00108199974, 0.00933999848, 0.00111051148, 0.999994755, -0.00304800388, -0.00933665223, 0.00305824145, 0.99995178),C1 = CFrame.new(0.400015235, 0.400005817, 7.39097595e-006, 0.00933599845, -0.0030579993, -0.99995178, 0.00110999751, 0.999994755, -0.0030477671, 0.999955773, -0.00108149007, 0.00933934376),})
CorruptedPart = New("Part",RightLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.600000024, 0.200000003),CFrame = CFrame.new(2.69322205, 1.81620288, 0.650299072, 0.999955714, 0.00111051137, -0.00933665317, -0.00108199974, 0.999994755, 0.00305824191, 0.00933999754, -0.00304800365, 0.999951899),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 0.999955773, -0.00108199974, 0.00933999848, 0.00111051148, 0.999994755, -0.00304800388, -0.00933665223, 0.00305824145, 0.99995178),C1 = CFrame.new(-0.400013447, 0.500005245, 0.400009155, 0.00933599845, -0.0030579993, -0.99995178, 0.00110999751, 0.999994755, -0.0030477671, 0.999955773, -0.00108149007, 0.00933934376),})
CorruptedPart = New("Part",RightLeg,"CorruptedPart",{BrickColor = BrickColor.new("Really black"),Material = Enum.Material.Granite,Size = Vector3.new(0.200000003, 0.400000006, 0.200000003),CFrame = CFrame.new(2.69684124, 1.71498096, 0.250625998, 0.999955714, 0.00111051137, -0.00933665317, -0.00108199974, 0.999994755, 0.00305824191, 0.00933999754, -0.00304800365, 0.999951899),CanCollide = false,BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
Mesh = New("BlockMesh",CorruptedPart,"Mesh",{Scale = Vector3.new(1.10000002, 1.10000002, 1.10000002),})
Weld = New("ManualWeld",CorruptedPart,"Weld",{Part0 = CorruptedPart,Part1 = MainPart,C0 = CFrame.new(0, 0, 0, 0.999955773, -0.00108199974, 0.00933999848, 0.00111051148, 0.999994755, -0.00304800388, -0.00933665223, 0.00305824145, 0.99995178),C1 = CFrame.new(-1.63316727e-005, 0.400005937, 0.400005102, 0.00933599845, -0.0030579993, -0.99995178, 0.00110999751, 0.999994755, -0.0030477671, 0.999955773, -0.00108149007, 0.00933934376),})
ScatterEff(EffCorruptedPart)
 
sa = RightArm:GetChildren()
for i = 1, #sa do
ScatterEff(sa[i])
end
 
local eff1 = Instance.new("ParticleEmitter",EyeFire)
eff1.Size = NumberSequence.new(.1)
eff1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(.2,0),NumberSequenceKeypoint.new(1,1)})
eff1.LightEmission = 1
eff1.Lifetime = NumberRange.new(.5)
eff1.Speed = NumberRange.new(1)
eff1.EmissionDirection = "Front"
eff1.Rate = 100
eff1.Texture = "rbxassetid://347504241"
eff1.Acceleration = Vector3.new(0,10,0)
eff1.Color = ColorSequence.new(Color3.new(1,0,0))
local eff2 = Instance.new("ParticleEmitter",EyeFire)
eff2.Size = NumberSequence.new(.1)
eff2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(.2,0),NumberSequenceKeypoint.new(1,1)})
eff2.LightEmission = 1
eff2.Lifetime = NumberRange.new(.5)
eff2.Speed = NumberRange.new(1)
eff2.EmissionDirection = "Front"
eff2.Rate = 100
eff2.Texture = "rbxassetid://347504259"
eff2.Acceleration = Vector3.new(0,10,0)
eff2.Color = ColorSequence.new(Color3.new(1,0,0))
local eff3 = Instance.new("ParticleEmitter",EyeFire)
eff3.Size = NumberSequence.new(.1)
eff3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)})
eff3.LightEmission = 1
eff3.Lifetime = NumberRange.new(.5)
eff3.Speed = NumberRange.new(1)
eff3.EmissionDirection = "Front"
eff3.Rate = 100
eff3.Texture = "rbxasset://textures/particles/fire_main.dds"
eff3.Acceleration = Vector3.new(0,10,0)
eff3.Color = ColorSequence.new(Color3.new(1,0,0))
 
--Sounds--
slashsnd = New("Sound",chara.Torso,"Slash",{SoundId = "rbxassetid://28144425",PlaybackSpeed = .7,Volume = 5})
hitsnd = New("Sound",chara.Torso,"Hit",{SoundId = "rbxassetid://429400881",PlaybackSpeed = .7,Volume = 5})
telesnd = New("Sound",chara.Torso,"Tele",{SoundId = "rbxassetid://2767090",PlaybackSpeed = .7,Volume = 5})
burnsnd = New("Sound",chara.Torso,"Burn",{SoundId = "rbxassetid://32791565",PlaybackSpeed = .7,Volume = 5})
music1 = New("Sound",chara.Torso,"Music1",{SoundId = "rbxassetid://678930213",PlaybackSpeed = .1,Volume = 10,Looped = true})
music2 = New("Sound",chara.Torso,"Music1",{SoundId = "rbxassetid://678930213",PlaybackSpeed = .1,Volume = 10,Looped = true})
deathmus = New("Sound",chara.Torso,"DeathMus",{SoundId = "rbxassetid://19094700",PlaybackSpeed = .5,Volume = 5,Looped = true})
deathex = New("Sound",chara.Torso,"DeathEx",{SoundId = "rbxassetid://11984351",PlaybackSpeed = 1,Volume = 5})
music1:Play()
music2:Play()
 
--Animations--
walkanim = chara.Humanoid:LoadAnimation(New("Animation",chara,"Walk",{AnimationId = "rbxassetid://180426354"}))
swinganim = chara.Humanoid:LoadAnimation(New("Animation",chara,"Swing",{AnimationId = "rbxassetid://186934658"}))
 
chara.Humanoid.Running:connect(function(speed) 
 
	if speed > 3 then
 
		walkanim:Play()
	else
 
		walkanim:Stop()
	end
end)
 
--Name Tag--
local naeeym = Instance.new("BillboardGui",chara)
naeeym.Size = UDim2.new(0,100,0,40)
naeeym.StudsOffset = Vector3.new(0,2,0)
naeeym.Adornee = chara.Head
local tecks = Instance.new("TextLabel",naeeym)
tecks.BackgroundTransparency = 1
tecks.BorderSizePixel = 0
tecks.Text = "John Doe"
tecks.Font = "Fantasy"
tecks.FontSize = "Size24"
tecks.TextStrokeTransparency = 0
tecks.TextStrokeColor3 = Color3.new(0,0,0)
tecks.TextColor3 = Color3.new(0,0,0)
tecks.Size = UDim2.new(1,0,0.5,0)
 
--Skybox--
skybox = Instance.new("Part",chara)
skybox.Size = Vector3.new(0,0,0)
skybox.Anchored = true
skybox.CanCollide = true
skyboxmesh = Instance.new("SpecialMesh",skybox)
skyboxmesh.MeshId = "http://www.roblox.com/asset/?id=1527559"
skyboxmesh.TextureId = "http://www.roblox.com/asset/?id=1529455"
skyboxmesh.VertexColor = Vector3.new(1,0,0)
skyboxmesh.Scale = Vector3.new(-3000,-1000,-3000)
 
--Soul Steal--
function SoulSteal(pos)
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",chara)
soul.Size = Vector3.new(0,0,0)
soul.CanCollide = false
soul.Anchored = false
soul.Position = pos
soul.CFrame = CFrame.new(pos.X,pos.Y,pos.Z)
soul.Transparency = 1
local ptc = Instance.new("ParticleEmitter",soul)
ptc.Texture = "http://www.roblox.com/asset/?id=413366101"
ptc.Size = NumberSequence.new(.5)
ptc.LockedToPart = true
ptc.Speed = NumberRange.new(0)
ptc.Lifetime = NumberRange.new(9999)
local bodpos = Instance.new("BodyPosition",soul)
bodpos.Position = pos
wait(2)
soul.Touched:connect(function(hit)
if hit.Parent == chara then
soul:Destroy()
end
end)
while soul do
wait(.1)
bodpos.Position = chara.Torso.Position
end
end)
soulst()
end
 
--Death of a Mortal--
function KillMortal(hitdude)
local torsy = nil
if hitdude:FindFirstChild("Torso")~=nil then
torsy = hitdude.Torso
DamageFling(hitdude)
elseif hitdude:FindFirstChild("UpperTorso")~=nil then
torsy = hitdude.UpperTorso
end
local val = Instance.new("ObjectValue",hitdude)
val.Name = "HasBeenHit"
-- hitdude:BreakJoints()
-- hitdude.Humanoid:Destroy()
SoulSteal(torsy.Position)
local chi = hitdude:GetChildren()
for i = 1, #chi do
if chi[i].ClassName == "Part" or chi[i].ClassName == "MeshPart" then
-- local bodpos = Instance.new("BodyPosition",chi[i])
-- bodpos.Position = chi[i].Position + Vector3.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))
ScatterEff(chi[i])
-- chi[i].BrickColor = BrickColor.new("Really black")
end
end
for i = 1, 4 do
for i = 1, #chi do
if chi[i].ClassName == "Part" or chi[i].ClassName == "MeshPart" then
-- chi[i].Transparency = chi[i].Transparency + .25
wait(.01)
end
end
end
for i = 1, #chi do
if chi[i].ClassName == "Part" or chi[i].ClassName == "MeshPart" then
-- chi[i]:Destroy()
end
end
end
 
--Arm Touch--
bladeactive = false
Hitbox.Touched:connect(function(hit)
if bladeactive == true then
if hit.Parent:FindFirstChild("Humanoid")~= nil and hit.Parent:FindFirstChild("HasBeenHit")== nil and hit.Parent ~= chara then
hitsnd:Play()
KillMortal(hit.Parent)
end
end
end)
 
--Teleport--
function Teleport(pos)
telesnd:Play()
local ch = chara:GetChildren()
for i = 1, #ch do
if ch[i].ClassName == "Part" and ch[i].Name ~= "HumanoidRootPart" then
local trace = Instance.new("Part",game.Workspace)
trace.Size = ch[i].Size
trace.Material = "Neon"
trace.BrickColor = BrickColor.new("Really black")
trace.Transparency = .3
trace.CanCollide = false
trace.Anchored = true
trace.CFrame = ch[i].CFrame
if ch[i].Name == "Head" then
mehs = Instance.new("CylinderMesh",trace)
mehs.Scale = Vector3.new(1.25,1.25,1.25)
end
tracedisappear = coroutine.wrap(function()
wait(1)
for i = 1, 7 do
wait(.1)
trace.Transparency = trace.Transparency + .1
end
trace:Destroy()
end)
tracedisappear()
end
end
 
g1 = Instance.new("BodyGyro", chara.HumanoidRootPart)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
g1.CFrame = CFrame.new(playerss:FindFirstChild("HumanoidRootPart").Position,Mouse.Hit.p)
 
game:GetService("Debris"):AddItem(g1,.05)
 
playerss:FindFirstChild("HumanoidRootPart").CFrame = CFrame.new(Mouse.Hit.p) * CFrame.new(0,3.3,0)
 
end
 
--Grab--
function Grab(mouse)
local hit = mouse.Target
if hit ~= nil then
if hit.Parent:FindFirstChild("Humanoid")~=nil then
local torsy = nil
if hit.Parent:FindFirstChild("Torso")~=nil then
torsy = hit.Parent.Torso
elseif hit.Parent:FindFirstChild("UpperTorso")~=nil then
torsy = hit.Parent.UpperTorso
end
local bodpos = Instance.new("BodyPosition",torsy)
bodpos.Position = torsy.Position
wait(1)
burnsnd:Play()
hit.Parent.Humanoid.MaxHealth = 100
bodpos.Position = bodpos.Position + Vector3.new(0,4,0)
for i = 1, 10 do
wait(.1)
BurningEff(torsy)
hit.Parent.Humanoid.Health = hit.Parent.Humanoid.Health - 10
end
KillMortal(hit.Parent)
end
else end
end
 
--Button1Down--
dell = false
function onButton1Down()
if dell == false then
dell = true
swinganim:Play()
bladeactive = true
slashsnd:Play()
wait(.7)
bladeactive = false
dell = false
swinganim:Stop()
end
end
 
--KeyDowns--
function onKeyDown(key)
if key == "z" then
Teleport(Mouse.Hit.p + Vector3.new(0,2,0))
elseif key == "x" then
Grab(Mouse)
end
end
 
--Mouse Functions--
Mouse = player:GetMouse()
if Mouse then
Mouse.Button1Down:connect(onButton1Down)
Mouse.KeyDown:connect(onKeyDown)
end
 
--Death--
chara.Humanoid.Died:connect(function()
local pat = Instance.new("Part",game.Workspace)
pat.Transparency = 1
pat.Anchored = true
pat.CFrame = chara.Torso.CFrame
naeeym.Parent = pat
naeeym.Adornee = pat
skybox.Parent = game.Workspace
tecks.Text = "BAD CHOICE"
tecks.FontSize = "Size48"
tecks.TextColor3 = Color3.new(1,0,0)
music1:Stop()
music2:Stop()
deathmus.Parent = game.Workspace
deathex.Parent = game.Workspace
deathmus:Play()
deathex:Play()
game.Lighting.OutdoorAmbient = Color3.new(0,0,0)
game.Lighting.TimeOfDay = "00:00:00"
game.Lighting.FogColor = Color3.new(0,0,0)
game.Lighting.FogEnd = 1000
local ex = Instance.new("Explosion",game.Workspace)
ex.Position = chara.Torso.Position
ex.Visible = false
ex.BlastRadius = 999999999999999999999999
ex.BlastPressure = 9999999999999999999999999
end)
 
--Loop Function--
while true do
wait(.01)
chance = math.random(0,100)
if chance < 10 then
sel = math.random(1,3)
if sel == 1 then
tecks.Text = "NOHOPE"
elseif sel == 2 then
tecks.Text = "GIVEUP"
elseif sel == 3 then
tecks.Text = "BURNINHELL"
end
else tecks.Text = "John Doe"
end
if chara.Humanoid.Health > 0 then
chara.Humanoid.MaxHealth = math.huge
chara.Humanoid.Health = math.huge
game.Lighting.OutdoorAmbient = Color3.new(1,0,0)
game.Lighting.Ambient = Color3.new(1,0,0)
chara["Left Arm"].BrickColor = BrickColor.new("Cool yellow")
chara["Right Arm"].BrickColor = BrickColor.new("Cool yellow")
chara["Left Leg"].BrickColor = BrickColor.new("Medium blue")
chara["Right Leg"].BrickColor = BrickColor.new("Medium blue")
chara.Torso.BrickColor = BrickColor.new("Bright yellow")
chara["Left Arm"].Anchored = false
chara["Right Arm"].Anchored = false
chara["Left Leg"].Anchored = false
chara["Right Leg"].Anchored = false
chara.Torso.Anchored = false
ch = chara:GetChildren()
for i = 1, #ch do
if ch[i].ClassName == "Accessory" or ch[i].ClassName == "Hat" then
-- ch[i]:Destroy()
end
end
tools = player.Backpack:GetChildren()
for i = 1, #tools do
if tools[i].ClassName == "HopperBin" then
-- tools[i]:Destroy()
end
end
skybox.CFrame = skybox.CFrame * CFrame.fromEulerAnglesXYZ(0,math.rad(1),0)
tecks.Position = UDim2.new(0,math.random(-3,3),0,math.random(-3,3))
local jtrace = Instance.new("Part",game.Workspace)
jtrace.Name = "JDTrace"
jtrace.Size = Vector3.new(10,0,10)
jtrace.Position = chara.Torso.Position
jtrace.CFrame = chara.Torso.CFrame - Vector3.new(0,3,0)
jtrace.Anchored = true
jtrace.CanCollide = false
jtrace.BrickColor = BrickColor.new("Really black")
jtrace.Material = "Granite"
BurningEff(jtrace)
game.Debris:AddItem(jtrace,1)
end
end
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "net bypass",
	Callback = function()
		    -- when you reset make sure to re-execute this or just make this execute in a loop
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
    if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
    game:GetService("RunService").Heartbeat:connect(function()
    v.Velocity = Vector3.new(-30,0,0)
    end)
    end
    end
    
    game:GetService("StarterGui"):SetCore("SendNotification", { 
        Title = "Notification";
        Text = "Netless Ran";
        Icon = "rbxthumb://type=Asset&id=5107182114&w=150&h=150"})
    Duration = 16;
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "anti fling",
	Callback = function()
		-- // Constants \\ --
-- [ Services ] --
local Services = setmetatable({}, {__index = function(Self, Index)
local NewService = game.GetService(game, Index)
if NewService then
Self[Index] = NewService
end
return NewService
end})

-- [ LocalPlayer ] --
local LocalPlayer = Services.Players.LocalPlayer

-- // Functions \\ --
local function PlayerAdded(Player)
   local Detected = false
   local Character;
   local PrimaryPart;

   local function CharacterAdded(NewCharacter)
       Character = NewCharacter
       repeat
           wait()
           PrimaryPart = NewCharacter:FindFirstChild("HumanoidRootPart")
       until PrimaryPart
       Detected = false
   end

   CharacterAdded(Player.Character or Player.CharacterAdded:Wait())
   Player.CharacterAdded:Connect(CharacterAdded)
   Services.RunService.Heartbeat:Connect(function()
       if (Character and Character:IsDescendantOf(workspace)) and (PrimaryPart and PrimaryPart:IsDescendantOf(Character)) then
           if PrimaryPart.AssemblyAngularVelocity.Magnitude > 50 or PrimaryPart.AssemblyLinearVelocity.Magnitude > 100 then
               if Detected == false then
                   game.StarterGui:SetCore("ChatMakeSystemMessage", {
                       Text = "Fling Exploit detected, Player: " .. tostring(Player);
                       Color = Color3.fromRGB(255, 200, 0);
                   })
               end
               Detected = true
               for i,v in ipairs(Character:GetDescendants()) do
                   if v:IsA("BasePart") then
                       v.CanCollide = false
                       v.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                       v.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                       v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
                   end
               end
               PrimaryPart.CanCollide = false
               PrimaryPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
               PrimaryPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
               PrimaryPart.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
           end
       end
   end)
end

-- // Event Listeners \\ --
for i,v in ipairs(Services.Players:GetPlayers()) do
   if v ~= LocalPlayer then
       PlayerAdded(v)
   end
end
Services.Players.PlayerAdded:Connect(PlayerAdded)

local LastPosition = nil
Services.RunService.Heartbeat:Connect(function()
   pcall(function()
       local PrimaryPart = LocalPlayer.Character.PrimaryPart
       if PrimaryPart.AssemblyLinearVelocity.Magnitude > 250 or PrimaryPart.AssemblyAngularVelocity.Magnitude > 250 then
           PrimaryPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
           PrimaryPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
           PrimaryPart.CFrame = LastPosition

           game.StarterGui:SetCore("ChatMakeSystemMessage", {
               Text = "You were flung. Neutralizing velocity.";
               Color = Color3.fromRGB(255, 0, 0);
           })
       elseif PrimaryPart.AssemblyLinearVelocity.Magnitude < 50 or PrimaryPart.AssemblyAngularVelocity.Magnitude > 50 then
           LastPosition = PrimaryPart.CFrame
       end
   end)
end)
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe switcher (free)",
	Callback = function()
		--amogus
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
game:GetService("RunService").Heartbeat:connect(function()
v.Velocity = Vector3.new(45,0,0)
end)
end
end
 
Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
-----OPTIONS
local ToolName = "Back_AccAccessory" ----- the hats name on explorer/dex (not name in catalog)
local NoSound = false ----- sound or no sound (Background Music)
local OldModel = false ----- Use Old Model or your accessory

local IsDead = false
local StateMover = true

local playerss = workspace.non
local maybe = playerss[ToolName].Handle
local bbv,bullet
if Bypass == "death" then
	bullet = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	bullet.Transparency = 0
	bullet.Massless = true
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end

	bbv = Instance.new("BodyPosition",bullet)
    bbv.Position = playerss.Torso.CFrame.p
end


maybe:FindFirstChildOfClass("AlignPosition").Name = "AlignPosition2"
maybe:FindFirstChildOfClass("AlignOrientation").Name = "AlignOrientation2"

playerss.Torso.WaistBackAttachment.Position = Vector3.new(-0, 2, 0.6)
playerss.Torso.WaistBackAttachment.Orientation = Vector3.new(-4.16, -190, 99.8)

if Bypass == "death" then
coroutine.wrap(function()
	while true do
		if not playerss or not playerss:FindFirstChildOfClass("Humanoid") or playerss:FindFirstChildOfClass("Humanoid").Health <= 0 then IsDead = true; return end
		if StateMover then
			bbv.Position = playerss.Torso.CFrame.p
    		bullet.Position = playerss.Torso.CFrame.p
		end
		game:GetService("RunService").RenderStepped:wait()
	end
end)()
end

local CDDF = {}
local DamageFling = function(DmgPer)
	if IsDead or Bypass ~= "death" or (DmgPer.Name == playerss.Name and DmgPer.Name == "non") or CDDF[DmgPer] or not DmgPer or not DmgPer:FindFirstChildOfClass("Humanoid") or DmgPer:FindFirstChildOfClass("Humanoid").Health <= 0 then return end
	CDDF[DmgPer] = true; StateMover = false
	local PosFling = (DmgPer:FindFirstChild("HumanoidRootPart") and DmgPer:FindFirstChild("HumanoidRootPart") .CFrame.p) or (DmgPer:FindFirstChildOfClass("Part") and DmgPer:FindFirstChildOfClass("Part").CFrame.p)
    bbav = Instance.new("BodyAngularVelocity",bullet)
    bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
    bbav.P = 1000000000000000000000000000
    bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
    game:GetService("Debris"):AddItem(bbav,0.1)
    bullet.Rotation = playerss.Torso.Rotation
	for _=1,15 do
		bbv.Position = PosFling
		bullet.Position = PosFling
        wait(0.03)
	end
	bbv.Position = playerss.Torso.CFrame.p
    bullet.Position = playerss.Torso.CFrame.p
	CDDF[DmgPer] = false; StateMover = true
end

cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
SpecialMesh2 = Instance.new("SpecialMesh")
Part3 = Instance.new("Part")
SpecialMesh4 = Instance.new("SpecialMesh")
Weld5 = Instance.new("Weld")
Weld6 = Instance.new("Weld")
Weld7 = Instance.new("Weld")
Weld8 = Instance.new("Weld")
Weld9 = Instance.new("Weld")
Weld10 = Instance.new("Weld")
Weld11 = Instance.new("Weld")
Weld12 = Instance.new("Weld")
Weld13 = Instance.new("Weld")
Weld14 = Instance.new("Weld")
Weld15 = Instance.new("Weld")
Weld16 = Instance.new("Weld")
Weld17 = Instance.new("Weld")
Weld18 = Instance.new("Weld")
Weld19 = Instance.new("Weld")
Weld20 = Instance.new("Weld")
Weld21 = Instance.new("Weld")
Weld22 = Instance.new("Weld")
Weld23 = Instance.new("Weld")
Weld24 = Instance.new("Weld")
Weld25 = Instance.new("Weld")
Weld26 = Instance.new("Weld")
Weld27 = Instance.new("Weld")
Weld28 = Instance.new("Weld")
Weld29 = Instance.new("Weld")
Weld30 = Instance.new("Weld")
Weld31 = Instance.new("Weld")
Weld32 = Instance.new("Weld")
Weld33 = Instance.new("Weld")
Weld34 = Instance.new("Weld")
Weld35 = Instance.new("Weld")
Weld36 = Instance.new("Weld")
Weld37 = Instance.new("Weld")
Weld38 = Instance.new("Weld")
Weld39 = Instance.new("Weld")
Weld40 = Instance.new("Weld")
Weld41 = Instance.new("Weld")
Weld42 = Instance.new("Weld")
Weld43 = Instance.new("Weld")
Weld44 = Instance.new("Weld")
Weld45 = Instance.new("Weld")
Weld46 = Instance.new("Weld")
Weld47 = Instance.new("Weld")
Weld48 = Instance.new("Weld")
Weld49 = Instance.new("Weld")
Weld50 = Instance.new("Weld")
Weld51 = Instance.new("Weld")
Weld52 = Instance.new("Weld")
Weld53 = Instance.new("Weld")
Weld54 = Instance.new("Weld")
Weld55 = Instance.new("Weld")
Weld56 = Instance.new("Weld")
Weld57 = Instance.new("Weld")
Weld58 = Instance.new("Weld")
Weld59 = Instance.new("Weld")
Weld60 = Instance.new("Weld")
Weld61 = Instance.new("Weld")
Weld62 = Instance.new("Weld")
Weld63 = Instance.new("Weld")
Weld64 = Instance.new("Weld")
Weld65 = Instance.new("Weld")
Weld66 = Instance.new("Weld")
Weld67 = Instance.new("Weld")
Weld68 = Instance.new("Weld")
Weld69 = Instance.new("Weld")
Weld70 = Instance.new("Weld")
Weld71 = Instance.new("Weld")
Weld72 = Instance.new("Weld")
Weld73 = Instance.new("Weld")
Weld74 = Instance.new("Weld")
Weld75 = Instance.new("Weld")
Weld76 = Instance.new("Weld")
Weld77 = Instance.new("Weld")
Weld78 = Instance.new("Weld")
Weld79 = Instance.new("Weld")
Weld80 = Instance.new("Weld")
Weld81 = Instance.new("Weld")
Weld82 = Instance.new("Weld")
Weld83 = Instance.new("Weld")
Weld84 = Instance.new("Weld")
Weld85 = Instance.new("Weld")
Weld86 = Instance.new("Weld")
Weld87 = Instance.new("Weld")
Weld88 = Instance.new("Weld")
Weld89 = Instance.new("Weld")
Weld90 = Instance.new("Weld")
Weld91 = Instance.new("Weld")
Weld92 = Instance.new("Weld")
Weld93 = Instance.new("Weld")
Weld94 = Instance.new("Weld")
Weld95 = Instance.new("Weld")
Weld96 = Instance.new("Weld")
Weld97 = Instance.new("Weld")
Weld98 = Instance.new("Weld")
Weld99 = Instance.new("Weld")
Weld100 = Instance.new("Weld")
Weld101 = Instance.new("Weld")
Weld102 = Instance.new("Weld")
Weld103 = Instance.new("Weld")
Weld104 = Instance.new("Weld")
Weld105 = Instance.new("Weld")
Weld106 = Instance.new("Weld")
Weld107 = Instance.new("Weld")
Weld108 = Instance.new("Weld")
Weld109 = Instance.new("Weld")
Weld110 = Instance.new("Weld")
Weld111 = Instance.new("Weld")
Weld112 = Instance.new("Weld")
Weld113 = Instance.new("Weld")
Weld114 = Instance.new("Weld")
Weld115 = Instance.new("Weld")
Weld116 = Instance.new("Weld")
Weld117 = Instance.new("Weld")
Weld118 = Instance.new("Weld")
Weld119 = Instance.new("Weld")
Weld120 = Instance.new("Weld")
Weld121 = Instance.new("Weld")
Weld122 = Instance.new("Weld")
Weld123 = Instance.new("Weld")
Weld124 = Instance.new("Weld")
Weld125 = Instance.new("Weld")
Weld126 = Instance.new("Weld")
Weld127 = Instance.new("Weld")
Weld128 = Instance.new("Weld")
Weld129 = Instance.new("Weld")
Weld130 = Instance.new("Weld")
Weld131 = Instance.new("Weld")
Weld132 = Instance.new("Weld")
Weld133 = Instance.new("Weld")
Weld134 = Instance.new("Weld")
Weld135 = Instance.new("Weld")
Weld136 = Instance.new("Weld")
Weld137 = Instance.new("Weld")
Weld138 = Instance.new("Weld")
Weld139 = Instance.new("Weld")
Weld140 = Instance.new("Weld")
Weld141 = Instance.new("Weld")
Weld142 = Instance.new("Weld")
Weld143 = Instance.new("Weld")
Weld144 = Instance.new("Weld")
Weld145 = Instance.new("Weld")
Weld146 = Instance.new("Weld")
Weld147 = Instance.new("Weld")
Weld148 = Instance.new("Weld")
Weld149 = Instance.new("Weld")
Weld150 = Instance.new("Weld")
Weld151 = Instance.new("Weld")
Weld152 = Instance.new("Weld")
Weld153 = Instance.new("Weld")
Weld154 = Instance.new("Weld")
Weld155 = Instance.new("Weld")
Weld156 = Instance.new("Weld")
Weld157 = Instance.new("Weld")
Weld158 = Instance.new("Weld")
Weld159 = Instance.new("Weld")
Weld160 = Instance.new("Weld")
Weld161 = Instance.new("Weld")
Weld162 = Instance.new("Weld")
Part163 = Instance.new("Part")
SpecialMesh164 = Instance.new("SpecialMesh")
Part165 = Instance.new("Part")
SpecialMesh166 = Instance.new("SpecialMesh")
Part167 = Instance.new("Part")
SpecialMesh168 = Instance.new("SpecialMesh")
Part169 = Instance.new("Part")
SpecialMesh170 = Instance.new("SpecialMesh")
Part171 = Instance.new("Part")
SpecialMesh172 = Instance.new("SpecialMesh")
Part173 = Instance.new("Part")
SpecialMesh174 = Instance.new("SpecialMesh")
Part175 = Instance.new("Part")
SpecialMesh176 = Instance.new("SpecialMesh")
Part177 = Instance.new("Part")
SpecialMesh178 = Instance.new("SpecialMesh")
Part179 = Instance.new("Part")
SpecialMesh180 = Instance.new("SpecialMesh")
Part181 = Instance.new("Part")
SpecialMesh182 = Instance.new("SpecialMesh")
Part183 = Instance.new("Part")
SpecialMesh184 = Instance.new("SpecialMesh")
Part185 = Instance.new("Part")
SpecialMesh186 = Instance.new("SpecialMesh")
Part187 = Instance.new("Part")
SpecialMesh188 = Instance.new("SpecialMesh")
Part189 = Instance.new("Part")
SpecialMesh190 = Instance.new("SpecialMesh")
Part191 = Instance.new("Part")
SpecialMesh192 = Instance.new("SpecialMesh")
Part193 = Instance.new("Part")
SpecialMesh194 = Instance.new("SpecialMesh")
Part195 = Instance.new("Part")
SpecialMesh196 = Instance.new("SpecialMesh")
Part197 = Instance.new("Part")
SpecialMesh198 = Instance.new("SpecialMesh")
Part199 = Instance.new("Part")
SpecialMesh200 = Instance.new("SpecialMesh")
Part201 = Instance.new("Part")
SpecialMesh202 = Instance.new("SpecialMesh")
Part203 = Instance.new("Part")
SpecialMesh204 = Instance.new("SpecialMesh")
Part205 = Instance.new("Part")
SpecialMesh206 = Instance.new("SpecialMesh")
Part207 = Instance.new("Part")
SpecialMesh208 = Instance.new("SpecialMesh")
Part209 = Instance.new("Part")
SpecialMesh210 = Instance.new("SpecialMesh")
Part211 = Instance.new("Part")
SpecialMesh212 = Instance.new("SpecialMesh")
Part213 = Instance.new("Part")
SpecialMesh214 = Instance.new("SpecialMesh")
Part215 = Instance.new("Part")
SpecialMesh216 = Instance.new("SpecialMesh")
Part217 = Instance.new("Part")
SpecialMesh218 = Instance.new("SpecialMesh")
Part219 = Instance.new("Part")
SpecialMesh220 = Instance.new("SpecialMesh")
Part221 = Instance.new("Part")
SpecialMesh222 = Instance.new("SpecialMesh")
Part223 = Instance.new("Part")
SpecialMesh224 = Instance.new("SpecialMesh")
Part225 = Instance.new("Part")
SpecialMesh226 = Instance.new("SpecialMesh")
Part227 = Instance.new("Part")
SpecialMesh228 = Instance.new("SpecialMesh")
Part229 = Instance.new("Part")
SpecialMesh230 = Instance.new("SpecialMesh")
Part231 = Instance.new("Part")
SpecialMesh232 = Instance.new("SpecialMesh")
Part233 = Instance.new("Part")
SpecialMesh234 = Instance.new("SpecialMesh")
Part235 = Instance.new("Part")
SpecialMesh236 = Instance.new("SpecialMesh")
Part237 = Instance.new("Part")
SpecialMesh238 = Instance.new("SpecialMesh")
Part239 = Instance.new("Part")
SpecialMesh240 = Instance.new("SpecialMesh")
Part241 = Instance.new("Part")
SpecialMesh242 = Instance.new("SpecialMesh")
Part243 = Instance.new("Part")
SpecialMesh244 = Instance.new("SpecialMesh")
Part245 = Instance.new("Part")
SpecialMesh246 = Instance.new("SpecialMesh")
Part247 = Instance.new("Part")
SpecialMesh248 = Instance.new("SpecialMesh")
Part249 = Instance.new("Part")
SpecialMesh250 = Instance.new("SpecialMesh")
Part251 = Instance.new("Part")
SpecialMesh252 = Instance.new("SpecialMesh")
Part253 = Instance.new("Part")
SpecialMesh254 = Instance.new("SpecialMesh")
Part255 = Instance.new("Part")
SpecialMesh256 = Instance.new("SpecialMesh")
Part257 = Instance.new("Part")
SpecialMesh258 = Instance.new("SpecialMesh")
Part259 = Instance.new("Part")
SpecialMesh260 = Instance.new("SpecialMesh")
Part261 = Instance.new("Part")
SpecialMesh262 = Instance.new("SpecialMesh")
Part263 = Instance.new("Part")
SpecialMesh264 = Instance.new("SpecialMesh")
Part265 = Instance.new("Part")
SpecialMesh266 = Instance.new("SpecialMesh")
Part267 = Instance.new("Part")
SpecialMesh268 = Instance.new("SpecialMesh")
Part269 = Instance.new("Part")
SpecialMesh270 = Instance.new("SpecialMesh")
Part271 = Instance.new("Part")
SpecialMesh272 = Instance.new("SpecialMesh")
Part273 = Instance.new("Part")
SpecialMesh274 = Instance.new("SpecialMesh")
Part275 = Instance.new("Part")
SpecialMesh276 = Instance.new("SpecialMesh")
Part277 = Instance.new("Part")
SpecialMesh278 = Instance.new("SpecialMesh")
Part279 = Instance.new("Part")
SpecialMesh280 = Instance.new("SpecialMesh")
Part281 = Instance.new("Part")
SpecialMesh282 = Instance.new("SpecialMesh")
Part283 = Instance.new("Part")
SpecialMesh284 = Instance.new("SpecialMesh")
Part285 = Instance.new("Part")
SpecialMesh286 = Instance.new("SpecialMesh")
Part287 = Instance.new("Part")
SpecialMesh288 = Instance.new("SpecialMesh")
Part289 = Instance.new("Part")
SpecialMesh290 = Instance.new("SpecialMesh")
Part291 = Instance.new("Part")
SpecialMesh292 = Instance.new("SpecialMesh")
Part293 = Instance.new("Part")
SpecialMesh294 = Instance.new("SpecialMesh")
Part295 = Instance.new("Part")
SpecialMesh296 = Instance.new("SpecialMesh")
Part297 = Instance.new("Part")
SpecialMesh298 = Instance.new("SpecialMesh")
Part299 = Instance.new("Part")
SpecialMesh300 = Instance.new("SpecialMesh")
Part301 = Instance.new("Part")
SpecialMesh302 = Instance.new("SpecialMesh")
Part303 = Instance.new("Part")
SpecialMesh304 = Instance.new("SpecialMesh")
Part305 = Instance.new("Part")
SpecialMesh306 = Instance.new("SpecialMesh")
Part307 = Instance.new("Part")
SpecialMesh308 = Instance.new("SpecialMesh")
Part309 = Instance.new("Part")
SpecialMesh310 = Instance.new("SpecialMesh")
Part311 = Instance.new("Part")
SpecialMesh312 = Instance.new("SpecialMesh")
Part313 = Instance.new("Part")
SpecialMesh314 = Instance.new("SpecialMesh")
Part315 = Instance.new("Part")
SpecialMesh316 = Instance.new("SpecialMesh")
Part317 = Instance.new("Part")
SpecialMesh318 = Instance.new("SpecialMesh")
Part319 = Instance.new("Part")
SpecialMesh320 = Instance.new("SpecialMesh")
Part321 = Instance.new("Part")
SpecialMesh322 = Instance.new("SpecialMesh")
Part323 = Instance.new("Part")
SpecialMesh324 = Instance.new("SpecialMesh")
Part325 = Instance.new("Part")
SpecialMesh326 = Instance.new("SpecialMesh")
Part327 = Instance.new("Part")
SpecialMesh328 = Instance.new("SpecialMesh")
Part329 = Instance.new("Part")
SpecialMesh330 = Instance.new("SpecialMesh")
Part331 = Instance.new("Part")
SpecialMesh332 = Instance.new("SpecialMesh")
Part333 = Instance.new("Part")
SpecialMesh334 = Instance.new("SpecialMesh")
Part335 = Instance.new("Part")
SpecialMesh336 = Instance.new("SpecialMesh")
Part337 = Instance.new("Part")
SpecialMesh338 = Instance.new("SpecialMesh")
Part339 = Instance.new("Part")
SpecialMesh340 = Instance.new("SpecialMesh")
Part341 = Instance.new("Part")
SpecialMesh342 = Instance.new("SpecialMesh")
Part343 = Instance.new("Part")
SpecialMesh344 = Instance.new("SpecialMesh")
Part345 = Instance.new("Part")
SpecialMesh346 = Instance.new("SpecialMesh")
Part347 = Instance.new("Part")
SpecialMesh348 = Instance.new("SpecialMesh")
Part349 = Instance.new("Part")
SpecialMesh350 = Instance.new("SpecialMesh")
Part351 = Instance.new("Part")
SpecialMesh352 = Instance.new("SpecialMesh")
Part353 = Instance.new("Part")
SpecialMesh354 = Instance.new("SpecialMesh")
Part355 = Instance.new("Part")
SpecialMesh356 = Instance.new("SpecialMesh")
Part357 = Instance.new("Part")
SpecialMesh358 = Instance.new("SpecialMesh")
Part359 = Instance.new("Part")
SpecialMesh360 = Instance.new("SpecialMesh")
Part361 = Instance.new("Part")
SpecialMesh362 = Instance.new("SpecialMesh")
Part363 = Instance.new("Part")
SpecialMesh364 = Instance.new("SpecialMesh")
Part365 = Instance.new("Part")
SpecialMesh366 = Instance.new("SpecialMesh")
Part367 = Instance.new("Part")
SpecialMesh368 = Instance.new("SpecialMesh")
Part369 = Instance.new("Part")
SpecialMesh370 = Instance.new("SpecialMesh")
Part371 = Instance.new("Part")
SpecialMesh372 = Instance.new("SpecialMesh")
Part373 = Instance.new("Part")
SpecialMesh374 = Instance.new("SpecialMesh")
Part375 = Instance.new("Part")
SpecialMesh376 = Instance.new("SpecialMesh")
Part377 = Instance.new("Part")
SpecialMesh378 = Instance.new("SpecialMesh")
Part379 = Instance.new("Part")
SpecialMesh380 = Instance.new("SpecialMesh")
Part381 = Instance.new("Part")
SpecialMesh382 = Instance.new("SpecialMesh")
Part383 = Instance.new("Part")
SpecialMesh384 = Instance.new("SpecialMesh")
Part385 = Instance.new("Part")
SpecialMesh386 = Instance.new("SpecialMesh")
Part387 = Instance.new("Part")
SpecialMesh388 = Instance.new("SpecialMesh")
Part389 = Instance.new("Part")
SpecialMesh390 = Instance.new("SpecialMesh")
Part391 = Instance.new("Part")
SpecialMesh392 = Instance.new("SpecialMesh")
Part393 = Instance.new("Part")
SpecialMesh394 = Instance.new("SpecialMesh")
Part395 = Instance.new("Part")
SpecialMesh396 = Instance.new("SpecialMesh")
Part397 = Instance.new("Part")
SpecialMesh398 = Instance.new("SpecialMesh")
Part399 = Instance.new("Part")
SpecialMesh400 = Instance.new("SpecialMesh")
Part401 = Instance.new("Part")
SpecialMesh402 = Instance.new("SpecialMesh")
Part403 = Instance.new("Part")
SpecialMesh404 = Instance.new("SpecialMesh")
Part405 = Instance.new("Part")
SpecialMesh406 = Instance.new("SpecialMesh")
Part407 = Instance.new("Part")
SpecialMesh408 = Instance.new("SpecialMesh")
Part409 = Instance.new("Part")
SpecialMesh410 = Instance.new("SpecialMesh")
Part411 = Instance.new("Part")
SpecialMesh412 = Instance.new("SpecialMesh")
Part413 = Instance.new("Part")
SpecialMesh414 = Instance.new("SpecialMesh")
Part415 = Instance.new("Part")
SpecialMesh416 = Instance.new("SpecialMesh")
Part417 = Instance.new("Part")
SpecialMesh418 = Instance.new("SpecialMesh")
Part419 = Instance.new("Part")
SpecialMesh420 = Instance.new("SpecialMesh")
Part421 = Instance.new("Part")
SpecialMesh422 = Instance.new("SpecialMesh")
Part423 = Instance.new("Part")
SpecialMesh424 = Instance.new("SpecialMesh")
Part425 = Instance.new("Part")
SpecialMesh426 = Instance.new("SpecialMesh")
Part427 = Instance.new("Part")
SpecialMesh428 = Instance.new("SpecialMesh")
Part429 = Instance.new("Part")
SpecialMesh430 = Instance.new("SpecialMesh")
Part431 = Instance.new("Part")
SpecialMesh432 = Instance.new("SpecialMesh")
Part433 = Instance.new("Part")
SpecialMesh434 = Instance.new("SpecialMesh")
Part435 = Instance.new("Part")
SpecialMesh436 = Instance.new("SpecialMesh")
Part437 = Instance.new("Part")
SpecialMesh438 = Instance.new("SpecialMesh")
Part439 = Instance.new("Part")
SpecialMesh440 = Instance.new("SpecialMesh")
Part441 = Instance.new("Part")
SpecialMesh442 = Instance.new("SpecialMesh")
Part443 = Instance.new("Part")
SpecialMesh444 = Instance.new("SpecialMesh")
Part445 = Instance.new("Part")
SpecialMesh446 = Instance.new("SpecialMesh")
Part447 = Instance.new("Part")
SpecialMesh448 = Instance.new("SpecialMesh")
Part449 = Instance.new("Part")
SpecialMesh450 = Instance.new("SpecialMesh")
Part451 = Instance.new("Part")
SpecialMesh452 = Instance.new("SpecialMesh")
Part453 = Instance.new("Part")
SpecialMesh454 = Instance.new("SpecialMesh")
Part455 = Instance.new("Part")
SpecialMesh456 = Instance.new("SpecialMesh")
Part457 = Instance.new("Part")
SpecialMesh458 = Instance.new("SpecialMesh")
Part459 = Instance.new("Part")
SpecialMesh460 = Instance.new("SpecialMesh")
Part461 = Instance.new("Part")
SpecialMesh462 = Instance.new("SpecialMesh")
Part463 = Instance.new("Part")
SpecialMesh464 = Instance.new("SpecialMesh")
Part465 = Instance.new("Part")
SpecialMesh466 = Instance.new("SpecialMesh")
Part467 = Instance.new("Part")
SpecialMesh468 = Instance.new("SpecialMesh")
Part469 = Instance.new("Part")
SpecialMesh470 = Instance.new("SpecialMesh")
Part471 = Instance.new("Part")
SpecialMesh472 = Instance.new("SpecialMesh")
Part473 = Instance.new("Part")
SpecialMesh474 = Instance.new("SpecialMesh")
Part475 = Instance.new("Part")
SpecialMesh476 = Instance.new("SpecialMesh")
Model0.Parent = mas
Part1.Parent = Model0
Part1.CFrame = CFrame.new(-0.612978518, 3.52787709, -14.4877329, 0.999985635, -0.00299202278, 0.00444748998, 0.00513700023, 0.297964603, -0.95456326, 0.00153088011, 0.95457232, 0.297975689)
Part1.Orientation = Vector3.new(72.659996, 0.859999955, 0.98999995)
Part1.Position = Vector3.new(-0.612978518, 3.52787709, -14.4877329)
Part1.Rotation = Vector3.new(72.659996, 0.25, 0.170000002)
Part1.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part1.Velocity = Vector3.new(1.29135582e-08, 0.00246586069, 1.6969787e-07)
Part1.Size = Vector3.new(0.275000006, 0.22512494, 0.42337501)
Part1.Anchored = true
Part1.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.BrickColor = BrickColor.new("Really black")
Part1.CanCollide = false
Part1.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.Material = Enum.Material.Metal
Part1.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part1.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part1.brickColor = BrickColor.new("Really black")
SpecialMesh2.Parent = Part1
SpecialMesh2.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh2.MeshType = Enum.MeshType.Brick
Part3.Parent = Model0
Part3.CFrame = CFrame.new(-0.608517408, 2.57421446, -14.2038746, 0.999985635, 0.00162795268, -0.00510686403, 0.0051367972, -0.0189460143, 0.999807417, 0.00153088395, -0.999819279, -0.0189541057)
Part3.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part3.Position = Vector3.new(-0.608517408, 2.57421446, -14.2038746)
Part3.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part3.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part3.Velocity = Vector3.new(1.6413172e-07, 0.00246645301, 2.15686623e-06)
Part3.Size = Vector3.new(0.275000006, 0.315999985, 0.303375006)
Part3.Anchored = true
Part3.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.BrickColor = BrickColor.new("Really black")
Part3.CanCollide = false
Part3.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.Material = Enum.Material.Glass
Part3.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part3.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part3.brickColor = BrickColor.new("Really black")
SpecialMesh4.Parent = Part3
SpecialMesh4.Scale = Vector3.new(0.5, 1, 0.5)
SpecialMesh4.MeshType = Enum.MeshType.Wedge
Weld5.Name = "BTWeld"
Weld5.Parent = Part3
Weld5.C1 = CFrame.new(1.78813934e-06, -0.442868233, -0.256871939, -1, 2.08499841e-07, 2.3712164e-07, -2.08849087e-07, -1.00000024, 0, 2.39566361e-07, 1.86264515e-09, 1.00000024)
Weld5.Part0 = Part3
Weld5.Part1 = Part441
Weld5.part1 = Part441
Weld6.Name = "BTWeld"
Weld6.Parent = Part3
Weld6.C1 = CFrame.new(2.8014183e-06, 0.12912178, 0.434119463, -1, -2.32830644e-10, 3.05299181e-08, 2.32830644e-10, 1.00000024, 1.80676579e-07, -3.2619937e-08, 1.76951289e-07, -1.00000024)
Weld6.Part0 = Part3
Weld6.Part1 = Part323
Weld6.part1 = Part323
Weld7.Name = "BTWeld"
Weld7.Parent = Part3
Weld7.C1 = CFrame.new(-3.09944153e-06, -0.192704201, -0.62885952, 1, 8.96397978e-08, 1.20697223e-07, -8.91741365e-08, 1.00000024, 1.78813934e-07, -1.1825432e-07, -1.78813934e-07, 1.00000024)
Weld7.Part0 = Part3
Weld7.Part1 = Part371
Weld7.part1 = Part371
Weld8.Name = "BTWeld"
Weld8.Parent = Part3
Weld8.C1 = CFrame.new(-2.86102295e-06, 0.0544996262, -0.312496185, 1, 2.32830644e-10, 1.14778231e-09, 2.32830644e-10, 1.00000024, 1.86264515e-09, 1.14778231e-09, 1.86264515e-09, 1.00000024)
Weld8.Part0 = Part3
Weld8.Part1 = Part167
Weld8.part1 = Part167
Weld9.Name = "BTWeld"
Weld9.Parent = Part3
Weld9.C1 = CFrame.new(3.63588333e-06, -2.63571262, -0.638117313, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld9.Part0 = Part3
Weld9.Part1 = Part177
Weld9.part1 = Part177
Weld10.Name = "BTWeld"
Weld10.Parent = Part3
Weld10.C1 = CFrame.new(-2.98023224e-06, -0.077252388, -0.223499537, 1, 2.32830644e-10, 1.14778231e-09, 2.32830644e-10, 1.00000024, 1.86264515e-09, 1.14778231e-09, 1.86264515e-09, 1.00000024)
Weld10.Part0 = Part3
Weld10.Part1 = Part277
Weld10.part1 = Part277
Weld11.Name = "BTWeld"
Weld11.Parent = Part3
Weld11.C1 = CFrame.new(1.90734863e-06, -0.629117966, -0.531242609, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld11.Part0 = Part3
Weld11.Part1 = Part427
Weld11.part1 = Part427
Weld12.Name = "BTWeld"
Weld12.Parent = Part3
Weld12.C1 = CFrame.new(3.87430191e-06, -1.56084347, -0.606865883, -1, 2.08499841e-07, 1.81222276e-07, -2.08849087e-07, -1.00000024, 0, 1.83687007e-07, 1.86264515e-09, 1.00000024)
Weld12.Part0 = Part3
Weld12.Part1 = Part209
Weld12.part1 = Part209
Weld13.Name = "BTWeld"
Weld13.Parent = Part3
Weld13.C1 = CFrame.new(-1.66893005e-06, -0.394741058, 0.453120232, 1, -1.19092874e-07, -2.68964868e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, -2.71322278e-07, 5.77419996e-08, -1.00000024)
Weld13.Part0 = Part3
Weld13.Part1 = Part265
Weld13.part1 = Part265
Weld14.Name = "BTWeld"
Weld14.Parent = Part3
Weld14.C1 = CFrame.new(-3.51667404e-06, -3.62178516, 0.128079414, 1, 2.32830644e-10, -2.82076144e-07, 4.92436811e-08, -0.984807968, 0.173648342, -2.7945498e-07, -0.173648342, -0.984807968)
Weld14.Part0 = Part3
Weld14.Part1 = Part445
Weld14.part1 = Part445
Weld15.Name = "BTWeld"
Weld15.Parent = Part3
Weld15.C1 = CFrame.new(1.7285347e-06, -0.568753242, -0.743589878, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld15.Part0 = Part3
Weld15.Part1 = Part175
Weld15.part1 = Part175
Weld16.Name = "BTWeld"
Weld16.Parent = Part3
Weld16.C1 = CFrame.new(-0.568752289, -0.0312482715, 1.24358273, -5.98374754e-08, -1.00000024, 0, -1, 5.93718141e-08, 3.27925591e-07, -3.30370312e-07, -1.86264515e-09, -1.00000024)
Weld16.Part0 = Part3
Weld16.Part1 = Part433
Weld16.part1 = Part433
Weld17.Name = "BTWeld"
Weld17.Parent = Part3
Weld17.C1 = CFrame.new(1.7285347e-06, -0.568753242, -0.743589878, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld17.Part0 = Part3
Weld17.Part1 = Part417
Weld17.part1 = Part417
Weld18.Name = "BTWeld"
Weld18.Parent = Part3
Weld18.C1 = CFrame.new(-3.09944153e-06, -0.364574432, -0.628859282, 1, 8.96397978e-08, 1.20697223e-07, -8.91741365e-08, 1.00000024, 1.78813934e-07, -1.1825432e-07, -1.78813934e-07, 1.00000024)
Weld18.Part0 = Part3
Weld18.Part1 = Part295
Weld18.part1 = Part295
Weld19.Name = "BTWeld"
Weld19.Parent = Part3
Weld19.C1 = CFrame.new(3.93390656e-06, -3.33387375, 1.42912102, -1, 2.08499841e-07, 7.08205334e-08, -1.35507435e-07, -0.838670611, 0.544639409, 1.75263267e-07, 0.544639468, 0.838670611)
Weld19.Part0 = Part3
Weld19.Part1 = Part165
Weld19.part1 = Part165
Weld20.Name = "BTWeld"
Weld20.Parent = Part3
Weld20.C1 = CFrame.new(1.78813934e-07, -3.38045502, 0.755048752, 1, 2.32830644e-10, -2.6903399e-07, -2.32830644e-10, -1.00000024, 8.7544322e-08, -2.71093086e-07, -9.12696123e-08, -1.00000024)
Weld20.Part0 = Part3
Weld20.Part1 = Part315
Weld20.part1 = Part315
Weld21.Name = "BTWeld"
Weld21.Parent = Part3
Weld21.C1 = CFrame.new(0.522247314, -0.031253159, 0.449784279, 2.578774e-06, -0.500000775, -0.866025329, 1, 2.96742655e-06, 1.26622399e-06, 1.93726737e-06, -0.866025329, 0.500000715)
Weld21.Part0 = Part3
Weld21.Part1 = Part457
Weld21.part1 = Part457
Weld22.Name = "BTWeld"
Weld22.Parent = Part3
Weld22.C1 = CFrame.new(-3.03983688e-06, -0.26757431, -0.628857851, 1, 8.96397978e-08, 1.20697223e-07, -8.91741365e-08, 1.00000024, 1.78813934e-07, -1.1825432e-07, -1.78813934e-07, 1.00000024)
Weld22.Part0 = Part3
Weld22.Part1 = Part363
Weld22.part1 = Part363
Weld23.Name = "BTWeld"
Weld23.Parent = Part3
Weld23.C1 = CFrame.new(-3.03983688e-06, 0.579193592, -0.519788742, 1, 2.08732672e-07, 7.35781214e-08, -9.66247171e-08, 0.707106471, -0.707107365, -1.97673216e-07, 0.707107365, 0.707106471)
Weld23.Part0 = Part3
Weld23.Part1 = Part429
Weld23.part1 = Part429
Weld24.Name = "BTWeld"
Weld24.Parent = Part3
Weld24.C1 = CFrame.new(3.57627869e-06, -2.7432127, -0.596743584, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld24.Part0 = Part3
Weld24.Part1 = Part253
Weld24.part1 = Part253
Weld25.Name = "BTWeld"
Weld25.Parent = Part3
Weld25.C1 = CFrame.new(-5.96046448e-08, -0.0365514755, -0.0244483948, -1, 2.08383426e-07, 3.34477591e-07, -3.4889672e-07, -0.866025686, -0.49999994, 1.87254045e-07, -0.499999881, 0.866025686)
Weld25.Part0 = Part3
Weld25.Part1 = Part383
Weld25.part1 = Part383
Weld26.Name = "BTWeld"
Weld26.Parent = Part3
Weld26.C1 = CFrame.new(0.0437097549, -0.0312481523, 1.49426508, -1.02329068e-07, -0.707107306, -0.707106531, -1, -1.1047814e-07, 2.52499376e-07, -2.57976353e-07, 0.70710659, -0.707107306)
Weld26.Part0 = Part3
Weld26.Part1 = Part289
Weld26.part1 = Part289
Weld27.Name = "BTWeld"
Weld27.Parent = Part3
Weld27.C1 = CFrame.new(-0.390325546, -0.0312492251, 0.188101292, 1.53668225e-07, 0.866025686, 0.5, -1, 1.49011612e-07, 4.73319233e-08, -3.19560058e-08, -0.49999994, 0.866025686)
Weld27.Part0 = Part3
Weld27.Part1 = Part465
Weld27.part1 = Part465
Weld28.Name = "BTWeld"
Weld28.Parent = Part3
Weld28.C1 = CFrame.new(3.69548798e-06, 1.39622211, 0.606865406, -1, -8.95233825e-08, 3.02316039e-08, -8.91741365e-08, 1.00000024, -8.94069672e-08, -3.26745067e-08, -9.12696123e-08, -1.00000024)
Weld28.Part0 = Part3
Weld28.Part1 = Part325
Weld28.part1 = Part325
Weld29.Name = "BTWeld"
Weld29.Parent = Part3
Weld29.C1 = CFrame.new(-3.03983688e-06, -0.0283536911, -0.593729019, 1, 8.95233825e-08, 4.61641321e-08, -6.54254109e-08, 0.923879802, -0.382683307, -7.52625056e-08, 0.382683337, 0.923879921)
Weld29.Part0 = Part3
Weld29.Part1 = Part435
Weld29.part1 = Part435
Weld30.Name = "BTWeld"
Weld30.Parent = Part3
Weld30.C1 = CFrame.new(-2.98023224e-06, 0.0857448578, -0.331493855, 1, 2.32830644e-10, 1.14778231e-09, 2.32830644e-10, 1.00000024, 1.86264515e-09, 1.14778231e-09, 1.86264515e-09, 1.00000024)
Weld30.Part0 = Part3
Weld30.Part1 = Part297
Weld30.part1 = Part297
Weld31.Name = "BTWeld"
Weld31.Parent = Part3
Weld31.C1 = CFrame.new(2.98023224e-06, 0.0857439041, 0.434119463, -1, -2.32830644e-10, -8.87230271e-08, 2.32830644e-10, 1.00000024, 1.86264515e-09, 8.63965397e-08, -1.86264515e-09, -1.00000024)
Weld31.Part0 = Part3
Weld31.Part1 = Part403
Weld31.part1 = Part403
Weld32.Name = "BTWeld"
Weld32.Parent = Part3
Weld32.C1 = CFrame.new(3.69548798e-06, -1.12822342, -0.591116667, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld32.Part0 = Part3
Weld32.Part1 = Part317
Weld32.part1 = Part317
Weld33.Name = "BTWeld"
Weld33.Parent = Part3
Weld33.C1 = CFrame.new(-3.57627869e-06, 1.17320824, 0.736830235, 1, -1.19092874e-07, 2.04781827e-07, -1.19325705e-07, -1.00000024, 2.68220901e-07, 2.03222953e-07, -2.68220901e-07, -1.00000024)
Weld33.Part0 = Part3
Weld33.Part1 = Part171
Weld33.part1 = Part171
Weld34.Name = "BTWeld"
Weld34.Parent = Part3
Weld34.C1 = CFrame.new(3.51667404e-06, -2.70561504, -1.06026649, -1, 1.18976459e-07, 3.69582267e-07, -1.82189979e-07, -0.984807968, -0.173648283, 3.45506123e-07, -0.173648298, 0.984807968)
Weld34.Part0 = Part3
Weld34.Part1 = Part251
Weld34.part1 = Part251
Weld35.Name = "BTWeld"
Weld35.Parent = Part3
Weld35.C1 = CFrame.new(0.568753242, -0.0312516689, 1.24358273, 1.1944212e-07, 1.00000024, 0, 1, -1.18976459e-07, -3.28123861e-07, -3.30370312e-07, -1.86264515e-09, -1.00000024)
Weld35.Part0 = Part3
Weld35.Part1 = Part443
Weld35.part1 = Part443
Weld36.Name = "BTWeld"
Weld36.Parent = Part3
Weld36.C1 = CFrame.new(-0.00166904926, -3.09995842, -0.665301085, -1, -2.32830644e-10, 6.22057996e-08, -1.16415322e-10, -1.00000024, -6.14672899e-08, 6.45686669e-08, -5.77419996e-08, 1.00000024)
Weld36.Part0 = Part3
Weld36.Part1 = Part243
Weld36.part1 = Part243
Weld37.Name = "BTWeld"
Weld37.Parent = Part3
Weld37.C1 = CFrame.new(-1.3257277, -0.0312492847, 5.10531425, 9.66574589e-08, 0.0174533594, 0.999847949, -1, 2.08499841e-07, 9.1315087e-08, -2.07335688e-07, -0.999847949, 0.0174533576)
Weld37.Part0 = Part3
Weld37.Part1 = Part191
Weld37.part1 = Part191
Weld38.Name = "BTWeld"
Weld38.Parent = Part3
Weld38.C1 = CFrame.new(2.98023224e-06, -0.520121574, 0.565322638, -1, 2.08499841e-07, -1.4426405e-08, 1.87777914e-07, 0.923879921, 0.382683069, 9.12114047e-08, 0.382683039, -0.923879921)
Weld38.Part0 = Part3
Weld38.Part1 = Part459
Weld38.part1 = Part459
Weld39.Name = "BTWeld"
Weld39.Parent = Part3
Weld39.C1 = CFrame.new(-2.44379044e-06, 1.62276363, -0.980819702, 1, -3.87430191e-07, 3.99177225e-08, -1.89582352e-07, -0.569997728, -0.821646571, 3.3993274e-07, 0.821646512, -0.569997668)
Weld39.Part0 = Part3
Weld39.Part1 = Part327
Weld39.part1 = Part327
Weld40.Name = "BTWeld"
Weld40.Parent = Part3
Weld40.C1 = CFrame.new(3.69548798e-06, -1.7807188, -0.638116598, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld40.Part0 = Part3
Weld40.Part1 = Part229
Weld40.part1 = Part229
Weld41.Name = "BTWeld"
Weld41.Parent = Part3
Weld41.C1 = CFrame.new(-2.98023224e-06, -0.170754433, -0.381493092, 1, 2.32830644e-10, 1.14778231e-09, 2.32830644e-10, 1.00000024, 1.86264515e-09, 1.14778231e-09, 1.86264515e-09, 1.00000024)
Weld41.Part0 = Part3
Weld41.Part1 = Part469
Weld41.part1 = Part469
Weld42.Name = "BTWeld"
Weld42.Parent = Part3
Weld42.C1 = CFrame.new(1.7285347e-06, -0.568753242, -0.743589878, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld42.Part0 = Part3
Weld42.Part1 = Part169
Weld42.part1 = Part169
Weld43.Name = "BTWeld"
Weld43.Parent = Part3
Weld43.C1 = CFrame.new(1.84774399e-06, -0.227245331, -0.390619993, -1, 1.18976459e-07, 3.56074452e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.58400939e-07, -5.77419996e-08, 1.00000024)
Weld43.Part0 = Part3
Weld43.Part1 = Part463
Weld43.part1 = Part463
Weld44.Name = "BTWeld"
Weld44.Parent = Part3
Weld44.C1 = CFrame.new(-1.84774399e-06, 0.916108131, -0.790865183, 1, -5.93718141e-08, 2.56368367e-08, 5.97210601e-08, 1.00000024, 5.96046448e-08, -2.29756552e-08, -5.77419996e-08, 1.00000024)
Weld44.Part0 = Part3
Weld44.Part1 = Part411
Weld44.part1 = Part411
Weld45.Name = "BTWeld"
Weld45.Parent = Part3
Weld45.C1 = CFrame.new(3.75509262e-06, -2.08321857, -0.731868029, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld45.Part0 = Part3
Weld45.Part1 = Part475
Weld45.part1 = Part475
Weld46.Name = "BTWeld"
Weld46.Parent = Part3
Weld46.C1 = CFrame.new(0.00166875124, 3.12339592, -0.606613398, 1, -1.18976459e-07, -6.2136678e-08, 1.1944212e-07, 1.00000024, -8.94069672e-08, 6.48051355e-08, 9.12696123e-08, 1.00000024)
Weld46.Part0 = Part3
Weld46.Part1 = Part473
Weld46.part1 = Part473
Weld47.Name = "BTWeld"
Weld47.Parent = Part3
Weld47.C1 = CFrame.new(-0.246384621, -0.03125, 0.315700531, 8.35862011e-08, -0.965926051, 0.258819014, 1, 6.17001206e-08, -9.08512447e-08, 7.39237294e-08, 0.258818984, 0.965926111)
Weld47.Part0 = Part3
Weld47.Part1 = Part355
Weld47.part1 = Part355
Weld48.Name = "BTWeld"
Weld48.Parent = Part3
Weld48.C1 = CFrame.new(2.74181366e-06, 0.908480644, 0.621105194, -1, 3.87430191e-07, -2.68737494e-08, -1.25437509e-07, -0.382683992, -0.923879504, -3.67756002e-07, -0.923879564, 0.382684022)
Weld48.Part0 = Part3
Weld48.Part1 = Part341
Weld48.part1 = Part341
Weld49.Name = "BTWeld"
Weld49.Parent = Part3
Weld49.C1 = CFrame.new(1.96695328e-06, -0.43809557, 0.254676819, -1, 2.08499841e-07, 8.61909939e-08, -8.48667696e-08, -0.707106531, 0.707107365, 2.10478902e-07, 0.707107365, 0.707106471)
Weld49.Part0 = Part3
Weld49.Part1 = Part269
Weld49.part1 = Part269
Weld50.Name = "BTWeld"
Weld50.Parent = Part3
Weld50.C1 = CFrame.new(1.32572746, -0.0312505364, 5.10531616, -1.84201781e-07, -0.0174533594, -0.999847949, 1, -2.08499841e-07, -1.78890332e-07, -2.05705874e-07, -0.999847949, 0.0174533576)
Weld50.Part0 = Part3
Weld50.Part1 = Part379
Weld50.part1 = Part379
Weld51.Name = "BTWeld"
Weld51.Parent = Part3
Weld51.C1 = CFrame.new(1.7285347e-06, -0.242359161, -0.146375895, -1, 2.08499841e-07, 2.3712164e-07, -2.08849087e-07, -1.00000024, 0, 2.39566361e-07, 1.86264515e-09, 1.00000024)
Weld51.Part0 = Part3
Weld51.Part1 = Part455
Weld51.part1 = Part455
Weld52.Name = "BTWeld"
Weld52.Parent = Part3
Weld52.C1 = CFrame.new(-3.03983688e-06, -0.143110275, -0.641388893, 1, 8.95233825e-08, 7.0387614e-08, -6.88014552e-08, 0.96592617, -0.258818775, -8.91450327e-08, 0.258818746, 0.96592623)
Weld52.Part0 = Part3
Weld52.Part1 = Part453
Weld52.part1 = Part453
Weld53.Name = "BTWeld"
Weld53.Parent = Part3
Weld53.C1 = CFrame.new(1.84774399e-06, -0.316618919, -0.362743855, -1, 1.18976459e-07, 3.56074452e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.58400939e-07, -5.77419996e-08, 1.00000024)
Weld53.Part0 = Part3
Weld53.Part1 = Part425
Weld53.part1 = Part425
Weld54.Name = "BTWeld"
Weld54.Parent = Part3
Weld54.C1 = CFrame.new(-2.44379044e-06, 3.96811485, 0.642149091, 1, -2.08499841e-07, 1.92838343e-07, -1.85798854e-07, -0.993572116, -0.113202929, 2.13360181e-07, 0.113202937, -0.993572235)
Weld54.Part0 = Part3
Weld54.Part1 = Part241
Weld54.part1 = Part241
Weld55.Name = "BTWeld"
Weld55.Parent = Part3
Weld55.C1 = CFrame.new(-2.08616257e-06, 0.207164764, -0.535107613, 1, 2.08732672e-07, 7.35781214e-08, -2.08383426e-07, 1.00000024, 1.78813934e-07, -7.12225301e-08, -1.76951289e-07, 1.00000024)
Weld55.Part0 = Part3
Weld55.Part1 = Part321
Weld55.part1 = Part321
Weld56.Name = "BTWeld"
Weld56.Parent = Part3
Weld56.C1 = CFrame.new(0.3903265, -0.0312507153, 0.188101292, -2.43075192e-07, -0.866025627, -0.5, 1, -2.29571015e-07, -8.65911716e-08, -3.80096026e-08, -0.49999994, 0.866025686)
Weld56.Part0 = Part3
Weld56.Part1 = Part449
Weld56.part1 = Part449
Weld57.Name = "BTWeld"
Weld57.Parent = Part3
Weld57.C1 = CFrame.new(4.0832634, -0.0312500596, 2.68361759, -3.40398401e-07, -0.719340265, -0.694658279, 1, -3.15834768e-07, -1.60429408e-07, -1.03143975e-07, -0.694658279, 0.719340265)
Weld57.Part0 = Part3
Weld57.Part1 = Part261
Weld57.part1 = Part261
Weld58.Name = "BTWeld"
Weld58.Parent = Part3
Weld58.C1 = CFrame.new(3.87430191e-06, -2.97136497, -1.32431102, -1, 1.19092874e-07, 2.00954673e-07, -1.67870894e-07, -0.965925992, -0.258819073, 1.64814992e-07, -0.258819073, 0.965926111)
Weld58.Part0 = Part3
Weld58.Part1 = Part367
Weld58.part1 = Part367
Weld59.Name = "BTWeld"
Weld59.Parent = Part3
Weld59.C1 = CFrame.new(-3.21865082e-06, -0.0555143356, 0.74919796, 1, 2.08732672e-07, 1.05254003e-07, 7.4505806e-08, -0.707106292, 0.707107484, 2.20257789e-07, -0.707107544, -0.707106352)
Weld59.Part0 = Part3
Weld59.Part1 = Part179
Weld59.part1 = Part179
Weld60.Name = "BTWeld"
Weld60.Parent = Part3
Weld60.C1 = CFrame.new(0.854812145, -0.0312569141, 0.683163643, -7.71833584e-08, 0.707106531, -0.707107306, 1, 1.8987339e-07, 8.20728019e-08, 1.90921128e-07, -0.707107365, -0.707106531)
Weld60.Part0 = Part3
Weld60.Part1 = Part437
Weld60.part1 = Part437
Weld61.Name = "BTWeld"
Weld61.Parent = Part3
Weld61.C1 = CFrame.new(1.84774399e-06, -0.363491058, -0.331495762, -1, 1.18976459e-07, 3.56074452e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.58400939e-07, -5.77419996e-08, 1.00000024)
Weld61.Part0 = Part3
Weld61.Part1 = Part365
Weld61.part1 = Part365
Weld62.Name = "BTWeld"
Weld62.Parent = Part3
Weld62.C1 = CFrame.new(-5.96046448e-08, -0.251069069, 0.0857863426, -1, 2.08499841e-07, 1.84947567e-07, -1.53202564e-07, -0.965926051, 0.258819163, 2.35246262e-07, 0.258819163, 0.96592617)
Weld62.Part0 = Part3
Weld62.Part1 = Part423
Weld62.part1 = Part423
Weld63.Name = "BTWeld"
Weld63.Parent = Part3
Weld63.C1 = CFrame.new(2.92062759e-06, 0.530877113, 0.384551048, -1, -2.32830644e-10, 1.16708179e-07, -1.19271135e-07, -1.01514161e-06, -1.00000024, -1.16415322e-10, -1.00000024, 1.01141632e-06)
Weld63.Part0 = Part3
Weld63.Part1 = Part421
Weld63.part1 = Part421
Weld64.Name = "BTWeld"
Weld64.Parent = Part3
Weld64.C1 = CFrame.new(3.81469727e-06, -1.63659573, -0.658368826, -1, 2.08499841e-07, 1.81222276e-07, -2.08849087e-07, -1.00000024, 0, 1.83687007e-07, 1.86264515e-09, 1.00000024)
Weld64.Part0 = Part3
Weld64.Part1 = Part391
Weld64.part1 = Part391
Weld65.Name = "BTWeld"
Weld65.Parent = Part3
Weld65.C1 = CFrame.new(3.93390656e-06, -2.9557457, -1.37312269, -1, 1.19092874e-07, 2.00954673e-07, -1.67870894e-07, -0.965925992, -0.258819073, 1.64814992e-07, -0.258819073, 0.965926111)
Weld65.Part0 = Part3
Weld65.Part1 = Part419
Weld65.part1 = Part419
Weld66.Name = "BTWeld"
Weld66.Parent = Part3
Weld66.C1 = CFrame.new(-2.98023224e-07, 3.86712265, 0.467648745, 1, -2.08499841e-07, 1.92838343e-07, -1.85798854e-07, -0.993572116, -0.113202929, 2.13360181e-07, 0.113202937, -0.993572235)
Weld66.Part0 = Part3
Weld66.Part1 = Part415
Weld66.part1 = Part415
Weld67.Name = "BTWeld"
Weld67.Parent = Part3
Weld67.C1 = CFrame.new(-2.02655792e-06, 0.114692688, -0.875624657, 1, 2.08732672e-07, 7.35781214e-08, -2.19908543e-07, 0.965926111, 0.258818954, -1.55705493e-08, -0.258818954, 0.96592617)
Weld67.Part0 = Part3
Weld67.Part1 = Part193
Weld67.part1 = Part193
Weld68.Name = "BTWeld"
Weld68.Parent = Part3
Weld68.C1 = CFrame.new(1.84774399e-06, -0.820864677, -0.453119278, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld68.Part0 = Part3
Weld68.Part1 = Part447
Weld68.part1 = Part447
Weld69.Name = "BTWeld"
Weld69.Parent = Part3
Weld69.C1 = CFrame.new(1.84774399e-06, -0.879114151, -0.453119278, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld69.Part0 = Part3
Weld69.Part1 = Part329
Weld69.part1 = Part329
Weld70.Name = "BTWeld"
Weld70.Parent = Part3
Weld70.C1 = CFrame.new(-3.09944153e-06, 2.06479263, 0.744927168, 1, -1.19092874e-07, 2.05247488e-07, -1.07684173e-07, -0.998391926, -0.0566923842, 2.10064172e-07, 0.0566923767, -0.998391867)
Weld70.Part0 = Part3
Weld70.Part1 = Part213
Weld70.part1 = Part213
Weld71.Name = "BTWeld"
Weld71.Parent = Part3
Weld71.C1 = CFrame.new(-4.0832634, -0.0312493443, 2.68361759, 2.50991434e-07, 0.719340265, 0.694658279, -1, 2.34693289e-07, 1.15569492e-07, -7.84639269e-08, -0.694658279, 0.719340265)
Weld71.Part0 = Part3
Weld71.Part1 = Part257
Weld71.part1 = Part257
Weld72.Name = "BTWeld"
Weld72.Parent = Part3
Weld72.C1 = CFrame.new(1.84774399e-06, -0.227245331, -0.390619993, -1, 1.18976459e-07, 3.56074452e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.58400939e-07, -5.77419996e-08, 1.00000024)
Weld72.Part0 = Part3
Weld72.Part1 = Part173
Weld72.part1 = Part173
Weld73.Name = "BTWeld"
Weld73.Parent = Part3
Weld73.C1 = CFrame.new(2.86102295e-06, 0.835924149, -0.142241955, -1, 3.27709131e-07, -1.37008101e-07, -1.36438757e-07, -0.707107067, -0.707106829, -3.27592716e-07, -0.707106769, 0.707107008)
Weld73.Part0 = Part3
Weld73.Part1 = Part361
Weld73.part1 = Part361
Weld74.Name = "BTWeld"
Weld74.Parent = Part3
Weld74.C1 = CFrame.new(-0.00166893005, 2.82995987, 0.726299524, -1, 1.18976459e-07, 1.49711923e-07, 1.1944212e-07, 1.00000024, 0, -1.52022039e-07, -1.86264515e-09, -1.00000024)
Weld74.Part0 = Part3
Weld74.Part1 = Part377
Weld74.part1 = Part377
Weld75.Name = "BTWeld"
Weld75.Parent = Part3
Weld75.C1 = CFrame.new(1.7285347e-06, 0.0122146606, -1.26963711, -1, -2.32830644e-10, 3.04902642e-07, -2.17230991e-07, -0.707107246, -0.70710665, 2.16532499e-07, -0.70710665, 0.707107186)
Weld75.Part0 = Part3
Weld75.Part1 = Part283
Weld75.part1 = Part283
Weld76.Name = "BTWeld"
Weld76.Parent = Part3
Weld76.C1 = CFrame.new(-2.86102295e-06, -0.724999189, 0.384550095, 1, -1.19092874e-07, -4.21059667e-08, 4.47653292e-08, 1.01514161e-06, 1.00000024, -1.19325705e-07, -1.00000024, 1.01327896e-06)
Weld76.Part0 = Part3
Weld76.Part1 = Part291
Weld76.part1 = Part291
Weld77.Name = "BTWeld"
Weld77.Parent = Part3
Weld77.C1 = CFrame.new(-8.94069672e-07, 4.09370422, 0.476376891, 1, -5.93718141e-08, 2.00789145e-07, -3.6903657e-08, -0.993572116, -0.113202639, 2.04046955e-07, 0.113202639, -0.993572235)
Weld77.Part0 = Part3
Weld77.Part1 = Part395
Weld77.part1 = Part395
Weld78.Name = "BTWeld"
Weld78.Parent = Part3
Weld78.C1 = CFrame.new(2.92062759e-06, -0.468894958, 0.574460983, -1, 2.08499841e-07, -3.86498868e-08, 1.92318112e-07, 0.965926051, 0.258818746, 8.94651748e-08, 0.258818746, -0.965926111)
Weld78.Part0 = Part3
Weld78.Part1 = Part451
Weld78.part1 = Part451
Weld79.Name = "BTWeld"
Weld79.Parent = Part3
Weld79.C1 = CFrame.new(1.90734863e-06, 0.962981224, 0.66424036, -1, 5.93718141e-08, 6.19384082e-08, 5.98374754e-08, 1.00000024, -8.94069672e-08, -6.48051355e-08, -9.12696123e-08, -1.00000024)
Weld79.Part0 = Part3
Weld79.Part1 = Part203
Weld79.part1 = Part203
Weld80.Name = "BTWeld"
Weld80.Parent = Part3
Weld80.C1 = CFrame.new(-1.93451118, -0.0312488079, -0.270594597, 1.53435394e-07, 0.998629808, 0.0523359701, -1, 1.53202564e-07, 4.08908818e-09, -2.91402102e-09, -0.0523359627, 0.998629689)
Weld80.Part0 = Part3
Weld80.Part1 = Part397
Weld80.part1 = Part397
Weld81.Name = "BTWeld"
Weld81.Parent = Part3
Weld81.C1 = CFrame.new(-1.90734863e-06, 0.382622719, -0.453119993, 1, 2.32830644e-10, 1.14778231e-09, 2.32830644e-10, 1.00000024, 1.86264515e-09, 1.14778231e-09, 1.86264515e-09, 1.00000024)
Weld81.Part0 = Part3
Weld81.Part1 = Part237
Weld81.part1 = Part237
Weld82.Name = "BTWeld"
Weld82.Parent = Part3
Weld82.C1 = CFrame.new(-1.90734863e-06, 1.7890873, 3.13711452, 1, 2.68220901e-07, 1.37593815e-07, 9.1502443e-08, -0.700908601, 0.713251352, 2.86381692e-07, -0.713251412, -0.700908601)
Weld82.Part0 = Part3
Weld82.Part1 = Part373
Weld82.part1 = Part373
Weld83.Name = "BTWeld"
Weld83.Parent = Part3
Weld83.C1 = CFrame.new(-3.57627869e-06, 1.17321014, 0.911328077, 1, -1.19092874e-07, 2.04781827e-07, -1.19325705e-07, -1.00000024, 2.68220901e-07, 2.03222953e-07, -2.68220901e-07, -1.00000024)
Weld83.Part0 = Part3
Weld83.Part1 = Part163
Weld83.part1 = Part163
Weld84.Name = "BTWeld"
Weld84.Parent = Part3
Weld84.C1 = CFrame.new(1.7285347e-06, -0.568753242, -0.743589878, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld84.Part0 = Part3
Weld84.Part1 = Part281
Weld84.part1 = Part281
Weld85.Name = "BTWeld"
Weld85.Parent = Part3
Weld85.C1 = CFrame.new(-4.17232513e-07, 4.000597, -2.49560165, 1, -3.27709131e-07, 1.59834599e-07, -1.16531737e-07, -0.700910211, -0.713249803, 3.44938599e-07, 0.713249862, -0.700910151)
Weld85.Part0 = Part3
Weld85.Part1 = Part345
Weld85.part1 = Part345
Weld86.Name = "BTWeld"
Weld86.Parent = Part3
Weld86.C1 = CFrame.new(1.78813934e-06, -0.568753242, -1.01896238, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld86.Part0 = Part3
Weld86.Part1 = Part399
Weld86.part1 = Part399
Weld87.Name = "BTWeld"
Weld87.Parent = Part3
Weld87.C1 = CFrame.new(3.69548798e-06, -2.28520775, -0.633616686, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld87.Part0 = Part3
Weld87.Part1 = Part199
Weld87.part1 = Part199
Weld88.Name = "BTWeld"
Weld88.Parent = Part3
Weld88.C1 = CFrame.new(1.78813934e-06, -0.829603195, -0.33899641, -1, 2.08499841e-07, 1.81222276e-07, -2.08849087e-07, -1.00000024, 0, 1.83687007e-07, 1.86264515e-09, 1.00000024)
Weld88.Part0 = Part3
Weld88.Part1 = Part219
Weld88.part1 = Part219
Weld89.Name = "BTWeld"
Weld89.Parent = Part3
Weld89.C1 = CFrame.new(-3.33786011e-06, -0.0132074356, 0.994934082, 1, 2.32830644e-10, 2.04248863e-07, -5.65778464e-08, -0.960049927, 0.279829443, 1.94384484e-07, -0.279829443, -0.960049987)
Weld89.Part0 = Part3
Weld89.Part1 = Part1
Weld89.part1 = Part1
Weld90.Name = "BTWeld"
Weld90.Parent = Part3
Weld90.C1 = CFrame.new(1.96695328e-06, 0.916108131, 0.907114267, -1, 5.93718141e-08, 6.19384082e-08, 5.98374754e-08, 1.00000024, -8.94069672e-08, -6.48051355e-08, -9.12696123e-08, -1.00000024)
Weld90.Part0 = Part3
Weld90.Part1 = Part275
Weld90.part1 = Part275
Weld91.Name = "BTWeld"
Weld91.Parent = Part3
Weld91.C1 = CFrame.new(-1.7285347e-06, -1.12285709, 0.789239883, 1, 2.32830644e-10, -1.49781044e-07, -1.16415322e-10, -1.00000024, -6.14672899e-08, -1.52112989e-07, 5.77419996e-08, -1.00000024)
Weld91.Part0 = Part3
Weld91.Part1 = Part233
Weld91.part1 = Part233
Weld92.Name = "BTWeld"
Weld92.Parent = Part3
Weld92.C1 = CFrame.new(3.03983688e-06, 0.303620577, 0.382497787, -1, -2.08732672e-07, 1.17877789e-07, -1.20393452e-07, -1.19395554e-06, -1.00000024, 2.08499841e-07, -1.00000024, 1.1920929e-06)
Weld92.Part0 = Part3
Weld92.Part1 = Part221
Weld92.part1 = Part221
Weld93.Name = "BTWeld"
Weld93.Parent = Part3
Weld93.C1 = CFrame.new(-0.522247314, -0.0312470198, 0.449783325, -2.65327981e-06, 0.500000775, 0.866025329, -1, -2.96032522e-06, -1.35692608e-06, 1.88592821e-06, -0.866025269, 0.500000715)
Weld93.Part0 = Part3
Weld93.Part1 = Part467
Weld93.part1 = Part467
Weld94.Name = "BTWeld"
Weld94.Parent = Part3
Weld94.C1 = CFrame.new(-3.4570694e-06, 1.39806747, 0.593937159, 1, -1.19092874e-07, 2.05247488e-07, -1.07684173e-07, -0.998391926, -0.0566924736, 2.09929567e-07, 0.0566924661, -0.998391867)
Weld94.Part0 = Part3
Weld94.Part1 = Part339
Weld94.part1 = Part339
Weld95.Name = "BTWeld"
Weld95.Parent = Part3
Weld95.C1 = CFrame.new(0.795685768, -0.0312509537, -0.711493969, -8.45175236e-08, -0.932008028, 0.362438083, 1, -8.89413059e-08, 5.51335688e-09, 2.98023224e-08, 0.362438083, 0.932008028)
Weld95.Part0 = Part3
Weld95.Part1 = Part401
Weld95.part1 = Part401
Weld96.Name = "BTWeld"
Weld96.Parent = Part3
Weld96.C1 = CFrame.new(3.93390656e-06, -1.17022419, -0.44987011, -1, 2.08499841e-07, 1.81222276e-07, -2.08849087e-07, -1.00000024, 0, 1.83687007e-07, 1.86264515e-09, 1.00000024)
Weld96.Part0 = Part3
Weld96.Part1 = Part409
Weld96.part1 = Part409
Weld97.Name = "BTWeld"
Weld97.Parent = Part3
Weld97.C1 = CFrame.new(-2.92062759e-06, 2.3621769, 0.817341089, 1, -1.19092874e-07, 1.99657734e-07, -1.07917003e-07, -0.998391926, -0.0566924736, 2.04341632e-07, 0.0566924661, -0.998391867)
Weld97.Part0 = Part3
Weld97.Part1 = Part381
Weld97.part1 = Part381
Weld98.Name = "BTWeld"
Weld98.Parent = Part3
Weld98.C1 = CFrame.new(-0.431774139, -0.0312498212, 0.503154755, 7.72997737e-08, -0.70710665, 0.707107186, 1, 2.03726813e-08, -8.74406396e-08, 4.88944352e-08, 0.707107186, 0.70710665)
Weld98.Part0 = Part3
Weld98.Part1 = Part431
Weld98.part1 = Part431
Weld99.Name = "BTWeld"
Weld99.Parent = Part3
Weld99.C1 = CFrame.new(-3.15904617e-06, 0.420814514, 0.987199306, 1, -1.18976459e-07, 2.12703526e-07, -1.42492354e-07, -0.993572056, 0.1132036, 1.96479959e-07, -0.113203593, -0.993572116)
Weld99.Part0 = Part3
Weld99.Part1 = Part215
Weld99.part1 = Part215
Weld100.Name = "BTWeld"
Weld100.Parent = Part3
Weld100.C1 = CFrame.new(1.66893005e-06, -0.394741058, -0.312496424, -1, 1.18976459e-07, 3.56074452e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.58400939e-07, -5.77419996e-08, 1.00000024)
Weld100.Part0 = Part3
Weld100.Part1 = Part231
Weld100.part1 = Part231
Weld101.Name = "BTWeld"
Weld101.Parent = Part3
Weld101.C1 = CFrame.new(0.431774139, -0.0312502384, 0.503154755, 1.21071935e-08, 0.70710665, -0.707107186, -1, 2.66591087e-08, 8.21273716e-09, 2.63098627e-08, 0.707107186, 0.70710665)
Weld101.Part0 = Part3
Weld101.Part1 = Part195
Weld101.part1 = Part195
Weld102.Name = "BTWeld"
Weld102.Parent = Part3
Weld102.C1 = CFrame.new(-2.98023224e-06, 0.52676487, 0.681500196, 1, -1.18976459e-07, 2.07579433e-07, -1.19325705e-07, -1.00000024, 3.57627869e-07, 2.05687684e-07, -3.57627869e-07, -1.00000024)
Weld102.Part0 = Part3
Weld102.Part1 = Part247
Weld102.part1 = Part247
Weld103.Name = "BTWeld"
Weld103.Parent = Part3
Weld103.C1 = CFrame.new(-3.33786011e-06, -0.982596397, -1.40651131, 1, 2.08732672e-07, -4.8930815e-10, -1.93249434e-07, 0.922201157, -0.386711091, -7.82310963e-08, 0.386711091, 0.922201216)
Weld103.Part0 = Part3
Weld103.Part1 = Part307
Weld103.part1 = Part307
Weld104.Name = "BTWeld"
Weld104.Parent = Part3
Weld104.C1 = CFrame.new(-0.0437107086, -0.0312517285, 1.4942646, 1.91503204e-07, 0.707107306, 0.70710659, 1, 2.29338184e-08, -2.9189323e-07, -2.23633833e-07, 0.707106531, -0.707107246)
Weld104.Part0 = Part3
Weld104.Part1 = Part259
Weld104.part1 = Part259
Weld105.Name = "BTWeld"
Weld105.Parent = Part3
Weld105.C1 = CFrame.new(3.87430191e-06, -3.31824732, 1.47011757, -1, 2.08499841e-07, 7.08205334e-08, -1.35507435e-07, -0.838670611, 0.544639409, 1.75263267e-07, 0.544639468, 0.838670611)
Weld105.Part0 = Part3
Weld105.Part1 = Part407
Weld105.part1 = Part407
Weld106.Name = "BTWeld"
Weld106.Parent = Part3
Weld106.C1 = CFrame.new(-0.795685768, -0.0312490463, -0.711493969, -4.88944352e-09, 0.932008028, -0.362438083, -1, 1.22236088e-08, 4.33428795e-08, 4.74974513e-08, 0.362438083, 0.932008028)
Weld106.Part0 = Part3
Weld106.Part1 = Part263
Weld106.part1 = Part263
Weld107.Name = "BTWeld"
Weld107.Parent = Part3
Weld107.C1 = CFrame.new(-3.69548798e-06, -3.00638485, 1.33266807, 1, -1.18976459e-07, -3.95668394e-07, -1.86846592e-07, -0.984807968, -0.173648164, -3.70942871e-07, 0.173648179, -0.984807909)
Weld107.Part0 = Part3
Weld107.Part1 = Part351
Weld107.part1 = Part351
Weld108.Name = "BTWeld"
Weld108.Parent = Part3
Weld108.C1 = CFrame.new(3.63588333e-06, -0.320664406, -1.40051842, -1, -2.32830644e-10, 3.04902642e-07, -2.17230991e-07, -0.707107246, -0.70710665, 2.16532499e-07, -0.70710665, 0.707107186)
Weld108.Part0 = Part3
Weld108.Part1 = Part331
Weld108.part1 = Part331
Weld109.Name = "BTWeld"
Weld109.Parent = Part3
Weld109.C1 = CFrame.new(4.17232513e-07, 0.449201822, 1.99047565, -1, 4.76720743e-07, 8.52196536e-08, -6.01830834e-08, 0.0566915721, -0.998391926, -4.81144525e-07, -0.998391926, -0.0566915721)
Weld109.Part0 = Part3
Weld109.Part1 = Part187
Weld109.part1 = Part187
Weld110.Name = "BTWeld"
Weld110.Parent = Part3
Weld110.C1 = CFrame.new(-2.86102295e-06, 2.36217117, 0.642843485, 1, -1.19092874e-07, 1.99657734e-07, -1.07800588e-07, -0.998391807, -0.0566924661, 2.0434527e-07, 0.0566924587, -0.998391867)
Weld110.Part0 = Part3
Weld110.Part1 = Part239
Weld110.part1 = Part239
Weld111.Name = "BTWeld"
Weld111.Parent = Part3
Weld111.C1 = CFrame.new(-3.64600945, -0.0312488079, -0.13107121, 1.57626346e-07, 0.994522154, 0.104528487, -1, 1.56695023e-07, 1.25419319e-08, -2.27009878e-09, -0.104528494, 0.994522214)
Weld111.Part0 = Part3
Weld111.Part1 = Part293
Weld111.part1 = Part293
Weld112.Name = "BTWeld"
Weld112.Parent = Part3
Weld112.C1 = CFrame.new(-1.84774399e-06, -0.363490105, 0.43412137, 1, -1.19092874e-07, -2.68964868e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, -2.71322278e-07, 5.77419996e-08, -1.00000024)
Weld112.Part0 = Part3
Weld112.Part1 = Part387
Weld112.part1 = Part387
Weld113.Name = "BTWeld"
Weld113.Parent = Part3
Weld113.C1 = CFrame.new(1.7285347e-06, -0.568753242, -0.743589878, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld113.Part0 = Part3
Weld113.Part1 = Part471
Weld113.part1 = Part471
Weld114.Name = "BTWeld"
Weld114.Parent = Part3
Weld114.C1 = CFrame.new(5.96046448e-08, 0.289498925, 3.66633129, -1, 4.76720743e-07, 1.08511813e-07, -5.57629392e-08, 0.113202013, -0.993572295, -4.86383215e-07, -0.993572235, -0.113202013)
Weld114.Part0 = Part3
Weld114.Part1 = Part301
Weld114.part1 = Part301
Weld115.Name = "BTWeld"
Weld115.Parent = Part3
Weld115.C1 = CFrame.new(3.75509262e-06, -2.22058773, -0.638116837, -1, 2.08499841e-07, 1.81222276e-07, -2.08849087e-07, -1.00000024, 0, 1.83687007e-07, 1.86264515e-09, 1.00000024)
Weld115.Part0 = Part3
Weld115.Part1 = Part389
Weld115.part1 = Part389
Weld116.Name = "BTWeld"
Weld116.Parent = Part3
Weld116.C1 = CFrame.new(-3.03983688e-06, 0.552669525, 1.01939201, 1, 2.32830644e-10, 1.78628397e-07, -6.84522092e-08, -0.922201097, 0.386711597, 1.62399374e-07, -0.386711597, -0.922201097)
Weld116.Part0 = Part3
Weld116.Part1 = Part255
Weld116.part1 = Part255
Weld117.Name = "BTWeld"
Weld117.Parent = Part3
Weld117.C1 = CFrame.new(-3.75509262e-06, -3.10320187, 0.522767544, 1, -1.19092874e-07, -3.84490704e-07, -8.49831849e-08, -0.996194959, 0.0871557072, -3.95724783e-07, -0.0871557146, -0.996194959)
Weld117.Part0 = Part3
Weld117.Part1 = Part299
Weld117.part1 = Part299
Weld118.Name = "BTWeld"
Weld118.Parent = Part3
Weld118.C1 = CFrame.new(-4.76837158e-07, -2.59509277, 3.90086365, -1, 3.87430191e-07, 3.84452505e-07, 5.47152013e-09, 0.713250041, -0.700909913, -5.47152013e-07, -0.700909972, -0.713250101)
Weld118.Part0 = Part3
Weld118.Part1 = Part461
Weld118.part1 = Part461
Weld119.Name = "BTWeld"
Weld119.Parent = Part3
Weld119.C1 = CFrame.new(-3.4570694e-06, 3.23180103, 0.775444984, 1, -1.19092874e-07, 2.05247488e-07, -1.07567757e-07, -0.998391926, -0.056692116, 2.10009603e-07, 0.0566921085, -0.998391867)
Weld119.Part0 = Part3
Weld119.Part1 = Part349
Weld119.part1 = Part349
Weld120.Name = "BTWeld"
Weld120.Parent = Part3
Weld120.C1 = CFrame.new(-0.854813099, -0.0312469006, 0.683163643, 1.75787136e-08, -0.707106531, 0.707107306, -1, -9.8021701e-08, -7.47404556e-08, 1.20606273e-07, -0.707107365, -0.707106531)
Weld120.Part0 = Part3
Weld120.Part1 = Part217
Weld120.part1 = Part217
Weld121.Name = "BTWeld"
Weld121.Parent = Part3
Weld121.C1 = CFrame.new(8.94069672e-07, 0.388443947, 0.0130519867, -1, 2.08383426e-07, 3.34477591e-07, -3.4889672e-07, -0.866025686, -0.49999994, 1.87254045e-07, -0.499999881, 0.866025686)
Weld121.Part0 = Part3
Weld121.Part1 = Part393
Weld121.part1 = Part393
Weld122.Name = "BTWeld"
Weld122.Parent = Part3
Weld122.C1 = CFrame.new(1.84774399e-06, -1.088727, -0.591116905, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld122.Part0 = Part3
Weld122.Part1 = Part287
Weld122.part1 = Part287
Weld123.Name = "BTWeld"
Weld123.Parent = Part3
Weld123.C1 = CFrame.new(-2.98023224e-06, 0.291165352, -0.776105642, 1, 2.08732672e-07, 7.35781214e-08, -2.08383426e-07, 1.00000024, 1.78813934e-07, -7.12225301e-08, -1.76951289e-07, 1.00000024)
Weld123.Part0 = Part3
Weld123.Part1 = Part235
Weld123.part1 = Part235
Weld124.Name = "BTWeld"
Weld124.Parent = Part3
Weld124.C1 = CFrame.new(-1.78813934e-06, -0.316618919, 0.434119701, 1, -1.19092874e-07, -2.68964868e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, -2.71322278e-07, 5.77419996e-08, -1.00000024)
Weld124.Part0 = Part3
Weld124.Part1 = Part227
Weld124.part1 = Part227
Weld125.Name = "BTWeld"
Weld125.Parent = Part3
Weld125.C1 = CFrame.new(1.7285347e-06, -0.568753242, -0.743589878, -1, 1.18976459e-07, 3.28123861e-07, -1.1944212e-07, -1.00000024, -8.94069672e-08, 3.30041075e-07, -8.7544322e-08, 1.00000024)
Weld125.Part0 = Part3
Weld125.Part1 = Part375
Weld125.part1 = Part375
Weld126.Name = "BTWeld"
Weld126.Parent = Part3
Weld126.C1 = CFrame.new(1.1920929e-06, 0.194246531, 0.194999695, -1, -2.08732672e-07, 1.17877789e-07, -1.20393452e-07, -1.19395554e-06, -1.00000024, 2.08499841e-07, -1.00000024, 1.1920929e-06)
Weld126.Part0 = Part3
Weld126.Part1 = Part223
Weld126.part1 = Part223
Weld127.Name = "BTWeld"
Weld127.Parent = Part3
Weld127.C1 = CFrame.new(2.08616257e-06, 0.382621765, 0.593743563, -1, -2.32830644e-10, -8.87230271e-08, 2.32830644e-10, 1.00000024, 1.86264515e-09, 8.63965397e-08, -1.86264515e-09, -1.00000024)
Weld127.Part0 = Part3
Weld127.Part1 = Part347
Weld127.part1 = Part347
Weld128.Name = "BTWeld"
Weld128.Parent = Part3
Weld128.C1 = CFrame.new(3.87430191e-06, -3.59139156, -0.606614113, -1, 2.08383426e-07, 1.49542757e-07, -2.08732672e-07, -1.00000024, -5.96046448e-08, 1.52112989e-07, -5.77419996e-08, 1.00000024)
Weld128.Part0 = Part3
Weld128.Part1 = Part207
Weld128.part1 = Part207
Weld129.Name = "BTWeld"
Weld129.Parent = Part3
Weld129.C1 = CFrame.new(3.64600849, -0.0312508941, -0.13107121, -2.47033313e-07, -0.994522214, -0.104528487, 1, -2.45636329e-07, -2.16805347e-08, -2.28465069e-09, -0.104528487, 0.994522214)
Weld129.Part0 = Part3
Weld129.Part1 = Part273
Weld129.part1 = Part273
Weld130.Name = "BTWeld"
Weld130.Parent = Part3
Weld130.C1 = CFrame.new(-1.84774399e-06, -0.879115105, 0.593742847, 1, -1.19092874e-07, -2.13065505e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, -2.15442924e-07, 5.77419996e-08, -1.00000024)
Weld130.Part0 = Part3
Weld130.Part1 = Part369
Weld130.part1 = Part369
Weld131.Name = "BTWeld"
Weld131.Parent = Part3
Weld131.C1 = CFrame.new(3.51667404e-06, 2.25183678, 0.638117313, -1, -8.95233825e-08, 3.02316039e-08, -8.92905518e-08, 1.00000024, 5.96046448e-08, -3.29036993e-08, 5.77419996e-08, -1.00000024)
Weld131.Part0 = Part3
Weld131.Part1 = Part285
Weld131.part1 = Part285
Weld132.Name = "BTWeld"
Weld132.Parent = Part3
Weld132.C1 = CFrame.new(1.93451023, -0.0312511921, -0.27059412, -2.42958777e-07, -0.998629749, -0.0523359664, 1, -2.42260285e-07, -8.10723577e-09, -2.90310709e-09, -0.0523359701, 0.998629689)
Weld132.Part0 = Part3
Weld132.Part1 = Part405
Weld132.part1 = Part405
Weld133.Name = "BTWeld"
Weld133.Parent = Part3
Weld133.C1 = CFrame.new(3.63588333e-06, -1.6542244, -0.638116837, -1, 1.18976459e-07, 3.0064075e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.02987246e-07, -5.77419996e-08, 1.00000024)
Weld133.Part0 = Part3
Weld133.Part1 = Part359
Weld133.part1 = Part359
Weld134.Name = "BTWeld"
Weld134.Parent = Part3
Weld134.C1 = CFrame.new(-1.78813934e-06, 0.12912178, -0.362743616, 1, 2.32830644e-10, -1.18105163e-07, 2.32830644e-10, 1.00000024, 1.80676579e-07, 1.20164259e-07, -1.76951289e-07, 1.00000024)
Weld134.Part0 = Part3
Weld134.Part1 = Part183
Weld134.part1 = Part183
Weld135.Name = "BTWeld"
Weld135.Parent = Part3
Weld135.C1 = CFrame.new(-1.7285347e-06, 0.139364243, -0.256871939, 1, -1.18976459e-07, -1.49711923e-07, 1.1944212e-07, 1.00000024, 0, 1.52022039e-07, 1.86264515e-09, 1.00000024)
Weld135.Part0 = Part3
Weld135.Part1 = Part225
Weld135.part1 = Part225
Weld136.Name = "BTWeld"
Weld136.Parent = Part3
Weld136.C1 = CFrame.new(2.86102295e-06, 0.0545005798, 0.453119755, -1, -2.32830644e-10, -8.87230271e-08, 2.32830644e-10, 1.00000024, 1.86264515e-09, 8.63965397e-08, -1.86264515e-09, -1.00000024)
Weld136.Part0 = Part3
Weld136.Part1 = Part337
Weld136.part1 = Part337
Weld137.Name = "BTWeld"
Weld137.Parent = Part3
Weld137.C1 = CFrame.new(0.246384621, -0.0312500596, 0.315700054, 5.82076609e-09, 0.965926111, -0.258819044, -1, 2.29338184e-08, 6.17128535e-08, 6.73753675e-08, 0.258819014, 0.965926111)
Weld137.Part0 = Part3
Weld137.Part1 = Part245
Weld137.part1 = Part245
Weld138.Name = "BTWeld"
Weld138.Parent = Part3
Weld138.C1 = CFrame.new(-1.07288361e-06, 1.90734863e-06, 0.152749538, 1, -1.18976459e-07, -3.88215994e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, -3.90531568e-07, 5.77419996e-08, -1.00000024)
Weld138.Part0 = Part3
Weld138.Part1 = Part309
Weld138.part1 = Part309
Weld139.Name = "BTWeld"
Weld139.Parent = Part3
Weld139.C1 = CFrame.new(-3.03983688e-06, 0.82331419, -0.458539009, 1, 2.08732672e-07, 7.35781214e-08, -9.66247171e-08, 0.707106471, -0.707107365, -1.97673216e-07, 0.707107365, 0.707106471)
Weld139.Part0 = Part3
Weld139.Part1 = Part181
Weld139.part1 = Part181
Weld140.Name = "BTWeld"
Weld140.Parent = Part3
Weld140.C1 = CFrame.new(-3.39746475e-06, -1.05464268, -1.43672371, 1, 2.08732672e-07, -4.8930815e-10, -1.93249434e-07, 0.922201157, -0.386711091, -7.82310963e-08, 0.386711091, 0.922201216)
Weld140.Part0 = Part3
Weld140.Part1 = Part333
Weld140.part1 = Part333
Weld141.Name = "BTWeld"
Weld141.Parent = Part3
Weld141.C1 = CFrame.new(0.0437097549, -0.0312481523, 1.49426508, -1.02329068e-07, -0.707107306, -0.707106531, -1, -1.1047814e-07, 2.52499376e-07, -2.57976353e-07, 0.70710659, -0.707107306)
Weld141.Part0 = Part3
Weld141.Part1 = Part249
Weld141.part1 = Part249
Weld142.Name = "BTWeld"
Weld142.Parent = Part3
Weld142.C1 = CFrame.new(1.84774399e-06, 1.04499984, 4.84788132, -1, -2.32830644e-10, 1.16708179e-07, -1.19271135e-07, -1.01514161e-06, -1.00000024, -1.16415322e-10, -1.00000024, 1.01141632e-06)
Weld142.Part0 = Part3
Weld142.Part1 = Part205
Weld142.part1 = Part205
Weld143.Name = "BTWeld"
Weld143.Parent = Part3
Weld143.C1 = CFrame.new(-3.03983688e-06, 0.591758728, 0.577001572, 1, -1.18976459e-07, 2.07579433e-07, -1.19325705e-07, -1.00000024, 3.57627869e-07, 2.05687684e-07, -3.57627869e-07, -1.00000024)
Weld143.Part0 = Part3
Weld143.Part1 = Part385
Weld143.part1 = Part385
Weld144.Name = "BTWeld"
Weld144.Parent = Part3
Weld144.C1 = CFrame.new(-0.568752289, -0.0312482715, 1.24358273, -5.98374754e-08, -1.00000024, 0, -1, 5.93718141e-08, 3.27925591e-07, -3.30370312e-07, -1.86264515e-09, -1.00000024)
Weld144.Part0 = Part3
Weld144.Part1 = Part197
Weld144.part1 = Part197
Weld145.Name = "BTWeld"
Weld145.Parent = Part3
Weld145.C1 = CFrame.new(8.34465027e-07, 0.340940475, -0.537741661, -1, 2.08383426e-07, 3.34477591e-07, -1.24564394e-08, -0.866025329, 0.500000596, 3.95695679e-07, 0.500000596, 0.866025448)
Weld145.Part0 = Part3
Weld145.Part1 = Part357
Weld145.part1 = Part357
Weld146.Name = "BTWeld"
Weld146.Parent = Part3
Weld146.C1 = CFrame.new(-0.0784215927, -0.0312500596, 0.188100338, -2.43075192e-07, -0.866025627, -0.5, 1, -2.29571015e-07, -8.65911716e-08, -3.80096026e-08, -0.49999994, 0.866025686)
Weld146.Part0 = Part3
Weld146.Part1 = Part343
Weld146.part1 = Part343
Weld147.Name = "BTWeld"
Weld147.Parent = Part3
Weld147.C1 = CFrame.new(0.078420639, -0.0312501192, 0.188100815, 1.53668225e-07, 0.866025686, 0.5, -1, 1.49011612e-07, 4.73319233e-08, -3.19560058e-08, -0.49999994, 0.866025686)
Weld147.Part0 = Part3
Weld147.Part1 = Part353
Weld147.part1 = Part353
Weld148.Name = "BTWeld"
Weld148.Parent = Part3
Weld148.C1 = CFrame.new(-3.39746475e-06, -1.19873238, -1.4971447, 1, 2.08732672e-07, -4.8930815e-10, -1.93249434e-07, 0.922201157, -0.386711091, -7.82310963e-08, 0.386711091, 0.922201216)
Weld148.Part0 = Part3
Weld148.Part1 = Part313
Weld148.part1 = Part313
Weld149.Name = "BTWeld"
Weld149.Parent = Part3
Weld149.C1 = CFrame.new(-0.665288925, -0.0312472582, -0.400229454, 6.10016286e-08, 0.999914467, 0.0130897425, -1, 6.01867214e-08, 2.42216629e-08, 2.52284735e-08, -0.0130897434, 0.999914587)
Weld149.Part0 = Part3
Weld149.Part1 = Part211
Weld149.part1 = Part211
Weld150.Name = "BTWeld"
Weld150.Parent = Part3
Weld150.C1 = CFrame.new(1.78813934e-06, -0.22074604, -0.390618801, -1, 1.18976459e-07, 3.56074452e-07, -1.19325705e-07, -1.00000024, -5.96046448e-08, 3.58400939e-07, -5.77419996e-08, 1.00000024)
Weld150.Part0 = Part3
Weld150.Part1 = Part311
Weld150.part1 = Part311
Weld151.Name = "BTWeld"
Weld151.Parent = Part3
Weld151.C1 = CFrame.new(-3.39746475e-06, -1.12668896, -1.46693516, 1, 2.08732672e-07, -4.8930815e-10, -1.93249434e-07, 0.922201157, -0.386711091, -7.82310963e-08, 0.386711091, 0.922201216)
Weld151.Part0 = Part3
Weld151.Part1 = Part319
Weld151.part1 = Part319
Weld152.Name = "BTWeld"
Weld152.Parent = Part3
Weld152.C1 = CFrame.new(-3.03983688e-06, 0.522769928, 0.783498287, 1, -1.18976459e-07, 2.07579433e-07, -1.19325705e-07, -1.00000024, 3.57627869e-07, 2.05687684e-07, -3.57627869e-07, -1.00000024)
Weld152.Part0 = Part3
Weld152.Part1 = Part189
Weld152.part1 = Part189
Weld153.Name = "BTWeld"
Weld153.Parent = Part3
Weld153.C1 = CFrame.new(0.854812145, -0.0312569141, 0.683163643, -7.71833584e-08, 0.707106531, -0.707107306, 1, 1.8987339e-07, 8.20728019e-08, 1.90921128e-07, -0.707107365, -0.707106531)
Weld153.Part0 = Part3
Weld153.Part1 = Part271
Weld153.part1 = Part271
Weld154.Name = "BTWeld"
Weld154.Parent = Part3
Weld154.C1 = CFrame.new(1.78813934e-06, -0.589484215, -0.222372532, -1, 2.08499841e-07, 2.3712164e-07, -2.08849087e-07, -1.00000024, 0, 2.39566361e-07, 1.86264515e-09, 1.00000024)
Weld154.Part0 = Part3
Weld154.Part1 = Part303
Weld154.part1 = Part303
Weld155.Name = "BTWeld"
Weld155.Parent = Part3
Weld155.C1 = CFrame.new(-2.44379044e-06, 1.74366188, -2.46923256, 1, -3.87313776e-07, -1.35698428e-07, -2.53145117e-07, -0.31730628, -0.948323369, 3.2375101e-07, 0.948323369, -0.31730631)
Weld155.Part0 = Part3
Weld155.Part1 = Part305
Weld155.part1 = Part305
Weld156.Name = "BTWeld"
Weld156.Parent = Part3
Weld156.C1 = CFrame.new(2.74181366e-06, 0.0869274139, -0.603420258, -1, 2.08499841e-07, 2.86032446e-07, 5.57629392e-08, -0.707106411, 0.707107425, 3.51225026e-07, 0.707107425, 0.707106411)
Weld156.Part0 = Part3
Weld156.Part1 = Part413
Weld156.part1 = Part413
Weld157.Name = "BTWeld"
Weld157.Parent = Part3
Weld157.C1 = CFrame.new(-1.25169754e-06, 2.73876762, 0.462646961, 1, -2.08499841e-07, 1.89578714e-07, -1.861481e-07, -0.993572116, -0.113202803, 2.0985317e-07, 0.113202795, -0.993572176)
Weld157.Part0 = Part3
Weld157.Part1 = Part267
Weld157.part1 = Part267
Weld158.Name = "BTWeld"
Weld158.Parent = Part3
Weld158.C1 = CFrame.new(8.94069672e-07, 0.443323135, -0.28379035, -1, 2.08383426e-07, 3.34477591e-07, -2.08732672e-07, -1.00000024, 1.78813934e-07, 3.36614903e-07, 1.80676579e-07, 1.00000024)
Weld158.Part0 = Part3
Weld158.Part1 = Part439
Weld158.part1 = Part439
Weld159.Name = "BTWeld"
Weld159.Parent = Part3
Weld159.C1 = CFrame.new(-2.98023224e-07, 2.46521568, 0.596743584, -1, -8.95233825e-08, 3.02316039e-08, -8.92905518e-08, 1.00000024, 5.96046448e-08, -3.29036993e-08, 5.77419996e-08, -1.00000024)
Weld159.Part0 = Part3
Weld159.Part1 = Part201
Weld159.part1 = Part201
Weld160.Name = "BTWeld"
Weld160.Parent = Part3
Weld160.C1 = CFrame.new(0.665288925, -0.0312529206, -0.400229454, -1.50408596e-07, -0.999914527, -0.0130897444, 1, -1.49477273e-07, -2.5913323e-08, 2.56950443e-08, -0.0130897444, 0.999914587)
Weld160.Part0 = Part3
Weld160.Part1 = Part279
Weld160.part1 = Part279
Weld161.Name = "BTWeld"
Weld161.Parent = Part3
Weld161.C1 = CFrame.new(-3.63588333e-06, 1.55414867, 1.9456358, 1, 8.95233825e-08, 2.22247763e-07, -4.30736691e-08, -0.843391299, 0.537300408, 2.34518666e-07, -0.537300348, -0.84339118)
Weld161.Part0 = Part3
Weld161.Part1 = Part335
Weld161.part1 = Part335
Weld162.Name = "BTWeld"
Weld162.Parent = Part3
Weld162.C1 = CFrame.new(8.34465027e-07, -3.73201656, 0.770674467, 1, 2.32830644e-10, -2.6903399e-07, -2.32830644e-10, -1.00000024, 8.7544322e-08, -2.71093086e-07, -9.12696123e-08, -1.00000024)
Weld162.Part0 = Part3
Weld162.Part1 = Part185
Weld162.part1 = Part185
Part163.Parent = Model0
Part163.CFrame = CFrame.new(-0.611257851, 3.46313882, -15.394145, 0.999985635, -0.00162807317, 0.00510706799, 0.00513700349, 0.0189462826, -0.999807417, 0.00153099932, 0.999819279, 0.0189543739)
Part163.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part163.Position = Vector3.new(-0.611257851, 3.46313882, -15.394145)
Part163.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part163.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part163.Velocity = Vector3.new(2.31788153e-08, 0.0024639722, 3.04594494e-07)
Part163.Size = Vector3.new(0.275000006, 0.84512496, 0.359375)
Part163.Anchored = true
Part163.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part163.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part163.BrickColor = BrickColor.new("Really black")
Part163.CanCollide = false
Part163.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part163.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part163.Material = Enum.Material.Metal
Part163.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part163.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part163.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part163.brickColor = BrickColor.new("Really black")
SpecialMesh164.Parent = Part163
SpecialMesh164.Scale = Vector3.new(0.349999994, 1, 0.5)
SpecialMesh164.MeshType = Enum.MeshType.Brick
Part165.Parent = Model0
Part165.CFrame = CFrame.new(-0.617485046, 3.2590127, -10.6418428, -0.999985635, -0.00414685067, -0.00339615461, -0.00513672922, 0.560423911, 0.828190207, -0.00153109396, 0.828195751, -0.560437143)
Part165.Orientation = Vector3.new(-55.9099998, -179.649994, -0.529999971)
Part165.Position = Vector3.new(-0.617485046, 3.2590127, -10.6418428)
Part165.Rotation = Vector3.new(-124.089996, -0.189999998, 179.759995)
Part165.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part165.Velocity = Vector3.new(5.55462663e-08, 0.00247387378, 7.29936687e-07)
Part165.Size = Vector3.new(0.275000006, 0.4375, 0.25)
Part165.Anchored = true
Part165.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part165.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part165.BrickColor = BrickColor.new("Really black")
Part165.CanCollide = false
Part165.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part165.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part165.Material = Enum.Material.Metal
Part165.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part165.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part165.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part165.brickColor = BrickColor.new("Really black")
SpecialMesh166.Parent = Part165
SpecialMesh166.Scale = Vector3.new(0.5, 1, 0.25)
SpecialMesh166.MeshType = Enum.MeshType.Brick
Part167.Parent = Model0
Part167.CFrame = CFrame.new(-0.610199153, 2.88768315, -14.1553068, 0.999985635, 0.00162795268, -0.00510686403, 0.0051367972, -0.0189460143, 0.999807417, 0.00153088395, -0.999819279, -0.0189541057)
Part167.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part167.Position = Vector3.new(-0.610199153, 2.88768315, -14.1553068)
Part167.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part167.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part167.Velocity = Vector3.new(1.14426342e-07, 0.00246655382, 1.50368453e-06)
Part167.Size = Vector3.new(0.275000006, 0.207000002, 0.303375006)
Part167.Anchored = true
Part167.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part167.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part167.BrickColor = BrickColor.new("Really black")
Part167.CanCollide = false
Part167.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part167.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part167.Material = Enum.Material.Glass
Part167.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part167.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part167.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part167.brickColor = BrickColor.new("Really black")
SpecialMesh168.Parent = Part167
SpecialMesh168.Scale = Vector3.new(0.524999976, 0.5, 0.5)
SpecialMesh168.MeshType = Enum.MeshType.Wedge
Part169.Parent = Model0
Part169.CFrame = CFrame.new(-0.613238811, 3.32843637, -13.6493177, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part169.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part169.Position = Vector3.new(-0.613238811, 3.32843637, -13.6493177)
Part169.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part169.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part169.Velocity = Vector3.new(4.45380195e-08, 0.00246760761, 5.85277007e-07)
Part169.Size = Vector3.new(0.275000006, 0.698124886, 0.534374952)
Part169.Anchored = true
Part169.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part169.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part169.BrickColor = BrickColor.new("Bright blue")
Part169.CanCollide = false
Part169.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part169.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part169.Material = Enum.Material.Neon
Part169.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part169.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part169.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part169.brickColor = BrickColor.new("Bright blue")
SpecialMesh170.Parent = Part169
SpecialMesh170.Scale = Vector3.new(0.452499986, 1, 1)
SpecialMesh170.MeshType = Enum.MeshType.Cylinder
Part171.Parent = Model0
Part171.CFrame = CFrame.new(-0.610366702, 3.28867483, -15.3908367, 0.999985635, -0.00162807317, 0.00510706799, 0.00513700349, 0.0189462826, -0.999807417, 0.00153099932, 0.999819279, 0.0189543739)
Part171.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part171.Position = Vector3.new(-0.610366702, 3.28867483, -15.3908367)
Part171.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part171.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part171.Velocity = Vector3.new(5.08428144e-08, 0.00246397941, 6.68129019e-07)
Part171.Size = Vector3.new(0.275000006, 0.84512496, 0.422374964)
Part171.Anchored = true
Part171.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part171.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part171.BrickColor = BrickColor.new("Really black")
Part171.CanCollide = false
Part171.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part171.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part171.Material = Enum.Material.Metal
Part171.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part171.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part171.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part171.brickColor = BrickColor.new("Really black")
SpecialMesh172.Parent = Part171
SpecialMesh172.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh172.MeshType = Enum.MeshType.Brick
Part173.Parent = Model0
Part173.CFrame = CFrame.new(-0.610880256, 2.96906447, -13.9840736, -0.999985635, -0.00162807154, -0.00510650687, -0.00513644237, 0.0189459547, 0.999807417, -0.00153100991, 0.999819279, -0.0189540461)
Part173.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part173.Position = Vector3.new(-0.610880256, 2.96906447, -13.9840736)
Part173.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part173.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part173.Velocity = Vector3.new(1.01522062e-07, 0.00246691052, 1.33410845e-06)
Part173.Size = Vector3.new(0.275000006, 0.239124984, 0.205375016)
Part173.Anchored = true
Part173.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part173.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part173.BrickColor = BrickColor.new("Bright blue")
Part173.CanCollide = false
Part173.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part173.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part173.Material = Enum.Material.Neon
Part173.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part173.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part173.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part173.brickColor = BrickColor.new("Bright blue")
SpecialMesh174.Parent = Part173
SpecialMesh174.Scale = Vector3.new(0.550000012, 1, 1)
SpecialMesh174.MeshType = Enum.MeshType.Brick
Part175.Parent = Model0
Part175.CFrame = CFrame.new(-0.613238811, 3.32843637, -13.6493177, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part175.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part175.Position = Vector3.new(-0.613238811, 3.32843637, -13.6493177)
Part175.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part175.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part175.Velocity = Vector3.new(4.45380195e-08, 0.00246760761, 5.85277007e-07)
Part175.Size = Vector3.new(0.275000006, 0.698124886, 0.372374952)
Part175.Anchored = true
Part175.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part175.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part175.BrickColor = BrickColor.new("Really black")
Part175.CanCollide = false
Part175.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part175.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part175.Material = Enum.Material.Metal
Part175.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part175.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part175.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part175.brickColor = BrickColor.new("Really black")
SpecialMesh176.Parent = Part175
SpecialMesh176.Scale = Vector3.new(0.455000013, 1, 1)
SpecialMesh176.MeshType = Enum.MeshType.Cylinder
Part177.Parent = Model0
Part177.CFrame = CFrame.new(-0.616063476, 3.26214504, -11.5807333, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part177.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part177.Position = Vector3.new(-0.616063476, 3.26214504, -11.5807333)
Part177.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part177.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part177.Velocity = Vector3.new(5.50495756e-08, 0.00247191754, 7.23409755e-07)
Part177.Size = Vector3.new(0.275000006, 0.630125046, 0.280375004)
Part177.Anchored = true
Part177.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part177.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part177.BrickColor = BrickColor.new("Really black")
Part177.CanCollide = false
Part177.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part177.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part177.Material = Enum.Material.Metal
Part177.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part177.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part177.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part177.brickColor = BrickColor.new("Really black")
SpecialMesh178.Parent = Part177
SpecialMesh178.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh178.MeshType = Enum.MeshType.Brick
Part179.Parent = Model0
Part179.CFrame = CFrame.new(-0.610621691, 3.13382888, -14.7050791, 0.999985635, -0.00476216245, 0.00246017892, 0.00513689732, 0.720368028, -0.693573177, 0.00153067347, 0.693575799, 0.720382154)
Part179.Orientation = Vector3.new(43.9099998, 0.199999988, 0.409999996)
Part179.Position = Vector3.new(-0.610621691, 3.13382888, -14.7050791)
Part179.Rotation = Vector3.new(43.9099998, 0.140000001, 0.269999981)
Part179.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part179.Velocity = Vector3.new(7.53960734e-08, 0.0024654083, 9.90785111e-07)
Part179.Size = Vector3.new(0.275000006, 0.221124932, 0.418375015)
Part179.Anchored = true
Part179.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part179.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part179.BrickColor = BrickColor.new("Really black")
Part179.CanCollide = false
Part179.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part179.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part179.Material = Enum.Material.Metal
Part179.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part179.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part179.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part179.brickColor = BrickColor.new("Really black")
SpecialMesh180.Parent = Part179
SpecialMesh180.Scale = Vector3.new(0.550000012, 1.04999995, 0.899999976)
SpecialMesh180.MeshType = Enum.MeshType.Brick
Part181.Parent = Model0
Part181.CFrame = CFrame.new(-0.61356318, 3.48533392, -13.9631662, 0.999985635, 0.0047621401, -0.00246015727, 0.00513686566, -0.720367908, 0.693573296, 0.00153067405, -0.693575978, -0.720381975)
Part181.Orientation = Vector3.new(-43.9099998, -179.800003, 179.589996)
Part181.Position = Vector3.new(-0.61356318, 3.48533392, -13.9631662)
Part181.Rotation = Vector3.new(-136.089996, -0.140000001, -0.269999981)
Part181.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part181.Velocity = Vector3.new(1.96594527e-08, 0.00246695359, 2.58346063e-07)
Part181.Size = Vector3.new(0.275000006, 0.413124949, 0.622375011)
Part181.Anchored = true
Part181.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part181.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part181.BrickColor = BrickColor.new("Really black")
Part181.CanCollide = false
Part181.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part181.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part181.Material = Enum.Material.Metal
Part181.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part181.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part181.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part181.brickColor = BrickColor.new("Really black")
SpecialMesh182.Parent = Part181
SpecialMesh182.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh182.MeshType = Enum.MeshType.Brick
Part183.Parent = Model0
Part183.CFrame = CFrame.new(-0.610578179, 2.93933439, -14.0816517, 0.999985635, 0.00162795174, -0.00510674529, 0.005136678, -0.0189458355, 0.999807417, 0.00153088616, -0.999819279, -0.0189539269)
Part183.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part183.Position = Vector3.new(-0.610578179, 2.93933439, -14.0816517)
Part183.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part183.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part183.Velocity = Vector3.new(1.06236229e-07, 0.00246670726, 1.39605754e-06)
Part183.Size = Vector3.new(0.275000006, 0.252000004, 0.213375002)
Part183.Anchored = true
Part183.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part183.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part183.BrickColor = BrickColor.new("Really black")
Part183.CanCollide = false
Part183.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part183.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part183.Material = Enum.Material.Metal
Part183.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part183.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part183.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part183.brickColor = BrickColor.new("Really black")
SpecialMesh184.Parent = Part183
SpecialMesh184.Scale = Vector3.new(0.569999993, 0.125, 0.375)
SpecialMesh184.MeshType = Enum.MeshType.Wedge
Part185.Parent = Model0
Part185.CFrame = CFrame.new(-0.61852932, 3.41544771, -10.4871407, 0.999985635, -0.00162795314, 0.00510659395, 0.00513652712, 0.0189461038, -0.999807417, 0.00153088907, 0.999819279, 0.0189541951)
Part185.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part185.Position = Vector3.new(-0.61852932, 3.41544771, -10.4871407)
Part185.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part185.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part185.Velocity = Vector3.new(3.07410488e-08, 0.00247419602, 4.03969523e-07)
Part185.Size = Vector3.new(0.270000011, 0.21875, 0.234375)
Part185.Anchored = true
Part185.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part185.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part185.BrickColor = BrickColor.new("Really black")
Part185.CanCollide = false
Part185.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part185.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part185.Material = Enum.Material.Metal
Part185.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part185.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part185.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part185.brickColor = BrickColor.new("Really black")
SpecialMesh186.Parent = Part185
SpecialMesh186.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh186.MeshType = Enum.MeshType.Wedge
Part187.Parent = Model0
Part187.CFrame = CFrame.new(-0.608188927, 3.09825993, -16.1759663, -0.999985635, 0.00519088237, -0.00133629935, -0.0051367199, -0.999273539, -0.0377651006, -0.0015313623, -0.0377576947, 0.999285877)
Part187.Orientation = Vector3.new(2.15999985, -0.0799999982, -179.709991)
Part187.Position = Vector3.new(-0.608188927, 3.09825993, -16.1759663)
Part187.Rotation = Vector3.new(2.15999985, -0.0799999982, -179.699997)
Part187.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part187.Velocity = Vector3.new(8.10360774e-08, 0.00246234378, 1.06490097e-06)
Part187.Size = Vector3.new(0.275000006, 0.235124931, 1.6693753)
Part187.Anchored = true
Part187.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part187.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part187.BrickColor = BrickColor.new("Really black")
Part187.CanCollide = false
Part187.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part187.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part187.Material = Enum.Material.Metal
Part187.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part187.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part187.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part187.brickColor = BrickColor.new("Really black")
SpecialMesh188.Parent = Part187
SpecialMesh188.Scale = Vector3.new(0.400000006, 1.04999995, 1)
SpecialMesh188.MeshType = Enum.MeshType.Brick
Part189.Parent = Model0
Part189.CFrame = CFrame.new(-0.611664593, 3.3476572, -14.7413998, 0.999985635, -0.00162807363, 0.00510707032, 0.00513700629, 0.018946372, -0.999807417, 0.0015309992, 0.999819279, 0.0189544633)
Part189.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part189.Position = Vector3.new(-0.611664593, 3.3476572, -14.7413998)
Part189.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part189.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part189.Velocity = Vector3.new(4.14902424e-08, 0.00246533239, 5.45226158e-07)
Part189.Size = Vector3.new(0.275000006, 0.480124891, 0.214375019)
Part189.Anchored = true
Part189.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part189.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part189.BrickColor = BrickColor.new("Bright blue")
Part189.CanCollide = false
Part189.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part189.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part189.Material = Enum.Material.Neon
Part189.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part189.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part189.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part189.brickColor = BrickColor.new("Bright blue")
SpecialMesh190.Parent = Part189
SpecialMesh190.Scale = Vector3.new(0.449999988, 1, 0.100000001)
SpecialMesh190.MeshType = Enum.MeshType.Brick
Part191.Parent = Model0
Part191.CFrame = CFrame.new(-0.637731671, 3.71308732, -19.354105, -0.0050775772, -0.999985635, -0.00171704381, 0.999324501, -0.00513670873, 0.0363931209, -0.0364014208, -0.00153109431, 0.999336243)
Part191.Orientation = Vector3.new(-2.08999991, -0.099999994, 90.2900009)
Part191.Position = Vector3.new(-0.637731671, 3.71308732, -19.354105)
Part191.Rotation = Vector3.new(-2.08999991, -0.099999994, 90.2900009)
Part191.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part191.Velocity = Vector3.new(-1.64544822e-08, 0.00245571672, -2.16228841e-07)
Part191.Size = Vector3.new(0.210000038, 0.200000003, 0.285374999)
Part191.Anchored = true
Part191.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part191.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part191.BrickColor = BrickColor.new("Royal purple")
Part191.CanCollide = false
Part191.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part191.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part191.Material = Enum.Material.Neon
Part191.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part191.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part191.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part191.brickColor = BrickColor.new("Royal purple")
SpecialMesh192.Parent = Part191
SpecialMesh192.Scale = Vector3.new(0.5, 0.300000012, 0.5)
SpecialMesh192.MeshType = Enum.MeshType.Wedge
Part193.Parent = Model0
Part193.CFrame = CFrame.new(-0.613232374, 3.39655375, -13.8819904, 0.999985635, 0.000250508543, -0.00535421353, 0.00513686566, 0.240468621, 0.97064352, 0.00153067405, -0.970657051, 0.240463868)
Part193.Orientation = Vector3.new(-76.0800018, -1.27999997, 1.22000003)
Part193.Position = Vector3.new(-0.613232374, 3.39655375, -13.8819904)
Part193.Rotation = Vector3.new(-76.0899963, -0.310000002, -0.00999999978)
Part193.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part193.Velocity = Vector3.new(3.37369386e-08, 0.00246712286, 4.43339275e-07)
Part193.Size = Vector3.new(0.275000006, 0.422124922, 0.412375003)
Part193.Anchored = true
Part193.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part193.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part193.BrickColor = BrickColor.new("Really black")
Part193.CanCollide = false
Part193.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part193.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part193.Material = Enum.Material.Metal
Part193.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part193.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part193.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part193.brickColor = BrickColor.new("Really black")
SpecialMesh194.Parent = Part193
SpecialMesh194.Scale = Vector3.new(0.5, 1.04999995, 0.5)
SpecialMesh194.MeshType = Enum.MeshType.Brick
Part195.Parent = Model0
Part195.CFrame = CFrame.new(-0.640585661, 2.53611565, -13.5419912, 0.00476224814, -0.999985635, -0.00245993445, -0.72036773, -0.00513678836, 0.693573475, -0.693576157, -0.00153091096, -0.720381796)
Part195.Orientation = Vector3.new(-43.9099998, -179.800003, -90.409996)
Part195.Position = Vector3.new(-0.640585661, 2.53611565, -13.5419912)
Part195.Rotation = Vector3.new(-136.089996, -0.140000001, 89.7299957)
Part195.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part195.Velocity = Vector3.new(1.70172896e-07, 0.00246782694, 2.23625375e-06)
Part195.Size = Vector3.new(0.421999991, 0.200000003, 0.280375004)
Part195.Anchored = true
Part195.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part195.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part195.BrickColor = BrickColor.new("Royal purple")
Part195.CanCollide = false
Part195.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part195.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part195.Material = Enum.Material.Neon
Part195.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part195.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part195.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part195.brickColor = BrickColor.new("Royal purple")
SpecialMesh196.Parent = Part195
SpecialMesh196.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh196.MeshType = Enum.MeshType.Wedge
Part197.Parent = Model0
Part197.CFrame = CFrame.new(-0.647041559, 3.82817221, -13.658843, -0.00162801228, -0.999985635, 0.00510653481, 0.0189460143, -0.00513646938, -0.999807417, 0.999819279, -0.00153094972, 0.0189541057)
Part197.Orientation = Vector3.new(88.8799973, 15.0799999, 105.169998)
Part197.Position = Vector3.new(-0.647041559, 3.82817221, -13.658843)
Part197.Rotation = Vector3.new(88.909996, 0.289999992, 90.0899963)
Part197.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part197.Velocity = Vector3.new(-3.47029321e-08, 0.00246758247, -4.56033831e-07)
Part197.Size = Vector3.new(0.643000007, 0.200000003, 0.280375004)
Part197.Anchored = true
Part197.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part197.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part197.BrickColor = BrickColor.new("Royal purple")
Part197.CanCollide = false
Part197.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part197.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part197.Material = Enum.Material.Neon
Part197.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part197.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part197.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part197.brickColor = BrickColor.new("Royal purple")
SpecialMesh198.Parent = Part197
SpecialMesh198.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh198.MeshType = Enum.MeshType.Wedge
Part199.Parent = Model0
Part199.CFrame = CFrame.new(-0.615469754, 3.2510047, -11.9310894, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part199.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part199.Position = Vector3.new(-0.615469754, 3.2510047, -11.9310894)
Part199.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part199.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part199.Velocity = Vector3.new(5.68160452e-08, 0.00247118762, 7.46623186e-07)
Part199.Size = Vector3.new(0.275000006, 0.261124998, 0.245374992)
Part199.Anchored = true
Part199.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part199.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part199.BrickColor = BrickColor.new("Bright blue")
Part199.CanCollide = false
Part199.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part199.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part199.Material = Enum.Material.Neon
Part199.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part199.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part199.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part199.brickColor = BrickColor.new("Bright blue")
SpecialMesh200.Parent = Part199
SpecialMesh200.Scale = Vector3.new(0.375, 1.04999995, 0.5)
SpecialMesh200.MeshType = Enum.MeshType.Brick
Part201.Parent = Model0
Part201.CFrame = CFrame.new(-0.615578175, 3.21754885, -11.7504148, -0.999985635, 0.00162786292, 0.00510683237, -0.00513676414, -0.0189459566, -0.999807417, -0.00153079513, -0.999819279, 0.0189540461)
Part201.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part201.Position = Vector3.new(-0.615578175, 3.21754885, -11.7504148)
Part201.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part201.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part201.Velocity = Vector3.new(6.21209963e-08, 0.0024715641, 8.16335842e-07)
Part201.Size = Vector3.new(0.275000006, 0.214125022, 0.234375)
Part201.Anchored = true
Part201.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part201.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part201.BrickColor = BrickColor.new("Really black")
Part201.CanCollide = false
Part201.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part201.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part201.Material = Enum.Material.Metal
Part201.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part201.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part201.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part201.brickColor = BrickColor.new("Really black")
SpecialMesh202.Parent = Part201
SpecialMesh202.Scale = Vector3.new(0.5, 0.560000002, 0.400000006)
SpecialMesh202.MeshType = Enum.MeshType.Wedge
Part203.Parent = Model0
Part203.CFrame = CFrame.new(-0.613475382, 3.25657153, -13.2536583, -0.999985635, 0.00162801275, 0.00510680024, -0.00513673527, -0.0189461038, -0.999807417, -0.00153094472, -0.999819279, 0.0189541951)
Part203.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part203.Position = Vector3.new(-0.613475382, 3.25657153, -13.2536583)
Part203.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part203.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part203.Velocity = Vector3.new(5.59333202e-08, 0.00246843207, 7.35023434e-07)
Part203.Size = Vector3.new(0.275000006, 0.204125047, 0.210375011)
Part203.Anchored = true
Part203.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part203.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part203.BrickColor = BrickColor.new("Really black")
Part203.CanCollide = false
Part203.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part203.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part203.Material = Enum.Material.Metal
Part203.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part203.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part203.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part203.brickColor = BrickColor.new("Really black")
SpecialMesh204.Parent = Part203
SpecialMesh204.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh204.MeshType = Enum.MeshType.Wedge
Part205.Parent = Model0
Part205.CFrame = CFrame.new(-0.605959892, 3.52715993, -19.0706863, -0.999985635, 0.00510674436, -0.0016279578, -0.00513667939, -0.999807417, 0.0189470276, -0.00153088616, 0.018955119, 0.999819279)
Part205.Orientation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part205.Position = Vector3.new(-0.605959892, 3.52715993, -19.0706863)
Part205.Rotation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part205.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part205.Velocity = Vector3.new(1.30272237e-08, 0.0024563123, 1.71192255e-07)
Part205.Size = Vector3.new(0.275000006, 0.446125001, 0.496375084)
Part205.Anchored = true
Part205.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part205.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part205.BrickColor = BrickColor.new("Really black")
Part205.CanCollide = false
Part205.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part205.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part205.Material = Enum.Material.Metal
Part205.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part205.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part205.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part205.brickColor = BrickColor.new("Really black")
SpecialMesh206.Parent = Part205
SpecialMesh206.Scale = Vector3.new(0.400000006, 1, 0.899999976)
SpecialMesh206.MeshType = Enum.MeshType.Wedge
Part207.Parent = Model0
Part207.CFrame = CFrame.new(-0.617458701, 3.24875402, -10.62463, -0.999985635, -0.00162816094, -0.00510671316, -0.00513665052, 0.0189459547, 0.999807417, -0.00153109536, 0.999819279, -0.0189540461)
Part207.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part207.Position = Vector3.new(-0.617458701, 3.24875402, -10.62463)
Part207.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part207.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part207.Velocity = Vector3.new(5.71729402e-08, 0.00247390964, 7.51312939e-07)
Part207.Size = Vector3.new(0.25999999, 0.375, 0.21875)
Part207.Anchored = true
Part207.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part207.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part207.BrickColor = BrickColor.new("Really black")
Part207.CanCollide = false
Part207.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part207.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part207.Material = Enum.Material.Metal
Part207.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part207.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part207.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part207.brickColor = BrickColor.new("Really black")
SpecialMesh208.Parent = Part207
SpecialMesh208.Scale = Vector3.new(0.300000012, 1, 1)
SpecialMesh208.MeshType = Enum.MeshType.Wedge
Part209.Parent = Model0
Part209.CFrame = CFrame.new(-0.614153862, 3.21053505, -12.6548157, -0.999985635, -0.00162816129, -0.00510668149, -0.00513661886, 0.0189460143, 0.999807417, -0.00153109606, 0.999819279, -0.0189541057)
Part209.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part209.Position = Vector3.new(-0.614153862, 3.21053505, -12.6548157)
Part209.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part209.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part209.Velocity = Vector3.new(6.32331378e-08, 0.00246967981, 8.30950682e-07)
Part209.Size = Vector3.new(0.275000006, 0.35512504, 0.416375011)
Part209.Anchored = true
Part209.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part209.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part209.BrickColor = BrickColor.new("Really black")
Part209.CanCollide = false
Part209.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part209.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part209.Material = Enum.Material.Metal
Part209.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part209.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part209.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part209.brickColor = BrickColor.new("Really black")
SpecialMesh210.Parent = Part209
SpecialMesh210.Scale = Vector3.new(0.5, 0.560000002, 0.5)
SpecialMesh210.MeshType = Enum.MeshType.Wedge
Part211.Parent = Model0
Part211.CFrame = CFrame.new(-0.640777826, 2.97037435, -14.8715458, 0.00156102644, -0.999985635, -0.00512771169, -0.00585717242, -0.00513677299, 0.99996984, -0.999981701, -0.00153094484, -0.00586510729)
Part211.Orientation = Vector3.new(-89.5599976, -138.839996, -131.25)
Part211.Position = Vector3.new(-0.640777826, 2.97037435, -14.8715458)
Part211.Rotation = Vector3.new(-90.3399963, -0.289999992, 89.909996)
Part211.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part211.Velocity = Vector3.new(1.01314356e-07, 0.00246505649, 1.33137894e-06)
Part211.Size = Vector3.new(0.49000001, 0.200000003, 0.290374994)
Part211.Anchored = true
Part211.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part211.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part211.BrickColor = BrickColor.new("Royal purple")
Part211.CanCollide = false
Part211.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part211.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part211.Material = Enum.Material.Neon
Part211.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part211.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part211.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part211.brickColor = BrickColor.new("Royal purple")
SpecialMesh212.Parent = Part211
SpecialMesh212.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh212.MeshType = Enum.MeshType.Wedge
Part213.Parent = Model0
Part213.CFrame = CFrame.new(-0.609622896, 3.39657903, -16.2390652, 0.999985635, -0.00133592181, 0.00519115385, 0.00513700396, -0.0377659053, -0.999273479, 0.00153099932, 0.999285877, -0.0377584994)
Part213.Orientation = Vector3.new(87.8199997, 172.169998, 172.25)
Part213.Position = Vector3.new(-0.609622896, 3.39657903, -16.2390652)
Part213.Rotation = Vector3.new(92.159996, 0.299999982, 0.0799999982)
Part213.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part213.Velocity = Vector3.new(3.37329027e-08, 0.002462212, 4.43286638e-07)
Part213.Size = Vector3.new(0.275000006, 0.533124864, 0.214375019)
Part213.Anchored = true
Part213.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part213.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part213.BrickColor = BrickColor.new("Bright blue")
Part213.CanCollide = false
Part213.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part213.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part213.Material = Enum.Material.Neon
Part213.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part213.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part213.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part213.brickColor = BrickColor.new("Bright blue")
SpecialMesh214.Parent = Part213
SpecialMesh214.Scale = Vector3.new(0.449999988, 0.899999976, 0.100000001)
SpecialMesh214.MeshType = Enum.MeshType.Brick
Part215.Parent = Model0
Part215.CFrame = CFrame.new(-0.612417579, 3.49721146, -14.7513313, 0.999985635, -0.00219574547, 0.00488994364, 0.00513701141, 0.13200599, -0.991235793, 0.00153099908, 0.991246581, 0.132015377)
Part215.Orientation = Vector3.new(82.409996, 2.11999989, 2.23000002)
Part215.Position = Vector3.new(-0.612417579, 3.49721146, -14.7513313)
Part215.Rotation = Vector3.new(82.409996, 0.280000001, 0.129999995)
Part215.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part215.Velocity = Vector3.new(1.77760739e-08, 0.00246531144, 2.33596552e-07)
Part215.Size = Vector3.new(0.275000006, 0.488124937, 0.359375)
Part215.Anchored = true
Part215.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part215.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part215.BrickColor = BrickColor.new("Really black")
Part215.CanCollide = false
Part215.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part215.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part215.Material = Enum.Material.Metal
Part215.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part215.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part215.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part215.brickColor = BrickColor.new("Really black")
SpecialMesh216.Parent = Part215
SpecialMesh216.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh216.MeshType = Enum.MeshType.Brick
Part217.Parent = Model0
Part217.CFrame = CFrame.new(-0.645515323, 3.66365719, -14.1031828, -0.0047622188, -0.999985635, 0.00246008043, 0.720367849, -0.00513686892, -0.693573356, 0.693576038, -0.00153078465, 0.720381975)
Part217.Orientation = Vector3.new(43.9099998, 0.199999988, 90.409996)
Part217.Position = Vector3.new(-0.645515323, 3.66365719, -14.1031828)
Part217.Rotation = Vector3.new(43.9099998, 0.140000001, 90.2699966)
Part217.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part217.Velocity = Vector3.new(-8.61649951e-09, 0.00246665697, -1.13230158e-07)
Part217.Size = Vector3.new(0.496000022, 0.200000003, 0.280375004)
Part217.Anchored = true
Part217.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part217.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part217.BrickColor = BrickColor.new("Royal purple")
Part217.CanCollide = false
Part217.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part217.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part217.Material = Enum.Material.Neon
Part217.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part217.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part217.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part217.brickColor = BrickColor.new("Royal purple")
SpecialMesh218.Parent = Part217
SpecialMesh218.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh218.MeshType = Enum.MeshType.Wedge
Part219.Parent = Model0
Part219.CFrame = CFrame.new(-0.611597419, 2.92886329, -13.380847, -0.999985635, -0.00162816129, -0.00510668149, -0.00513661886, 0.0189460143, 0.999807417, -0.00153109606, 0.999819279, -0.0189541057)
Part219.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part219.Position = Vector3.new(-0.611597419, 2.92886329, -13.380847)
Part219.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part219.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part219.Velocity = Vector3.new(1.07896597e-07, 0.00246816734, 1.41787655e-06)
Part219.Size = Vector3.new(0.275000006, 0.630125046, 0.280375004)
Part219.Anchored = true
Part219.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part219.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part219.BrickColor = BrickColor.new("Really black")
Part219.CanCollide = false
Part219.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part219.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part219.Material = Enum.Material.Metal
Part219.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part219.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part219.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part219.brickColor = BrickColor.new("Really black")
SpecialMesh220.Parent = Part219
SpecialMesh220.Scale = Vector3.new(0.395000011, 0.75, 0.25)
SpecialMesh220.MeshType = Enum.MeshType.Wedge
Part221.Parent = Model0
Part221.CFrame = CFrame.new(-0.609442294, 2.87052941, -14.5920582, -0.999985635, 0.00510674296, -0.00162775011, -0.00513667427, -0.999807417, 0.0189472083, -0.00153067766, 0.0189552978, 0.999819279)
Part221.Orientation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part221.Position = Vector3.new(-0.609442294, 2.87052941, -14.5920582)
Part221.Rotation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part221.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part221.Velocity = Vector3.new(1.17146328e-07, 0.00246564392, 1.53942813e-06)
Part221.Size = Vector3.new(0.275000006, 0.216999978, 0.295375019)
Part221.Anchored = true
Part221.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part221.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part221.BrickColor = BrickColor.new("Really black")
Part221.CanCollide = false
Part221.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part221.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part221.Material = Enum.Material.Glass
Part221.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part221.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part221.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part221.brickColor = BrickColor.new("Really black")
SpecialMesh222.Parent = Part221
SpecialMesh222.Scale = Vector3.new(0.5, 0.75, 0.25)
SpecialMesh222.MeshType = Enum.MeshType.Wedge
Part223.Parent = Model0
Part223.CFrame = CFrame.new(-0.609190822, 2.76472902, -14.4025202, -0.999985635, 0.00510674296, -0.00162775011, -0.00513667427, -0.999807417, 0.0189472083, -0.00153067766, 0.0189552978, 0.999819279)
Part223.Orientation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part223.Position = Vector3.new(-0.609190822, 2.76472902, -14.4025202)
Part223.Rotation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part223.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part223.Velocity = Vector3.new(1.3392264e-07, 0.0024660388, 1.7598868e-06)
Part223.Size = Vector3.new(0.275000006, 0.23299998, 0.295375019)
Part223.Anchored = true
Part223.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part223.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part223.BrickColor = BrickColor.new("Really black")
Part223.CanCollide = false
Part223.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part223.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part223.Material = Enum.Material.Glass
Part223.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part223.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part223.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part223.brickColor = BrickColor.new("Really black")
SpecialMesh224.Parent = Part223
SpecialMesh224.Scale = Vector3.new(0.5, 1, 0.25)
SpecialMesh224.MeshType = Enum.MeshType.Wedge
Part225.Parent = Model0
Part225.CFrame = CFrame.new(-0.610054374, 2.83367729, -14.0694036, 0.999985635, 0.00162807188, -0.00510671316, 0.00513664866, -0.0189460143, 0.999807417, 0.00153100595, -0.999819279, -0.0189541057)
Part225.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part225.Position = Vector3.new(-0.610054374, 2.83367729, -14.0694036)
Part225.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part225.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part225.Velocity = Vector3.new(1.22989817e-07, 0.00246673287, 1.61621767e-06)
Part225.Size = Vector3.new(0.275000006, 0.311124951, 0.267374992)
Part225.Anchored = true
Part225.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part225.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part225.BrickColor = BrickColor.new("Really black")
Part225.CanCollide = false
Part225.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part225.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part225.Material = Enum.Material.Metal
Part225.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part225.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part225.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part225.brickColor = BrickColor.new("Really black")
SpecialMesh226.Parent = Part225
SpecialMesh226.Scale = Vector3.new(0.495000005, 1, 1)
SpecialMesh226.MeshType = Enum.MeshType.Brick
Part227.Parent = Model0
Part227.CFrame = CFrame.new(-0.611247957, 3.01424932, -13.8955402, 0.999985635, -0.00162807154, 0.00510659395, 0.00513652945, 0.0189459547, -0.999807417, 0.00153100828, 0.999819279, 0.0189540461)
Part227.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part227.Position = Vector3.new(-0.611247957, 3.01424932, -13.8955402)
Part227.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part227.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part227.Velocity = Vector3.new(9.43572971e-08, 0.00246709492, 1.23995574e-06)
Part227.Size = Vector3.new(0.275000006, 0.228, 0.213375002)
Part227.Anchored = true
Part227.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part227.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part227.BrickColor = BrickColor.new("Really black")
Part227.CanCollide = false
Part227.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part227.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part227.Material = Enum.Material.Metal
Part227.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part227.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part227.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part227.brickColor = BrickColor.new("Really black")
SpecialMesh228.Parent = Part227
SpecialMesh228.Scale = Vector3.new(0.569999993, 0.125, 0.375)
SpecialMesh228.MeshType = Enum.MeshType.Wedge
Part229.Parent = Model0
Part229.CFrame = CFrame.new(-0.614671409, 3.24594569, -12.4355726, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part229.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part229.Position = Vector3.new(-0.614671409, 3.24594569, -12.4355726)
Part229.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part229.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part229.Velocity = Vector3.new(5.76182231e-08, 0.00247013662, 7.57164685e-07)
Part229.Size = Vector3.new(0.275000006, 0.745124936, 0.280375004)
Part229.Anchored = true
Part229.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part229.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part229.BrickColor = BrickColor.new("Really black")
Part229.CanCollide = false
Part229.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part229.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part229.Material = Enum.Material.Metal
Part229.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part229.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part229.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part229.brickColor = BrickColor.new("Really black")
SpecialMesh230.Parent = Part229
SpecialMesh230.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh230.MeshType = Enum.MeshType.Brick
Part231.Parent = Model0
Part231.CFrame = CFrame.new(-0.610754132, 2.89412951, -13.8151274, -0.999985635, -0.00162807154, -0.00510650687, -0.00513644237, 0.0189459547, 0.999807417, -0.00153100991, 0.999819279, -0.0189540461)
Part231.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part231.Position = Vector3.new(-0.610754132, 2.89412951, -13.8151274)
Part231.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part231.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part231.Velocity = Vector3.new(1.1340417e-07, 0.00246726256, 1.49025209e-06)
Part231.Size = Vector3.new(0.275000006, 0.200000003, 0.303375006)
Part231.Anchored = true
Part231.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part231.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part231.BrickColor = BrickColor.new("Really black")
Part231.CanCollide = false
Part231.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part231.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part231.Material = Enum.Material.Glass
Part231.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part231.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part231.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part231.brickColor = BrickColor.new("Really black")
SpecialMesh232.Parent = Part231
SpecialMesh232.Scale = Vector3.new(0.524999976, 0.5, 0.5)
SpecialMesh232.MeshType = Enum.MeshType.Wedge
Part233.Parent = Model0
Part233.CFrame = CFrame.new(-0.614374042, 3.38457584, -13.09618, 0.999985635, -0.00162795233, 0.00510671316, 0.00513664633, 0.0189459547, -0.999807417, 0.00153088674, 0.999819279, 0.0189540461)
Part233.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part233.Position = Vector3.new(-0.614374042, 3.38457584, -13.09618)
Part233.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part233.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part233.Velocity = Vector3.new(3.56362335e-08, 0.00246876013, 4.68297941e-07)
Part233.Size = Vector3.new(0.275000006, 0.322125077, 0.363375008)
Part233.Anchored = true
Part233.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part233.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part233.BrickColor = BrickColor.new("Really black")
Part233.CanCollide = false
Part233.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part233.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part233.Material = Enum.Material.Metal
Part233.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part233.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part233.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part233.brickColor = BrickColor.new("Really black")
SpecialMesh234.Parent = Part233
SpecialMesh234.Scale = Vector3.new(0.5, 1, 1)
SpecialMesh234.MeshType = Enum.MeshType.Wedge
Part235.Parent = Model0
Part235.CFrame = CFrame.new(-0.612951875, 3.3556869, -13.9274721, 0.999985635, 0.00162774313, -0.00510693667, 0.00513686566, -0.0189458374, 0.999807417, 0.00153067405, -0.999819279, -0.0189539269)
Part235.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part235.Position = Vector3.new(-0.612951875, 3.3556869, -13.9274721)
Part235.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part235.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part235.Velocity = Vector3.new(4.02170173e-08, 0.0024670281, 5.28494468e-07)
Part235.Size = Vector3.new(0.275000006, 0.54112494, 0.367374986)
Part235.Anchored = true
Part235.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part235.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part235.BrickColor = BrickColor.new("Really black")
Part235.CanCollide = false
Part235.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part235.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part235.Material = Enum.Material.Metal
Part235.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part235.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part235.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part235.brickColor = BrickColor.new("Really black")
SpecialMesh236.Parent = Part235
SpecialMesh236.Scale = Vector3.new(0.5, 1.04999995, 0.600000024)
SpecialMesh236.MeshType = Enum.MeshType.Brick
Part237.Parent = Model0
Part237.CFrame = CFrame.new(-0.611452341, 3.03449631, -13.8299093, 0.999985635, 0.00162795268, -0.00510686403, 0.0051367972, -0.0189460143, 0.999807417, 0.00153088395, -0.999819279, -0.0189541057)
Part237.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part237.Position = Vector3.new(-0.611452341, 3.03449631, -13.8299093)
Part237.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part237.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part237.Velocity = Vector3.new(9.11468163e-08, 0.00246723159, 1.19776655e-06)
Part237.Size = Vector3.new(0.275000006, 0.207000002, 0.303375006)
Part237.Anchored = true
Part237.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part237.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part237.BrickColor = BrickColor.new("Really black")
Part237.CanCollide = false
Part237.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part237.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part237.Material = Enum.Material.Metal
Part237.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part237.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part237.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part237.brickColor = BrickColor.new("Really black")
SpecialMesh238.Parent = Part237
SpecialMesh238.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh238.MeshType = Enum.MeshType.Wedge
Part239.Parent = Model0
Part239.CFrame = CFrame.new(-0.608695984, 3.30580091, -16.5400867, 0.999985635, -0.00133592135, 0.00519114826, 0.0051369979, -0.0377659909, -0.999273479, 0.00153099943, 0.999285758, -0.0377585851)
Part239.Orientation = Vector3.new(87.8199997, 172.169998, 172.25)
Part239.Position = Vector3.new(-0.608695984, 3.30580091, -16.5400867)
Part239.Rotation = Vector3.new(92.159996, 0.299999982, 0.0799999982)
Part239.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part239.Velocity = Vector3.new(4.81271911e-08, 0.00246158475, 6.32443061e-07)
Part239.Size = Vector3.new(0.275000006, 1.65712488, 0.422374964)
Part239.Anchored = true
Part239.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part239.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part239.BrickColor = BrickColor.new("Really black")
Part239.CanCollide = false
Part239.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part239.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part239.Material = Enum.Material.Metal
Part239.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part239.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part239.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part239.brickColor = BrickColor.new("Really black")
SpecialMesh240.Parent = Part239
SpecialMesh240.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh240.MeshType = Enum.MeshType.Brick
Part241.Parent = Model0
Part241.CFrame = CFrame.new(-0.607766628, 3.58790874, -18.0936966, 0.999985635, -0.0010395617, 0.00525854016, 0.00513699278, -0.0943568796, -0.99552542, 0.00153108896, 0.995537996, -0.094350189)
Part241.Orientation = Vector3.new(84.5800018, 176.809998, 176.87999)
Part241.Position = Vector3.new(-0.607766628, 3.58790874, -18.0936966)
Part241.Rotation = Vector3.new(95.409996, 0.299999982, 0.0599999987)
Part241.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part241.Velocity = Vector3.new(3.39455752e-09, 0.00245834771, 4.46085551e-08)
Part241.Size = Vector3.new(0.275000006, 1.66212487, 0.359375)
Part241.Anchored = true
Part241.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part241.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part241.BrickColor = BrickColor.new("Really black")
Part241.CanCollide = false
Part241.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part241.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part241.Material = Enum.Material.Metal
Part241.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part241.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part241.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part241.brickColor = BrickColor.new("Really black")
SpecialMesh242.Parent = Part241
SpecialMesh242.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh242.MeshType = Enum.MeshType.Brick
Part243.Parent = Model0
Part243.CFrame = CFrame.new(-0.618630528, 3.29811025, -11.1170893, -0.999985635, -0.00162795233, -0.0051068007, -0.00513673387, 0.0189459547, 0.999807417, -0.00153088511, 0.999819279, -0.0189540461)
Part243.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part243.Position = Vector3.new(-0.618630528, 3.29811025, -11.1170893)
Part243.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part243.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part243.Velocity = Vector3.new(4.93467311e-08, 0.00247288332, 6.48468244e-07)
Part243.Size = Vector3.new(0.25999999, 0.3125, 0.320125014)
Part243.Anchored = true
Part243.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part243.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part243.BrickColor = BrickColor.new("Really black")
Part243.CanCollide = false
Part243.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part243.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part243.Material = Enum.Material.Metal
Part243.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part243.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part243.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part243.brickColor = BrickColor.new("Really black")
SpecialMesh244.Parent = Part243
SpecialMesh244.Scale = Vector3.new(0.5, 1, 1)
SpecialMesh244.MeshType = Enum.MeshType.Wedge
Part245.Parent = Model0
Part245.CFrame = CFrame.new(-0.639055848, 2.33898354, -13.8797112, 0.0028942409, -0.999985635, -0.00451144017, -0.277069569, -0.00513673481, 0.960836232, -0.960845649, -0.00153090828, -0.277080446)
Part245.Orientation = Vector3.new(-73.909996, -179.069992, -91.0599976)
Part245.Position = Vector3.new(-0.639055848, 2.33898354, -13.8797112)
Part245.Rotation = Vector3.new(-106.089996, -0.25999999, 89.8299942)
Part245.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part245.Velocity = Vector3.new(2.01431277e-07, 0.00246712356, 2.64702226e-06)
Part245.Size = Vector3.new(0.453000009, 0.200000003, 0.280375004)
Part245.Anchored = true
Part245.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part245.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part245.BrickColor = BrickColor.new("Royal purple")
Part245.CanCollide = false
Part245.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part245.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part245.Material = Enum.Material.Neon
Part245.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part245.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part245.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part245.brickColor = BrickColor.new("Royal purple")
SpecialMesh246.Parent = Part245
SpecialMesh246.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh246.MeshType = Enum.MeshType.Wedge
Part247.Parent = Model0
Part247.CFrame = CFrame.new(-0.611137211, 3.24560308, -14.7434616, 0.999985635, -0.00162807363, 0.00510707032, 0.00513700629, 0.018946372, -0.999807417, 0.0015309992, 0.999819279, 0.0189544633)
Part247.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part247.Position = Vector3.new(-0.611137211, 3.24560308, -14.7434616)
Part247.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part247.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part247.Velocity = Vector3.new(5.76725228e-08, 0.0024653282, 7.57878638e-07)
Part247.Size = Vector3.new(0.275000006, 0.488124937, 0.418375015)
Part247.Anchored = true
Part247.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part247.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part247.BrickColor = BrickColor.new("Really black")
Part247.CanCollide = false
Part247.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part247.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part247.Material = Enum.Material.Metal
Part247.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part247.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part247.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part247.brickColor = BrickColor.new("Really black")
SpecialMesh248.Parent = Part247
SpecialMesh248.Scale = Vector3.new(0.400000006, 1, 0.899999976)
SpecialMesh248.MeshType = Enum.MeshType.Brick
Part249.Parent = Model0
Part249.CFrame = CFrame.new(-0.646988273, 3.68078995, -13.1990242, 0.00245985761, -0.999985635, 0.00476197852, -0.693573356, -0.00513654156, -0.720367849, 0.720381916, -0.00153077836, -0.693576097)
Part249.Orientation = Vector3.new(46.079998, 179.610001, -90.4199982)
Part249.Position = Vector3.new(-0.646988273, 3.68078995, -13.1990242)
Part249.Rotation = Vector3.new(133.910004, 0.269999981, 89.8600006)
Part249.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part249.Velocity = Vector3.new(-1.13331566e-08, 0.00246854057, -1.48930098e-07)
Part249.Size = Vector3.new(0.496000022, 0.200000003, 0.280375004)
Part249.Anchored = true
Part249.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part249.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part249.BrickColor = BrickColor.new("Royal purple")
Part249.CanCollide = false
Part249.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part249.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part249.Material = Enum.Material.Neon
Part249.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part249.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part249.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part249.brickColor = BrickColor.new("Royal purple")
SpecialMesh250.Parent = Part249
SpecialMesh250.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh250.MeshType = Enum.MeshType.Wedge
Part251.Parent = Model0
Part251.CFrame = CFrame.new(-0.616084397, 3.20240736, -11.3666525, -0.999985635, -0.000716604234, -0.00531162601, -0.00513642887, -0.154956639, 0.987908065, -0.00153101014, 0.987921119, 0.154950723)
Part251.Orientation = Vector3.new(-81.0800018, -1.95999992, -178.099991)
Part251.Position = Vector3.new(-0.616084397, 3.20240736, -11.3666525)
Part251.Rotation = Vector3.new(-81.0899963, -0.299999982, 179.959991)
Part251.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part251.Velocity = Vector3.new(6.45219203e-08, 0.00247236365, 8.47886554e-07)
Part251.Size = Vector3.new(0.275000006, 0.203125, 0.234375)
Part251.Anchored = true
Part251.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part251.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part251.BrickColor = BrickColor.new("Really black")
Part251.CanCollide = false
Part251.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part251.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part251.Material = Enum.Material.Metal
Part251.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part251.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part251.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part251.brickColor = BrickColor.new("Really black")
SpecialMesh252.Parent = Part251
SpecialMesh252.Scale = Vector3.new(0.5, 1.04999995, 0.400000006)
SpecialMesh252.MeshType = Enum.MeshType.Brick
Part253.Parent = Model0
Part253.CFrame = CFrame.new(-0.616027236, 3.22281599, -11.4724684, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part253.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part253.Position = Vector3.new(-0.616027236, 3.22281599, -11.4724684)
Part253.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part253.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part253.Velocity = Vector3.new(6.12858102e-08, 0.00247214315, 8.05360628e-07)
Part253.Size = Vector3.new(0.275000006, 0.415125012, 0.234375)
Part253.Anchored = true
Part253.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part253.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part253.BrickColor = BrickColor.new("Really black")
Part253.CanCollide = false
Part253.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part253.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part253.Material = Enum.Material.Metal
Part253.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part253.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part253.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part253.brickColor = BrickColor.new("Really black")
SpecialMesh254.Parent = Part253
SpecialMesh254.Scale = Vector3.new(0.5, 1.04999995, 0.400000006)
SpecialMesh254.MeshType = Enum.MeshType.Brick
Part255.Parent = Model0
Part255.CFrame = CFrame.new(-0.610752404, 3.28331137, -15.1213608, 0.999985635, -0.00347625092, 0.00408016983, 0.00513697462, 0.404109061, -0.914696634, 0.00153088057, 0.914704442, 0.404121131)
Part255.Orientation = Vector3.new(66.159996, 0.579999983, 0.729999959)
Part255.Position = Vector3.new(-0.610752404, 3.28331137, -15.1213608)
Part255.Rotation = Vector3.new(66.159996, 0.229999989, 0.199999988)
Part255.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part255.Velocity = Vector3.new(5.16932808e-08, 0.00246454077, 6.79305003e-07)
Part255.Size = Vector3.new(0.275000006, 0.330124885, 0.214375019)
Part255.Anchored = true
Part255.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part255.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part255.BrickColor = BrickColor.new("Bright blue")
Part255.CanCollide = false
Part255.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part255.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part255.Material = Enum.Material.Neon
Part255.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part255.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part255.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part255.brickColor = BrickColor.new("Bright blue")
SpecialMesh256.Parent = Part255
SpecialMesh256.Scale = Vector3.new(0.449999988, 1, 0.100000001)
SpecialMesh256.MeshType = Enum.MeshType.Brick
Part257.Parent = Model0
Part257.CFrame = CFrame.new(-0.63657546, 3.38894939, -19.0216789, -0.00237622252, -0.999985635, -0.00480452133, 0.680895686, -0.00513668498, 0.732362568, -0.732376754, -0.00153112097, 0.68089813)
Part257.Orientation = Vector3.new(-47.079998, -0.399999976, 90.4300003)
Part257.Position = Vector3.new(-0.63657546, 3.38894939, -19.0216789)
Part257.Rotation = Vector3.new(-47.0900002, -0.280000001, 90.1399994)
Part257.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part257.Velocity = Vector3.new(3.49426692e-08, 0.00245640939, 4.59184662e-07)
Part257.Size = Vector3.new(0.940000057, 0.200000003, 0.285374999)
Part257.Anchored = true
Part257.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part257.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part257.BrickColor = BrickColor.new("Royal purple")
Part257.CanCollide = false
Part257.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part257.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part257.Material = Enum.Material.Neon
Part257.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part257.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part257.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part257.brickColor = BrickColor.new("Royal purple")
SpecialMesh258.Parent = Part257
SpecialMesh258.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh258.MeshType = Enum.MeshType.Wedge
Part259.Parent = Model0
Part259.CFrame = CFrame.new(-0.584489346, 3.6811111, -13.1989288, -0.00245976867, 0.999985635, 0.00476201251, 0.693573415, 0.00513650384, -0.720367789, -0.720381916, 0.00153086672, -0.693576038)
Part259.Orientation = Vector3.new(46.079998, 179.610001, 89.5799942)
Part259.Position = Vector3.new(-0.584489346, 3.6811111, -13.1989288)
Part259.Rotation = Vector3.new(133.910004, 0.269999981, -90.1399994)
Part259.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part259.Velocity = Vector3.new(-1.13840777e-08, 0.00246855081, -1.49599259e-07)
Part259.Size = Vector3.new(0.496000022, 0.200000003, 0.280375004)
Part259.Anchored = true
Part259.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part259.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part259.BrickColor = BrickColor.new("Royal purple")
Part259.CanCollide = false
Part259.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part259.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part259.Material = Enum.Material.Neon
Part259.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part259.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part259.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part259.brickColor = BrickColor.new("Royal purple")
SpecialMesh260.Parent = Part259
SpecialMesh260.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh260.MeshType = Enum.MeshType.Wedge
Part261.Parent = Model0
Part261.CFrame = CFrame.new(-0.574076533, 3.38927007, -19.0215836, 0.00237613311, 0.999985635, -0.00480454601, -0.680895686, 0.00513664167, 0.732362568, 0.732376754, 0.00153120293, 0.68089813)
Part261.Orientation = Vector3.new(-47.079998, -0.399999976, -89.5699997)
Part261.Position = Vector3.new(-0.574076533, 3.38927007, -19.0215836)
Part261.Rotation = Vector3.new(-47.0900002, -0.280000001, -89.8600006)
Part261.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part261.Velocity = Vector3.new(3.48918228e-08, 0.00245641964, 4.58516467e-07)
Part261.Size = Vector3.new(0.940000057, 0.200000003, 0.285374999)
Part261.Anchored = true
Part261.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part261.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part261.BrickColor = BrickColor.new("Royal purple")
Part261.CanCollide = false
Part261.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part261.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part261.Material = Enum.Material.Neon
Part261.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part261.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part261.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part261.brickColor = BrickColor.new("Royal purple")
SpecialMesh262.Parent = Part261
SpecialMesh262.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh262.MeshType = Enum.MeshType.Wedge
Part263.Parent = Model0
Part263.CFrame = CFrame.new(-0.640052557, 2.92977762, -15.2103024, 0.00336818164, -0.999985635, -0.00416955911, -0.380026042, -0.00513675297, 0.924961627, -0.924969733, -0.00153089722, -0.380037904)
Part263.Orientation = Vector3.new(-67.659996, -179.369995, -90.7699966)
Part263.Position = Vector3.new(-0.640052557, 2.92977762, -15.2103024)
Part263.Rotation = Vector3.new(-112.339996, -0.239999995, 89.8099976)
Part263.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part263.Velocity = Vector3.new(1.07751589e-07, 0.00246435078, 1.41597127e-06)
Part263.Size = Vector3.new(0.288000047, 0.200000003, 0.27837503)
Part263.Anchored = true
Part263.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part263.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part263.BrickColor = BrickColor.new("Royal purple")
Part263.CanCollide = false
Part263.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part263.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part263.Material = Enum.Material.Neon
Part263.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part263.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part263.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part263.brickColor = BrickColor.new("Royal purple")
SpecialMesh264.Parent = Part263
SpecialMesh264.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh264.MeshType = Enum.MeshType.Wedge
Part265.Parent = Model0
Part265.CFrame = CFrame.new(-0.611472309, 3.03472614, -13.8177929, 0.999985635, -0.00162807154, 0.00510659395, 0.00513652945, 0.0189459547, -0.999807417, 0.00153100828, 0.999819279, 0.0189540461)
Part265.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part265.Position = Vector3.new(-0.611472309, 3.03472614, -13.8177929)
Part265.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part265.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part265.Velocity = Vector3.new(9.11103797e-08, 0.00246725697, 1.1972877e-06)
Part265.Size = Vector3.new(0.275000006, 0.200000003, 0.303375006)
Part265.Anchored = true
Part265.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part265.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part265.BrickColor = BrickColor.new("Really black")
Part265.CanCollide = false
Part265.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part265.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part265.Material = Enum.Material.Glass
Part265.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part265.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part265.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part265.brickColor = BrickColor.new("Really black")
SpecialMesh266.Parent = Part265
SpecialMesh266.Scale = Vector3.new(0.524999976, 0.5, 0.5)
SpecialMesh266.MeshType = Enum.MeshType.Wedge
Part267.Parent = Model0
Part267.CFrame = CFrame.new(-0.608101904, 3.29321218, -16.8867702, 0.999985635, -0.00103956275, 0.00525853597, 0.00513698952, -0.0943567529, -0.99552536, 0.00153108896, 0.995537996, -0.0943500549)
Part267.Orientation = Vector3.new(84.5800018, 176.809998, 176.87999)
Part267.Position = Vector3.new(-0.608101904, 3.29321218, -16.8867702)
Part267.Rotation = Vector3.new(95.409996, 0.299999982, 0.0599999987)
Part267.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part267.Velocity = Vector3.new(5.0123333e-08, 0.00246086251, 6.5867448e-07)
Part267.Size = Vector3.new(0.275000006, 0.454124868, 0.214375019)
Part267.Anchored = true
Part267.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part267.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part267.BrickColor = BrickColor.new("Bright blue")
Part267.CanCollide = false
Part267.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part267.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part267.Material = Enum.Material.Neon
Part267.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part267.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part267.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part267.brickColor = BrickColor.new("Bright blue")
SpecialMesh268.Parent = Part267
SpecialMesh268.Scale = Vector3.new(0.449999988, 0.899999976, 0.100000001)
SpecialMesh268.MeshType = Enum.MeshType.Brick
Part269.Parent = Model0
Part269.CFrame = CFrame.new(-0.609975338, 2.71316695, -13.7165575, -0.999985635, -0.00476232171, -0.00245974911, -0.00513671385, 0.720367908, 0.693573296, -0.0015310942, 0.693576038, -0.720381975)
Part269.Orientation = Vector3.new(-43.9099998, -179.800003, -0.409999996)
Part269.Position = Vector3.new(-0.609975338, 2.71316695, -13.7165575)
Part269.Rotation = Vector3.new(-136.089996, -0.140000001, 179.729996)
Part269.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part269.Velocity = Vector3.new(1.42098628e-07, 0.00246746815, 1.8673278e-06)
Part269.Size = Vector3.new(0.275000006, 0.403124899, 0.352375001)
Part269.Anchored = true
Part269.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part269.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part269.BrickColor = BrickColor.new("Really black")
Part269.CanCollide = false
Part269.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part269.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part269.Material = Enum.Material.Metal
Part269.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part269.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part269.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part269.brickColor = BrickColor.new("Really black")
SpecialMesh270.Parent = Part269
SpecialMesh270.Scale = Vector3.new(0.349999994, 1, 1)
SpecialMesh270.MeshType = Enum.MeshType.Brick
Part271.Parent = Model0
Part271.CFrame = CFrame.new(-0.583012402, 3.6639781, -14.1030874, 0.00476215919, 0.999985635, 0.00246015075, -0.720367849, 0.0051368745, -0.693573356, -0.693576038, 0.00153069268, 0.720381975)
Part271.Orientation = Vector3.new(43.9099998, 0.199999988, -89.5899963)
Part271.Position = Vector3.new(-0.583012402, 3.6639781, -14.1030874)
Part271.Rotation = Vector3.new(43.9099998, 0.140000001, -89.7299957)
Part271.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part271.Velocity = Vector3.new(-8.66738503e-09, 0.00246666698, -1.13898864e-07)
Part271.Size = Vector3.new(0.496000022, 0.200000003, 0.280375004)
Part271.Anchored = true
Part271.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part271.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part271.BrickColor = BrickColor.new("Royal purple")
Part271.CanCollide = false
Part271.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part271.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part271.Material = Enum.Material.Neon
Part271.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part271.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part271.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part271.brickColor = BrickColor.new("Royal purple")
SpecialMesh272.Parent = Part271
SpecialMesh272.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh272.MeshType = Enum.MeshType.Wedge
Part273.Parent = Model0
Part273.CFrame = CFrame.new(-0.573997319, 3.0173018, -17.825201, -0.00108546892, 0.999985635, -0.00524905883, -0.0856661052, 0.00513677904, 0.99631083, 0.996323526, 0.00153113017, 0.0856593028)
Part273.Orientation = Vector3.new(-85.0800018, -3.50999999, -86.5699997)
Part273.Position = Vector3.new(-0.573997319, 3.0173018, -17.825201)
Part273.Rotation = Vector3.new(-85.0899963, -0.299999982, -90.0599976)
Part273.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part273.Velocity = Vector3.new(9.38732327e-08, 0.00245891255, 1.23359519e-06)
Part273.Size = Vector3.new(1.78499997, 0.200000003, 0.301375002)
Part273.Anchored = true
Part273.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part273.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part273.BrickColor = BrickColor.new("Royal purple")
Part273.CanCollide = false
Part273.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part273.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part273.Material = Enum.Material.Neon
Part273.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part273.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part273.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part273.brickColor = BrickColor.new("Royal purple")
SpecialMesh274.Parent = Part273
SpecialMesh274.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh274.MeshType = Enum.MeshType.Wedge
Part275.Parent = Model0
Part275.CFrame = CFrame.new(-0.614639282, 3.4985106, -13.3051252, -0.999985635, 0.00162801275, 0.00510680024, -0.00513673527, -0.0189461038, -0.999807417, -0.00153094472, -0.999819279, 0.0189541951)
Part275.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part275.Position = Vector3.new(-0.614639282, 3.4985106, -13.3051252)
Part275.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part275.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part275.Velocity = Vector3.new(1.75700912e-08, 0.00246832473, 2.30889498e-07)
Part275.Size = Vector3.new(0.275000006, 0.204125047, 0.207375005)
Part275.Anchored = true
Part275.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part275.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part275.BrickColor = BrickColor.new("Really black")
Part275.CanCollide = false
Part275.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part275.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part275.Material = Enum.Material.Metal
Part275.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part275.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part275.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part275.brickColor = BrickColor.new("Really black")
SpecialMesh276.Parent = Part275
SpecialMesh276.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh276.MeshType = Enum.MeshType.Wedge
Part277.Parent = Model0
Part277.CFrame = CFrame.new(-0.609530032, 2.79620743, -14.2853489, 0.999985635, 0.00162795268, -0.00510686403, 0.0051367972, -0.0189460143, 0.999807417, 0.00153088395, -0.999819279, -0.0189541057)
Part277.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part277.Position = Vector3.new(-0.609530032, 2.79620743, -14.2853489)
Part277.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part277.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part277.Velocity = Vector3.new(1.28931248e-07, 0.00246628304, 1.6942945e-06)
Part277.Size = Vector3.new(0.275000006, 0.223999977, 0.375375003)
Part277.Anchored = true
Part277.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part277.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part277.BrickColor = BrickColor.new("Really black")
Part277.CanCollide = false
Part277.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part277.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part277.Material = Enum.Material.Glass
Part277.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part277.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part277.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part277.brickColor = BrickColor.new("Really black")
SpecialMesh278.Parent = Part277
SpecialMesh278.Scale = Vector3.new(0.5, 0.699999988, 0.5)
SpecialMesh278.MeshType = Enum.MeshType.Brick
Part279.Parent = Model0
Part279.CFrame = CFrame.new(-0.578278601, 2.9706955, -14.8714504, -0.00156111596, 0.999985635, -0.00512771122, 0.00585717056, 0.00513677299, 0.99996984, 0.999981761, 0.00153103413, -0.00586510636)
Part279.Orientation = Vector3.new(-89.5599976, -138.839996, 48.75)
Part279.Position = Vector3.new(-0.578278601, 2.9706955, -14.8714504)
Part279.Rotation = Vector3.new(-90.3399963, -0.289999992, -90.0899963)
Part279.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part279.Velocity = Vector3.new(1.01263424e-07, 0.00246506673, 1.33070978e-06)
Part279.Size = Vector3.new(0.49000001, 0.200000003, 0.290374994)
Part279.Anchored = true
Part279.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part279.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part279.BrickColor = BrickColor.new("Royal purple")
Part279.CanCollide = false
Part279.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part279.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part279.Material = Enum.Material.Neon
Part279.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part279.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part279.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part279.brickColor = BrickColor.new("Royal purple")
SpecialMesh280.Parent = Part279
SpecialMesh280.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh280.MeshType = Enum.MeshType.Wedge
Part281.Parent = Model0
Part281.CFrame = CFrame.new(-0.613238811, 3.32843637, -13.6493177, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part281.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part281.Position = Vector3.new(-0.613238811, 3.32843637, -13.6493177)
Part281.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part281.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part281.Velocity = Vector3.new(4.45380195e-08, 0.00246760761, 5.85277007e-07)
Part281.Size = Vector3.new(0.275000006, 0.698124886, 0.732374966)
Part281.Anchored = true
Part281.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part281.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part281.BrickColor = BrickColor.new("Really black")
Part281.CanCollide = false
Part281.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part281.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part281.Material = Enum.Material.Metal
Part281.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part281.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part281.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part281.brickColor = BrickColor.new("Really black")
SpecialMesh282.Parent = Part281
SpecialMesh282.Scale = Vector3.new(0.425000012, 1, 1)
SpecialMesh282.MeshType = Enum.MeshType.Cylinder
Part283.Parent = Model0
Part283.CFrame = CFrame.new(-0.614591718, 3.4972918, -13.3320847, -0.999985635, 0.00245974353, -0.0047620195, -0.00513649127, -0.693573475, 0.72036773, -0.00153088977, 0.720381856, 0.693576157)
Part283.Orientation = Vector3.new(-46.079998, -0.389999986, -179.580002)
Part283.Position = Vector3.new(-0.614591718, 3.4972918, -13.3320847)
Part283.Rotation = Vector3.new(-46.0900002, -0.269999981, -179.860001)
Part283.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part283.Velocity = Vector3.new(1.77633499e-08, 0.00246826862, 2.33429148e-07)
Part283.Size = Vector3.new(0.275000006, 0.413124949, 0.622375011)
Part283.Anchored = true
Part283.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part283.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part283.BrickColor = BrickColor.new("Really black")
Part283.CanCollide = false
Part283.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part283.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part283.Material = Enum.Material.Metal
Part283.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part283.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part283.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part283.brickColor = BrickColor.new("Really black")
SpecialMesh284.Parent = Part283
SpecialMesh284.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh284.MeshType = Enum.MeshType.Brick
Part285.Parent = Model0
Part285.CFrame = CFrame.new(-0.615438342, 3.25487208, -11.9645395, -0.999985635, 0.00162786292, 0.00510683237, -0.00513676414, -0.0189459566, -0.999807417, -0.00153079513, -0.999819279, 0.0189540461)
Part285.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part285.Position = Vector3.new(-0.615438342, 3.25487208, -11.9645395)
Part285.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part285.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part285.Velocity = Vector3.new(5.62028113e-08, 0.002471118, 7.38564609e-07)
Part285.Size = Vector3.new(0.275000006, 0.206125051, 0.280375004)
Part285.Anchored = true
Part285.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part285.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part285.BrickColor = BrickColor.new("Really black")
Part285.CanCollide = false
Part285.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part285.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part285.Material = Enum.Material.Metal
Part285.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part285.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part285.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part285.brickColor = BrickColor.new("Really black")
SpecialMesh286.Parent = Part285
SpecialMesh286.Scale = Vector3.new(0.400000006, 0.560000002, 0.5)
SpecialMesh286.MeshType = Enum.MeshType.Wedge
Part287.Parent = Model0
Part287.CFrame = CFrame.new(-0.613306701, 3.18584442, -13.1265478, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part287.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part287.Position = Vector3.new(-0.613306701, 3.18584442, -13.1265478)
Part287.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part287.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part287.Velocity = Vector3.new(6.71482141e-08, 0.00246869703, 8.82399092e-07)
Part287.Size = Vector3.new(0.275000006, 0.567124963, 0.311374992)
Part287.Anchored = true
Part287.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part287.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part287.BrickColor = BrickColor.new("Really black")
Part287.CanCollide = false
Part287.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part287.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part287.Material = Enum.Material.Metal
Part287.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part287.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part287.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part287.brickColor = BrickColor.new("Really black")
SpecialMesh288.Parent = Part287
SpecialMesh288.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh288.MeshType = Enum.MeshType.Brick
Part289.Parent = Model0
Part289.CFrame = CFrame.new(-0.646988273, 3.68078995, -13.1990242, 0.00245985761, -0.999985635, 0.00476197852, -0.693573356, -0.00513654156, -0.720367849, 0.720381916, -0.00153077836, -0.693576097)
Part289.Orientation = Vector3.new(46.079998, 179.610001, -90.4199982)
Part289.Position = Vector3.new(-0.646988273, 3.68078995, -13.1990242)
Part289.Rotation = Vector3.new(133.910004, 0.269999981, 89.8600006)
Part289.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part289.Velocity = Vector3.new(-1.13331566e-08, 0.00246854057, -1.48930098e-07)
Part289.Size = Vector3.new(0.496000022, 0.200000003, 0.280375004)
Part289.Anchored = true
Part289.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part289.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part289.BrickColor = BrickColor.new("Royal purple")
Part289.CanCollide = false
Part289.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part289.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part289.Material = Enum.Material.Neon
Part289.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part289.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part289.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part289.brickColor = BrickColor.new("Royal purple")
SpecialMesh290.Parent = Part289
SpecialMesh290.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh290.MeshType = Enum.MeshType.Wedge
Part291.Parent = Model0
Part291.CFrame = CFrame.new(-0.611590862, 3.29178786, -14.6020966, 0.999985635, -0.00510681886, -0.00162807701, 0.00513675623, 0.999807417, 0.0189470276, 0.00153100397, -0.018955119, 0.999819279)
Part291.Orientation = Vector3.new(-1.09000003, -0.0899999961, 0.289999992)
Part291.Position = Vector3.new(-0.611590862, 3.29178786, -14.6020966)
Part291.Rotation = Vector3.new(-1.09000003, -0.0899999961, 0.289999992)
Part291.Color = Color3.new(0.972549, 0.972549, 0.972549)
Part291.Velocity = Vector3.new(5.03492039e-08, 0.00246562273, 6.61642332e-07)
Part291.Size = Vector3.new(0.275000006, 0.200124964, 0.287375033)
Part291.Anchored = true
Part291.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part291.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part291.BrickColor = BrickColor.new("Institutional white")
Part291.CanCollide = false
Part291.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part291.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part291.Material = Enum.Material.Metal
Part291.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part291.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part291.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part291.brickColor = BrickColor.new("Institutional white")
SpecialMesh292.Parent = Part291
SpecialMesh292.Scale = Vector3.new(0.560000002, 1, 0.899999976)
SpecialMesh292.MeshType = Enum.MeshType.Wedge
Part293.Parent = Model0
Part293.CFrame = CFrame.new(-0.636496425, 3.01698065, -17.8252964, 0.00108537939, -0.999985635, -0.00524905883, 0.0856661052, -0.00513678649, 0.99631083, -0.996323466, -0.00153104111, 0.0856593102)
Part293.Orientation = Vector3.new(-85.0800018, -3.50999999, 93.4300003)
Part293.Position = Vector3.new(-0.636496425, 3.01698065, -17.8252964)
Part293.Rotation = Vector3.new(-85.0899963, -0.299999982, 89.9399948)
Part293.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part293.Velocity = Vector3.new(9.39241573e-08, 0.00245890254, 1.23426435e-06)
Part293.Size = Vector3.new(1.78499997, 0.200000003, 0.301375002)
Part293.Anchored = true
Part293.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part293.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part293.BrickColor = BrickColor.new("Royal purple")
Part293.CanCollide = false
Part293.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part293.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part293.Material = Enum.Material.Neon
Part293.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part293.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part293.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part293.brickColor = BrickColor.new("Royal purple")
SpecialMesh294.Parent = Part293
SpecialMesh294.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh294.MeshType = Enum.MeshType.Wedge
Part295.Parent = Model0
Part295.CFrame = CFrame.new(-0.611132324, 3.1960454, -14.5803022, 0.999985635, 0.00162786234, -0.00510698371, 0.00513691502, -0.0189458374, 0.999807417, 0.00153079221, -0.999819279, -0.0189539269)
Part295.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part295.Position = Vector3.new(-0.611132324, 3.1960454, -14.5803022)
Part295.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part295.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part295.Velocity = Vector3.new(6.55306707e-08, 0.00246566813, 8.61143121e-07)
Part295.Size = Vector3.new(0.275000006, 0.277124941, 0.702375054)
Part295.Anchored = true
Part295.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part295.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part295.BrickColor = BrickColor.new("Really black")
Part295.CanCollide = false
Part295.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part295.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part295.Material = Enum.Material.Glass
Part295.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part295.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part295.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part295.brickColor = BrickColor.new("Really black")
SpecialMesh296.Parent = Part295
SpecialMesh296.Scale = Vector3.new(0.550000012, 0.5, 0.800000012)
SpecialMesh296.MeshType = Enum.MeshType.Brick
Part297.Parent = Model0
Part297.CFrame = CFrame.new(-0.610346913, 2.907269, -14.1244287, 0.999985635, 0.00162795268, -0.00510686403, 0.0051367972, -0.0189460143, 0.999807417, 0.00153088395, -0.999819279, -0.0189541057)
Part297.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part297.Position = Vector3.new(-0.610346913, 2.907269, -14.1244287)
Part297.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part297.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part297.Velocity = Vector3.new(1.11320702e-07, 0.00246661808, 1.462873e-06)
Part297.Size = Vector3.new(0.275000006, 0.207000002, 0.213375002)
Part297.Anchored = true
Part297.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part297.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part297.BrickColor = BrickColor.new("Bright blue")
Part297.CanCollide = false
Part297.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part297.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part297.Material = Enum.Material.Neon
Part297.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part297.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part297.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part297.brickColor = BrickColor.new("Bright blue")
SpecialMesh298.Parent = Part297
SpecialMesh298.Scale = Vector3.new(0.550000012, 0.25, 0.5)
SpecialMesh298.MeshType = Enum.MeshType.Wedge
Part299.Parent = Model0
Part299.CFrame = CFrame.new(-0.617512941, 3.42300797, -11.1735916, 0.999985635, -0.00206693518, 0.00494515104, 0.00513641397, 0.106012821, -0.994351625, 0.00153101049, 0.994362772, 0.106021926)
Part299.Orientation = Vector3.new(83.909996, 2.66999984, 2.76999998)
Part299.Position = Vector3.new(-0.617512941, 3.42300797, -11.1735916)
Part299.Rotation = Vector3.new(83.909996, 0.280000001, 0.119999997)
Part299.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part299.Velocity = Vector3.new(2.95422424e-08, 0.00247276574, 3.88216051e-07)
Part299.Size = Vector3.new(0.275000006, 0.223124996, 0.234375)
Part299.Anchored = true
Part299.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part299.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part299.BrickColor = BrickColor.new("Really black")
Part299.CanCollide = false
Part299.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part299.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part299.Material = Enum.Material.Metal
Part299.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part299.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part299.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part299.brickColor = BrickColor.new("Really black")
SpecialMesh300.Parent = Part299
SpecialMesh300.Scale = Vector3.new(0.5, 1, 0.400000006)
SpecialMesh300.MeshType = Enum.MeshType.Brick
Part301.Parent = Model0
Part301.CFrame = CFrame.new(-0.60622716, 3.20835805, -17.8265324, -0.999985635, 0.00525827007, -0.00103986717, -0.00513669662, -0.995525479, -0.0943559632, -0.00153136277, -0.0943492651, 0.995538116)
Part301.Orientation = Vector3.new(5.40999985, -0.0599999987, -179.699997)
Part301.Position = Vector3.new(-0.60622716, 3.20835805, -17.8265324)
Part301.Rotation = Vector3.new(5.40999985, -0.0599999987, -179.699997)
Part301.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part301.Velocity = Vector3.new(6.35782698e-08, 0.00245890464, 8.35486958e-07)
Part301.Size = Vector3.new(0.275000006, 0.235124931, 1.6693753)
Part301.Anchored = true
Part301.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part301.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part301.BrickColor = BrickColor.new("Really black")
Part301.CanCollide = false
Part301.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part301.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part301.Material = Enum.Material.Metal
Part301.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part301.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part301.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part301.brickColor = BrickColor.new("Really black")
SpecialMesh302.Parent = Part301
SpecialMesh302.Scale = Vector3.new(0.400000006, 1.04999995, 1)
SpecialMesh302.MeshType = Enum.MeshType.Brick
Part303.Parent = Model0
Part303.CFrame = CFrame.new(-0.610610962, 2.80771255, -13.6187115, -0.999985635, -0.00162816129, -0.00510662561, -0.00513656298, 0.0189460143, 0.999807417, -0.00153109711, 0.999819279, -0.0189541057)
Part303.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part303.Position = Vector3.new(-0.610610962, 2.80771255, -13.6187115)
Part303.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part303.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part303.Velocity = Vector3.new(1.27106944e-07, 0.00246767187, 1.67032101e-06)
Part303.Size = Vector3.new(0.275000006, 0.368124902, 0.378374994)
Part303.Anchored = true
Part303.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part303.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part303.BrickColor = BrickColor.new("Really black")
Part303.CanCollide = false
Part303.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part303.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part303.Material = Enum.Material.Glass
Part303.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part303.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part303.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part303.brickColor = BrickColor.new("Really black")
SpecialMesh304.Parent = Part303
SpecialMesh304.Scale = Vector3.new(0.400000006, 1, 1)
SpecialMesh304.MeshType = Enum.MeshType.Wedge
Part305.Parent = Model0
Part305.CFrame = CFrame.new(-0.608244181, 3.38925195, -17.114748, 0.999985635, 0.00432614516, 0.00316458894, 0.00513666775, -0.942128837, -0.335212082, 0.00153127394, 0.335223496, -0.942137599)
Part305.Orientation = Vector3.new(19.5900002, 179.809998, 179.690002)
Part305.Position = Vector3.new(-0.608244181, 3.38925195, -17.114748)
Part305.Rotation = Vector3.new(160.410004, 0.179999992, -0.25)
Part305.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part305.Velocity = Vector3.new(3.48947182e-08, 0.00246038754, 4.5855424e-07)
Part305.Size = Vector3.new(0.275000006, 0.35212487, 0.214375019)
Part305.Anchored = true
Part305.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part305.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part305.BrickColor = BrickColor.new("Bright blue")
Part305.CanCollide = false
Part305.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part305.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part305.Material = Enum.Material.Neon
Part305.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part305.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part305.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part305.brickColor = BrickColor.new("Bright blue")
SpecialMesh306.Parent = Part305
SpecialMesh306.Scale = Vector3.new(0.449999988, 0.5, 0.100000001)
SpecialMesh306.MeshType = Enum.MeshType.Brick
Part307.Parent = Model0
Part307.CFrame = CFrame.new(-0.610837221, 3.46367049, -15.6710596, 0.999985635, 0.00347598689, -0.00408008695, 0.00513679162, -0.404108554, 0.914696753, 0.00153067545, -0.914704561, -0.404120624)
Part307.Orientation = Vector3.new(-66.159996, -179.419998, 179.269989)
Part307.Position = Vector3.new(-0.610837221, 3.46367049, -15.6710596)
Part307.Rotation = Vector3.new(-113.839996, -0.229999989, -0.199999988)
Part307.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part307.Velocity = Vector3.new(2.30945076e-08, 0.00246339524, 3.03486615e-07)
Part307.Size = Vector3.new(0.200000003, 0.217000008, 0.200375021)
Part307.Anchored = true
Part307.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part307.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part307.BrickColor = BrickColor.new("Royal purple")
Part307.CanCollide = false
Part307.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part307.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part307.Material = Enum.Material.Neon
Part307.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part307.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part307.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part307.brickColor = BrickColor.new("Royal purple")
SpecialMesh308.Parent = Part307
SpecialMesh308.Scale = Vector3.new(0.560000002, 0.200000003, 0.600000024)
SpecialMesh308.MeshType = Enum.MeshType.Brick
Part309.Parent = Model0
Part309.CFrame = CFrame.new(-0.609296381, 2.72693467, -14.2067709, 0.999985635, -0.00162807154, 0.00510647474, 0.00513641024, 0.0189459547, -0.999807417, 0.00153101049, 0.999819279, 0.0189540461)
Part309.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part309.Position = Vector3.new(-0.609296381, 2.72693467, -14.2067709)
Part309.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part309.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part309.Velocity = Vector3.new(1.39915542e-07, 0.00246644672, 1.83863972e-06)
Part309.Size = Vector3.new(0.275000006, 0.315999985, 0.310375005)
Part309.Anchored = true
Part309.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part309.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part309.BrickColor = BrickColor.new("Really black")
Part309.CanCollide = false
Part309.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part309.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part309.Material = Enum.Material.Glass
Part309.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part309.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part309.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part309.brickColor = BrickColor.new("Really black")
SpecialMesh310.Parent = Part309
SpecialMesh310.Scale = Vector3.new(0.5, 1, 0.5)
SpecialMesh310.MeshType = Enum.MeshType.Wedge
Part311.Parent = Model0
Part311.CFrame = CFrame.new(-0.610869706, 2.96894002, -13.990572, -0.999985635, -0.00162807154, -0.00510650687, -0.00513644237, 0.0189459547, 0.999807417, -0.00153100991, 0.999819279, -0.0189540461)
Part311.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part311.Position = Vector3.new(-0.610869706, 2.96894002, -13.990572)
Part311.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part311.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part311.Velocity = Vector3.new(1.01541801e-07, 0.00246689701, 1.33436765e-06)
Part311.Size = Vector3.new(0.275000006, 0.214124978, 0.205375016)
Part311.Anchored = true
Part311.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part311.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part311.BrickColor = BrickColor.new("Really black")
Part311.CanCollide = false
Part311.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part311.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part311.Material = Enum.Material.Metal
Part311.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part311.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part311.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part311.brickColor = BrickColor.new("Really black")
SpecialMesh312.Parent = Part311
SpecialMesh312.Scale = Vector3.new(0.569999993, 0.75, 0.75)
SpecialMesh312.MeshType = Enum.MeshType.Brick
Part313.Parent = Model0
Part313.CFrame = CFrame.new(-0.610455632, 3.45922971, -15.9053869, 0.999985635, 0.00347598689, -0.00408008695, 0.00513679162, -0.404108554, 0.914696753, 0.00153067545, -0.914704561, -0.404120624)
Part313.Orientation = Vector3.new(-66.159996, -179.419998, 179.269989)
Part313.Position = Vector3.new(-0.610455632, 3.45922971, -15.9053869)
Part313.Rotation = Vector3.new(-113.839996, -0.229999989, -0.199999988)
Part313.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part313.Velocity = Vector3.new(2.37986608e-08, 0.00246290723, 3.12739985e-07)
Part313.Size = Vector3.new(0.200000003, 0.217000008, 0.200375021)
Part313.Anchored = true
Part313.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part313.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part313.BrickColor = BrickColor.new("Royal purple")
Part313.CanCollide = false
Part313.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part313.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part313.Material = Enum.Material.Neon
Part313.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part313.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part313.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part313.brickColor = BrickColor.new("Royal purple")
SpecialMesh314.Parent = Part313
SpecialMesh314.Scale = Vector3.new(0.560000002, 0.200000003, 0.600000024)
SpecialMesh314.MeshType = Enum.MeshType.Brick
Part315.Parent = Model0
Part315.CFrame = CFrame.new(-0.61787647, 3.39316416, -10.8383427, 0.999985635, -0.00162795314, 0.00510659395, 0.00513652712, 0.0189461038, -0.999807417, 0.00153088907, 0.999819279, 0.0189541951)
Part315.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part315.Position = Vector3.new(-0.61787647, 3.39316416, -10.8383427)
Part315.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part315.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part315.Velocity = Vector3.new(3.42744499e-08, 0.00247346424, 4.50402268e-07)
Part315.Size = Vector3.new(0.275000006, 0.578125, 0.234375)
Part315.Anchored = true
Part315.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part315.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part315.BrickColor = BrickColor.new("Really black")
Part315.CanCollide = false
Part315.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part315.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part315.Material = Enum.Material.Metal
Part315.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part315.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part315.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part315.brickColor = BrickColor.new("Really black")
SpecialMesh316.Parent = Part315
SpecialMesh316.Scale = Vector3.new(0.5, 1.04999995, 0.400000006)
SpecialMesh316.MeshType = Enum.MeshType.Brick
Part317.Parent = Model0
Part317.CFrame = CFrame.new(-0.613369107, 3.18659282, -13.087059, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part317.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part317.Position = Vector3.new(-0.613369107, 3.18659282, -13.087059)
Part317.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part317.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part317.Velocity = Vector3.new(6.70295464e-08, 0.00246877922, 8.8083965e-07)
Part317.Size = Vector3.new(0.275000006, 0.248124972, 0.311374992)
Part317.Anchored = true
Part317.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part317.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part317.BrickColor = BrickColor.new("Really black")
Part317.CanCollide = false
Part317.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part317.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part317.Material = Enum.Material.Metal
Part317.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part317.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part317.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part317.brickColor = BrickColor.new("Really black")
SpecialMesh318.Parent = Part317
SpecialMesh318.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh318.MeshType = Enum.MeshType.Brick
Part319.Parent = Model0
Part319.CFrame = CFrame.new(-0.610582829, 3.460711, -15.82728, 0.999985635, 0.00347598689, -0.00408008695, 0.00513679162, -0.404108554, 0.914696753, 0.00153067545, -0.914704561, -0.404120624)
Part319.Orientation = Vector3.new(-66.159996, -179.419998, 179.269989)
Part319.Position = Vector3.new(-0.610582829, 3.460711, -15.82728)
Part319.Rotation = Vector3.new(-113.839996, -0.229999989, -0.199999988)
Part319.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part319.Velocity = Vector3.new(2.35637785e-08, 0.00246306974, 3.09653387e-07)
Part319.Size = Vector3.new(0.200000003, 0.217000008, 0.200375021)
Part319.Anchored = true
Part319.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part319.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part319.BrickColor = BrickColor.new("Royal purple")
Part319.CanCollide = false
Part319.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part319.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part319.Material = Enum.Material.Neon
Part319.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part319.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part319.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part319.brickColor = BrickColor.new("Royal purple")
SpecialMesh320.Parent = Part319
SpecialMesh320.Scale = Vector3.new(0.560000002, 0.200000003, 0.600000024)
SpecialMesh320.MeshType = Enum.MeshType.Brick
Part321.Parent = Model0
Part321.CFrame = CFrame.new(-0.611585259, 3.11314392, -14.0068893, 0.999985635, 0.00162774313, -0.00510693667, 0.00513686566, -0.0189458374, 0.999807417, 0.00153067405, -0.999819279, -0.0189539269)
Part321.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part321.Position = Vector3.new(-0.611585259, 3.11314392, -14.0068893)
Part321.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part321.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part321.Velocity = Vector3.new(7.86760097e-08, 0.00246686279, 1.03388675e-06)
Part321.Size = Vector3.new(0.275000006, 0.709124923, 0.47437498)
Part321.Anchored = true
Part321.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part321.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part321.BrickColor = BrickColor.new("Really black")
Part321.CanCollide = false
Part321.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part321.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part321.Material = Enum.Material.Metal
Part321.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part321.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part321.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part321.brickColor = BrickColor.new("Really black")
SpecialMesh322.Parent = Part321
SpecialMesh322.Scale = Vector3.new(0.5, 1.04999995, 0.800000012)
SpecialMesh322.MeshType = Enum.MeshType.Brick
Part323.Parent = Model0
Part323.CFrame = CFrame.new(-0.610941768, 3.01069665, -14.083005, -0.999985635, 0.00162795174, 0.00510683283, -0.00513676554, -0.0189458355, -0.999807417, -0.00153088453, -0.999819279, 0.0189539269)
Part323.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part323.Position = Vector3.new(-0.610941768, 3.01069665, -14.083005)
Part323.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part323.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part323.Velocity = Vector3.new(9.49206296e-08, 0.00246670446, 1.24735845e-06)
Part323.Size = Vector3.new(0.275000006, 0.252000004, 0.213375002)
Part323.Anchored = true
Part323.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part323.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part323.BrickColor = BrickColor.new("Really black")
Part323.CanCollide = false
Part323.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part323.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part323.Material = Enum.Material.Metal
Part323.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part323.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part323.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part323.brickColor = BrickColor.new("Really black")
SpecialMesh324.Parent = Part323
SpecialMesh324.Scale = Vector3.new(0.569999993, 0.125, 0.375)
SpecialMesh324.MeshType = Enum.MeshType.Wedge
Part325.Parent = Model0
Part325.CFrame = CFrame.new(-0.61388576, 3.20741606, -12.8194075, -0.999985635, 0.00162786373, 0.00510683237, -0.00513676414, -0.0189461056, -0.999807417, -0.00153079513, -0.999819279, 0.0189541951)
Part325.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part325.Position = Vector3.new(-0.61388576, 3.20741606, -12.8194075)
Part325.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part325.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part325.Velocity = Vector3.new(6.37276969e-08, 0.00246933685, 8.37449761e-07)
Part325.Size = Vector3.new(0.275000006, 0.244125068, 0.416375011)
Part325.Anchored = true
Part325.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part325.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part325.BrickColor = BrickColor.new("Really black")
Part325.CanCollide = false
Part325.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part325.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part325.Material = Enum.Material.Metal
Part325.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part325.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part325.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part325.brickColor = BrickColor.new("Really black")
SpecialMesh326.Parent = Part325
SpecialMesh326.Scale = Vector3.new(0.5, 0.560000002, 0.5)
SpecialMesh326.MeshType = Enum.MeshType.Wedge
Part327.Parent = Model0
Part327.CFrame = CFrame.new(-0.609650612, 3.31554532, -15.9490957, 0.999985635, 0.00326791825, 0.00424884167, 0.00513684331, -0.810688972, -0.585454702, 0.00153127068, 0.585468173, -0.810694098)
Part327.Orientation = Vector3.new(35.8400002, 179.699997, 179.639999)
Part327.Position = Vector3.new(-0.609650612, 3.31554532, -15.9490957)
Part327.Rotation = Vector3.new(144.160004, 0.239999995, -0.189999998)
Part327.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part327.Velocity = Vector3.new(4.65820733e-08, 0.00246281619, 6.12138422e-07)
Part327.Size = Vector3.new(0.275000006, 0.237124875, 0.214375019)
Part327.Anchored = true
Part327.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part327.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part327.BrickColor = BrickColor.new("Bright blue")
Part327.CanCollide = false
Part327.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part327.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part327.Material = Enum.Material.Neon
Part327.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part327.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part327.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part327.brickColor = BrickColor.new("Bright blue")
SpecialMesh328.Parent = Part327
SpecialMesh328.Scale = Vector3.new(0.449999988, 0.800000012, 0.100000001)
SpecialMesh328.MeshType = Enum.MeshType.Brick
Part329.Parent = Model0
Part329.CFrame = CFrame.new(-0.612260759, 3.04390216, -13.3335075, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part329.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part329.Position = Vector3.new(-0.612260759, 3.04390216, -13.3335075)
Part329.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part329.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part329.Velocity = Vector3.new(8.96553871e-08, 0.00246826583, 1.17816739e-06)
Part329.Size = Vector3.new(0.275000006, 0.200000003, 0.303375006)
Part329.Anchored = true
Part329.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part329.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part329.BrickColor = BrickColor.new("Really black")
Part329.CanCollide = false
Part329.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part329.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part329.Material = Enum.Material.Metal
Part329.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part329.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part329.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part329.brickColor = BrickColor.new("Really black")
SpecialMesh330.Parent = Part329
SpecialMesh330.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh330.MeshType = Enum.MeshType.Wedge
Part331.Parent = Model0
Part331.CFrame = CFrame.new(-0.614394248, 3.36069822, -13.0015078, -0.999985635, 0.00245974353, -0.0047620195, -0.00513649127, -0.693573475, 0.72036773, -0.00153088977, 0.720381856, 0.693576157)
Part331.Orientation = Vector3.new(-46.079998, -0.389999986, -179.580002)
Part331.Position = Vector3.new(-0.614394248, 3.36069822, -13.0015078)
Part331.Rotation = Vector3.new(-46.0900002, -0.269999981, -179.860001)
Part331.Color = Color3.new(0.803922, 0.803922, 0.803922)
Part331.Velocity = Vector3.new(3.94224067e-08, 0.00246895733, 5.18052275e-07)
Part331.Size = Vector3.new(0.275000006, 0.216124982, 0.280375004)
Part331.Anchored = true
Part331.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part331.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part331.BrickColor = BrickColor.new("Mid gray")
Part331.CanCollide = false
Part331.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part331.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part331.Material = Enum.Material.Metal
Part331.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part331.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part331.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part331.brickColor = BrickColor.new("Mid gray")
SpecialMesh332.Parent = Part331
SpecialMesh332.Scale = Vector3.new(0.349999994, 1.04999995, 0.5)
SpecialMesh332.MeshType = Enum.MeshType.Brick
Part333.Parent = Model0
Part333.CFrame = CFrame.new(-0.610709965, 3.46219134, -15.7491703, 0.999985635, 0.00347598689, -0.00408008695, 0.00513679162, -0.404108554, 0.914696753, 0.00153067545, -0.914704561, -0.404120624)
Part333.Orientation = Vector3.new(-66.159996, -179.419998, 179.269989)
Part333.Position = Vector3.new(-0.610709965, 3.46219134, -15.7491703)
Part333.Rotation = Vector3.new(-113.839996, -0.229999989, -0.199999988)
Part333.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part333.Velocity = Vector3.new(2.33290489e-08, 0.00246323249, 3.06568751e-07)
Part333.Size = Vector3.new(0.200000003, 0.217000008, 0.200375021)
Part333.Anchored = true
Part333.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part333.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part333.BrickColor = BrickColor.new("Royal purple")
Part333.CanCollide = false
Part333.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part333.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part333.Material = Enum.Material.Neon
Part333.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part333.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part333.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part333.brickColor = BrickColor.new("Royal purple")
SpecialMesh334.Parent = Part333
SpecialMesh334.Scale = Vector3.new(0.560000002, 0.200000003, 0.600000024)
SpecialMesh334.MeshType = Enum.MeshType.Brick
Part335.Parent = Model0
Part335.CFrame = CFrame.new(-0.608794093, 3.33530617, -16.5748692, 0.999985635, -0.0041169636, 0.00343261915, 0.005137017, 0.553175688, -0.83304894, 0.00153079035, 0.833054662, 0.55318886)
Part335.Orientation = Vector3.new(56.4099998, 0.359999985, 0.529999971)
Part335.Position = Vector3.new(-0.608794093, 3.33530617, -16.5748692)
Part335.Rotation = Vector3.new(56.4099998, 0.199999988, 0.239999995)
Part335.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part335.Velocity = Vector3.new(4.34486722e-08, 0.00246151234, 5.709623e-07)
Part335.Size = Vector3.new(0.275000006, 0.265124857, 0.214375019)
Part335.Anchored = true
Part335.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part335.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part335.BrickColor = BrickColor.new("Bright blue")
Part335.CanCollide = false
Part335.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part335.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part335.Material = Enum.Material.Neon
Part335.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part335.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part335.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part335.brickColor = BrickColor.new("Bright blue")
SpecialMesh336.Parent = Part335
SpecialMesh336.Scale = Vector3.new(0.449999988, 0.899999976, 0.100000001)
SpecialMesh336.MeshType = Enum.MeshType.Brick
Part337.Parent = Model0
Part337.CFrame = CFrame.new(-0.61091727, 3.02827954, -14.1579723, -0.999985635, 0.00162795268, 0.00510695158, -0.00513688475, -0.0189460143, -0.999807417, -0.00153088232, -0.999819279, 0.0189541057)
Part337.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part337.Position = Vector3.new(-0.61091727, 3.02827954, -14.1579723)
Part337.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part337.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part337.Velocity = Vector3.new(9.21325807e-08, 0.00246654823, 1.2107206e-06)
Part337.Size = Vector3.new(0.275000006, 0.207000002, 0.303375006)
Part337.Anchored = true
Part337.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part337.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part337.BrickColor = BrickColor.new("Really black")
Part337.CanCollide = false
Part337.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part337.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part337.Material = Enum.Material.Glass
Part337.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part337.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part337.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part337.brickColor = BrickColor.new("Really black")
SpecialMesh338.Parent = Part337
SpecialMesh338.Scale = Vector3.new(0.524999976, 0.5, 0.5)
SpecialMesh338.MeshType = Enum.MeshType.Wedge
Part339.Parent = Model0
Part339.CFrame = CFrame.new(-0.609729409, 3.2205193, -15.578517, 0.999985635, -0.00133592135, 0.00519115385, 0.00513700396, -0.0377659947, -0.999273479, 0.00153099932, 0.999285877, -0.0377585888)
Part339.Orientation = Vector3.new(87.8199997, 172.169998, 172.25)
Part339.Position = Vector3.new(-0.609729409, 3.2205193, -15.578517)
Part339.Rotation = Vector3.new(92.159996, 0.299999982, 0.0799999982)
Part339.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part339.Velocity = Vector3.new(6.1649942e-08, 0.00246358826, 8.10146275e-07)
Part339.Size = Vector3.new(0.275000006, 0.621124864, 0.214375019)
Part339.Anchored = true
Part339.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part339.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part339.BrickColor = BrickColor.new("Bright blue")
Part339.CanCollide = false
Part339.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part339.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part339.Material = Enum.Material.Neon
Part339.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part339.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part339.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part339.brickColor = BrickColor.new("Bright blue")
SpecialMesh340.Parent = Part339
SpecialMesh340.Scale = Vector3.new(0.449999988, 1, 0.100000001)
SpecialMesh340.MeshType = Enum.MeshType.Brick
Part341.Parent = Model0
Part341.CFrame = CFrame.new(-0.610086679, 3.15827918, -15.1365986, -0.999985635, 0.00409500999, -0.00345871458, -0.00513683027, -0.916451037, 0.400114089, -0.00153127091, 0.40012604, 0.916459024)
Part341.Orientation = Vector3.new(-23.5900002, -0.219999999, -179.679993)
Part341.Position = Vector3.new(-0.610086679, 3.15827918, -15.1365986)
Part341.Rotation = Vector3.new(-23.5900002, -0.199999988, -179.769989)
Part341.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part341.Velocity = Vector3.new(7.15190893e-08, 0.0024645091, 9.39837378e-07)
Part341.Size = Vector3.new(0.275000006, 0.221124932, 0.655375004)
Part341.Anchored = true
Part341.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part341.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part341.BrickColor = BrickColor.new("Really black")
Part341.CanCollide = false
Part341.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part341.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part341.Material = Enum.Material.Metal
Part341.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part341.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part341.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part341.brickColor = BrickColor.new("Really black")
SpecialMesh342.Parent = Part341
SpecialMesh342.Scale = Vector3.new(0.400000006, 1.04999995, 0.899999976)
SpecialMesh342.MeshType = Enum.MeshType.Brick
Part343.Parent = Model0
Part343.CFrame = CFrame.new(-0.576193094, 2.37180829, -14.2261257, 0.00114334025, 0.999985635, -0.00523668947, -0.483495861, 0.00513671385, 0.8753317, 0.875346005, 0.00153111527, 0.483494759)
Part343.Orientation = Vector3.new(-61.079998, -0.620000005, -89.3899994)
Part343.Position = Vector3.new(-0.576193094, 2.37180829, -14.2261257)
Part343.Rotation = Vector3.new(-61.0900002, -0.299999982, -89.9300003)
Part343.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part343.Velocity = Vector3.new(1.96226381e-07, 0.00246641156, 2.57862462e-06)
Part343.Size = Vector3.new(0.405000031, 0.200000003, 0.280375004)
Part343.Anchored = true
Part343.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part343.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part343.BrickColor = BrickColor.new("Royal purple")
Part343.CanCollide = false
Part343.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part343.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part343.Material = Enum.Material.Neon
Part343.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part343.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part343.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part343.brickColor = BrickColor.new("Royal purple")
SpecialMesh344.Parent = Part343
SpecialMesh344.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh344.MeshType = Enum.MeshType.Wedge
Part345.Parent = Model0
Part345.CFrame = CFrame.new(-0.606692195, 3.59138489, -18.8080196, 0.999985635, 0.00250130473, 0.00474093435, 0.00513696205, -0.699832857, -0.714288294, 0.00153120875, 0.714302421, -0.699835718)
Part345.Orientation = Vector3.new(45.579998, 179.610001, 179.580002)
Part345.Position = Vector3.new(-0.606692195, 3.59138489, -18.8080196)
Part345.Rotation = Vector3.new(134.410004, 0.269999981, -0.140000001)
Part345.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part345.Velocity = Vector3.new(2.843354e-09, 0.00245685945, 3.73652256e-08)
Part345.Size = Vector3.new(0.275000006, 0.47012496, 0.214375019)
Part345.Anchored = true
Part345.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part345.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part345.BrickColor = BrickColor.new("Bright blue")
Part345.CanCollide = false
Part345.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part345.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part345.Material = Enum.Material.Neon
Part345.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part345.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part345.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part345.brickColor = BrickColor.new("Bright blue")
SpecialMesh346.Parent = Part345
SpecialMesh346.Scale = Vector3.new(0.449999988, 0.699999988, 0.100000001)
SpecialMesh346.MeshType = Enum.MeshType.Brick
Part347.Parent = Model0
Part347.CFrame = CFrame.new(-0.612170458, 3.17509294, -13.8325748, -0.999985635, 0.00162795268, 0.00510695158, -0.00513688475, -0.0189460143, -0.999807417, -0.00153088232, -0.999819279, 0.0189541057)
Part347.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part347.Position = Vector3.new(-0.612170458, 3.17509294, -13.8325748)
Part347.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part347.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part347.Velocity = Vector3.new(6.88530264e-08, 0.002467226, 9.04802221e-07)
Part347.Size = Vector3.new(0.275000006, 0.207000002, 0.303375006)
Part347.Anchored = true
Part347.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part347.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part347.BrickColor = BrickColor.new("Really black")
Part347.CanCollide = false
Part347.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part347.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part347.Material = Enum.Material.Metal
Part347.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part347.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part347.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part347.brickColor = BrickColor.new("Really black")
SpecialMesh348.Parent = Part347
SpecialMesh348.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh348.MeshType = Enum.MeshType.Wedge
Part349.Parent = Model0
Part349.CFrame = CFrame.new(-0.608221889, 3.47114682, -17.4040871, 0.999985635, -0.00133592309, 0.00519115338, 0.00513700396, -0.037765637, -0.999273479, 0.00153099932, 0.999285877, -0.0377582312)
Part349.Orientation = Vector3.new(87.8199997, 172.169998, 172.25)
Part349.Position = Vector3.new(-0.608221889, 3.47114682, -17.4040871)
Part349.Rotation = Vector3.new(92.159996, 0.299999982, 0.0799999982)
Part349.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part349.Velocity = Vector3.new(2.19089991e-08, 0.0024597845, 2.87908023e-07)
Part349.Size = Vector3.new(0.275000006, 0.678124905, 0.214375019)
Part349.Anchored = true
Part349.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part349.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part349.BrickColor = BrickColor.new("Bright blue")
Part349.CanCollide = false
Part349.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part349.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part349.Material = Enum.Material.Neon
Part349.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part349.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part349.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part349.brickColor = BrickColor.new("Bright blue")
SpecialMesh350.Parent = Part349
SpecialMesh350.Scale = Vector3.new(0.449999988, 0.800000012, 0.100000001)
SpecialMesh350.MeshType = Enum.MeshType.Brick
Part351.Parent = Model0
Part351.CFrame = CFrame.new(-0.617746711, 3.42490911, -11.0273066, 0.999985635, -0.000716609415, 0.00531159993, 0.00513640279, -0.15495652, -0.987908006, 0.00153101061, 0.987921119, -0.154950604)
Part351.Orientation = Vector3.new(81.0800018, 178.039993, 178.099991)
Part351.Position = Vector3.new(-0.617746711, 3.42490911, -11.0273066)
Part351.Rotation = Vector3.new(98.909996, 0.299999982, 0.0399999991)
Part351.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part351.Velocity = Vector3.new(2.92407876e-08, 0.00247307052, 3.84254577e-07)
Part351.Size = Vector3.new(0.275000006, 0.203125, 0.234375)
Part351.Anchored = true
Part351.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part351.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part351.BrickColor = BrickColor.new("Really black")
Part351.CanCollide = false
Part351.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part351.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part351.Material = Enum.Material.Metal
Part351.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part351.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part351.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part351.brickColor = BrickColor.new("Really black")
SpecialMesh352.Parent = Part351
SpecialMesh352.Scale = Vector3.new(0.5, 0.502499998, 0.400000006)
SpecialMesh352.MeshType = Enum.MeshType.Brick
Part353.Parent = Model0
Part353.CFrame = CFrame.new(-0.638692379, 2.37148738, -14.226222, -0.00114342954, -0.999985635, -0.00523668341, 0.483495861, -0.00513675157, 0.8753317, -0.875346065, -0.00153103401, 0.483494759)
Part353.Orientation = Vector3.new(-61.079998, -0.620000005, 90.6100006)
Part353.Position = Vector3.new(-0.638692379, 2.37148738, -14.226222)
Part353.Rotation = Vector3.new(-61.0900002, -0.299999982, 90.0699997)
Part353.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part353.Velocity = Vector3.new(1.9627727e-07, 0.00246640155, 2.57929332e-06)
Part353.Size = Vector3.new(0.405000031, 0.200000003, 0.280375004)
Part353.Anchored = true
Part353.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part353.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part353.BrickColor = BrickColor.new("Royal purple")
Part353.CanCollide = false
Part353.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part353.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part353.Material = Enum.Material.Neon
Part353.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part353.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part353.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part353.brickColor = BrickColor.new("Royal purple")
SpecialMesh354.Parent = Part353
SpecialMesh354.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh354.MeshType = Enum.MeshType.Wedge
Part355.Parent = Model0
Part355.CFrame = CFrame.new(-0.576556623, 2.33930445, -13.8796148, -0.00289415126, 0.999985635, -0.00451143365, 0.277069539, 0.00513670407, 0.960836232, 0.96084559, 0.00153082411, -0.277080417)
Part355.Orientation = Vector3.new(-73.909996, -179.069992, 88.9399948)
Part355.Position = Vector3.new(-0.576556623, 2.33930445, -13.8796148)
Part355.Rotation = Vector3.new(-106.089996, -0.25999999, -90.1699982)
Part355.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part355.Velocity = Vector3.new(2.01380388e-07, 0.00246713357, 2.64635355e-06)
Part355.Size = Vector3.new(0.453000009, 0.200000003, 0.280375004)
Part355.Anchored = true
Part355.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part355.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part355.BrickColor = BrickColor.new("Royal purple")
Part355.CanCollide = false
Part355.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part355.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part355.Material = Enum.Material.Neon
Part355.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part355.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part355.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part355.brickColor = BrickColor.new("Royal purple")
SpecialMesh356.Parent = Part355
SpecialMesh356.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh356.MeshType = Enum.MeshType.Wedge
Part357.Parent = Model0
Part357.CFrame = CFrame.new(-0.609105706, 2.8586967, -14.7735023, -0.999985635, -0.0039632949, -0.00360830128, -0.00513646565, 0.516311884, 0.856385469, -0.00153109885, 0.856391609, -0.516324818)
Part357.Orientation = Vector3.new(-58.9099998, -179.599991, -0.569999993)
Part357.Position = Vector3.new(-0.609105706, 2.8586967, -14.7735023)
Part357.Rotation = Vector3.new(-121.089996, -0.209999993, 179.769989)
Part357.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part357.Velocity = Vector3.new(1.19022602e-07, 0.0024652658, 1.56408419e-06)
Part357.Size = Vector3.new(0.275000006, 0.277124912, 0.227375031)
Part357.Anchored = true
Part357.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part357.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part357.BrickColor = BrickColor.new("Really black")
Part357.CanCollide = false
Part357.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part357.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part357.Material = Enum.Material.Metal
Part357.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part357.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part357.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part357.brickColor = BrickColor.new("Really black")
SpecialMesh358.Parent = Part357
SpecialMesh358.Scale = Vector3.new(0.349999994, 0.300000012, 1)
SpecialMesh358.MeshType = Enum.MeshType.Brick
Part359.Parent = Model0
Part359.CFrame = CFrame.new(-0.614465594, 3.24354935, -12.5620441, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part359.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part359.Position = Vector3.new(-0.614465594, 3.24354935, -12.5620441)
Part359.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part359.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part359.Velocity = Vector3.new(5.79982e-08, 0.00246987306, 7.62158038e-07)
Part359.Size = Vector3.new(0.275000006, 0.998124957, 0.280375004)
Part359.Anchored = true
Part359.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part359.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part359.BrickColor = BrickColor.new("Really black")
Part359.CanCollide = false
Part359.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part359.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part359.Material = Enum.Material.Metal
Part359.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part359.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part359.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part359.brickColor = BrickColor.new("Really black")
SpecialMesh360.Parent = Part359
SpecialMesh360.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh360.MeshType = Enum.MeshType.Brick
Part361.Parent = Model0
Part361.CFrame = CFrame.new(-0.611248136, 3.25645614, -14.7074032, -0.999985635, 0.00245982548, -0.00476256292, -0.00513693923, -0.693573654, 0.720367551, -0.00153120921, 0.720381677, 0.693576276)
Part361.Orientation = Vector3.new(-46.079998, -0.389999986, -179.580002)
Part361.Position = Vector3.new(-0.611248136, 3.25645614, -14.7074032)
Part361.Rotation = Vector3.new(-46.0900002, -0.269999981, -179.860001)
Part361.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part361.Velocity = Vector3.new(5.59516025e-08, 0.00246540317, 7.35263882e-07)
Part361.Size = Vector3.new(0.275000006, 0.221124932, 0.418375015)
Part361.Anchored = true
Part361.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part361.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part361.BrickColor = BrickColor.new("Really black")
Part361.CanCollide = false
Part361.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part361.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part361.Material = Enum.Material.Metal
Part361.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part361.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part361.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part361.brickColor = BrickColor.new("Really black")
SpecialMesh362.Parent = Part361
SpecialMesh362.Scale = Vector3.new(0.550000012, 1.04999995, 0.899999976)
SpecialMesh362.MeshType = Enum.MeshType.Brick
Part363.Parent = Model0
Part363.CFrame = CFrame.new(-0.611290276, 3.1978817, -14.4833202, 0.999985635, 0.00162786234, -0.00510698371, 0.00513691502, -0.0189458374, 0.999807417, 0.00153079221, -0.999819279, -0.0189539269)
Part363.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part363.Position = Vector3.new(-0.611290276, 3.1978817, -14.4833202)
Part363.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part363.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part363.Velocity = Vector3.new(6.52394974e-08, 0.00246587023, 8.57316763e-07)
Part363.Size = Vector3.new(0.275000006, 0.221124932, 0.448374987)
Part363.Anchored = true
Part363.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part363.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part363.BrickColor = BrickColor.new("Really black")
Part363.CanCollide = false
Part363.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part363.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part363.Material = Enum.Material.Metal
Part363.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part363.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part363.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part363.brickColor = BrickColor.new("Really black")
SpecialMesh364.Parent = Part363
SpecialMesh364.Scale = Vector3.new(0.550000012, 1.04999995, 0.800000012)
SpecialMesh364.MeshType = Enum.MeshType.Brick
Part365.Parent = Model0
Part365.CFrame = CFrame.new(-0.610800147, 2.91253304, -13.8467321, -0.999985635, -0.00162807154, -0.00510650687, -0.00513644237, 0.0189459547, 0.999807417, -0.00153100991, 0.999819279, -0.0189540461)
Part365.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part365.Position = Vector3.new(-0.610800147, 2.91253304, -13.8467321)
Part365.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part365.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part365.Velocity = Vector3.new(1.10486013e-07, 0.00246719667, 1.45190415e-06)
Part365.Size = Vector3.new(0.275000006, 0.200000003, 0.213375002)
Part365.Anchored = true
Part365.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part365.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part365.BrickColor = BrickColor.new("Bright blue")
Part365.CanCollide = false
Part365.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part365.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part365.Material = Enum.Material.Neon
Part365.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part365.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part365.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part365.brickColor = BrickColor.new("Bright blue")
SpecialMesh366.Parent = Part365
SpecialMesh366.Scale = Vector3.new(0.550000012, 0.25, 0.5)
SpecialMesh366.MeshType = Enum.MeshType.Wedge
Part367.Parent = Model0
Part367.CFrame = CFrame.new(-0.616349459, 3.1451273, -11.0012493, -0.999985635, -0.000250895391, -0.00535403285, -0.00513659744, -0.24046874, 0.970643461, -0.001531007, 0.970656931, 0.240463987)
Part367.Orientation = Vector3.new(-76.0800018, -1.27999997, -178.779999)
Part367.Position = Vector3.new(-0.616349459, 3.1451273, -11.0012493)
Part367.Rotation = Vector3.new(-76.0899963, -0.310000002, 179.98999)
Part367.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part367.Velocity = Vector3.new(7.3604582e-08, 0.002473125, 9.67242272e-07)
Part367.Size = Vector3.new(0.200000003, 0.449500024, 0.236624971)
Part367.Anchored = true
Part367.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part367.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part367.BrickColor = BrickColor.new("Bright blue")
Part367.CanCollide = false
Part367.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part367.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part367.Material = Enum.Material.Neon
Part367.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part367.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part367.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part367.brickColor = BrickColor.new("Bright blue")
SpecialMesh368.Parent = Part367
SpecialMesh368.Scale = Vector3.new(0.5, 1, 0.25)
SpecialMesh368.MeshType = Enum.MeshType.Brick
Part369.Parent = Model0
Part369.CFrame = CFrame.new(-0.612978816, 3.18449855, -13.3361721, 0.999985635, -0.00162807154, 0.00510664983, 0.00513658533, 0.0189459547, -0.999807417, 0.00153100723, 0.999819279, 0.0189540461)
Part369.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part369.Position = Vector3.new(-0.612978816, 3.18449855, -13.3361721)
Part369.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part369.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part369.Velocity = Vector3.new(6.73616256e-08, 0.00246826024, 8.85203519e-07)
Part369.Size = Vector3.new(0.275000006, 0.200000003, 0.303375006)
Part369.Anchored = true
Part369.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part369.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part369.BrickColor = BrickColor.new("Really black")
Part369.CanCollide = false
Part369.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part369.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part369.Material = Enum.Material.Metal
Part369.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part369.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part369.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part369.brickColor = BrickColor.new("Really black")
SpecialMesh370.Parent = Part369
SpecialMesh370.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh370.MeshType = Enum.MeshType.Wedge
Part371.Parent = Model0
Part371.CFrame = CFrame.new(-0.611412168, 3.19930172, -14.4084625, 0.999985635, 0.00162786234, -0.00510698371, 0.00513691502, -0.0189458374, 0.999807417, 0.00153079221, -0.999819279, -0.0189539269)
Part371.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part371.Position = Vector3.new(-0.611412168, 3.19930172, -14.4084625)
Part371.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part371.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part371.Velocity = Vector3.new(6.50143335e-08, 0.00246602623, 8.54357836e-07)
Part371.Size = Vector3.new(0.275000006, 0.204124942, 0.464375019)
Part371.Anchored = true
Part371.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part371.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part371.BrickColor = BrickColor.new("Royal purple")
Part371.CanCollide = false
Part371.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part371.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part371.Material = Enum.Material.Neon
Part371.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part371.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part371.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part371.brickColor = BrickColor.new("Royal purple")
SpecialMesh372.Parent = Part371
SpecialMesh372.Scale = Vector3.new(0.524999976, 1.04999995, 0.800000012)
SpecialMesh372.MeshType = Enum.MeshType.Brick
Part373.Parent = Model0
Part373.CFrame = CFrame.new(-0.607544899, 3.43064713, -17.7122707, 0.999985635, -0.004783432, 0.00241859211, 0.00513692852, 0.726393282, -0.68726027, 0.00153061328, 0.687262774, 0.726407468)
Part373.Orientation = Vector3.new(43.4099998, 0.189999998, 0.409999996)
Part373.Position = Vector3.new(-0.607544899, 3.43064713, -17.7122707)
Part373.Rotation = Vector3.new(43.4099998, 0.140000001, 0.269999981)
Part373.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part373.Velocity = Vector3.new(2.83308559e-08, 0.00245914259, 3.72298132e-07)
Part373.Size = Vector3.new(0.275000006, 0.24712491, 0.214375019)
Part373.Anchored = true
Part373.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part373.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part373.BrickColor = BrickColor.new("Bright blue")
Part373.CanCollide = false
Part373.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part373.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part373.Material = Enum.Material.Neon
Part373.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part373.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part373.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part373.brickColor = BrickColor.new("Bright blue")
SpecialMesh374.Parent = Part373
SpecialMesh374.Scale = Vector3.new(0.449999988, 0.600000024, 0.100000001)
SpecialMesh374.MeshType = Enum.MeshType.Brick
Part375.Parent = Model0
Part375.CFrame = CFrame.new(-0.613238811, 3.32843637, -13.6493177, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part375.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part375.Position = Vector3.new(-0.613238811, 3.32843637, -13.6493177)
Part375.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part375.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part375.Velocity = Vector3.new(4.45380195e-08, 0.00246760761, 5.85277007e-07)
Part375.Size = Vector3.new(0.275000006, 0.698124886, 0.534374952)
Part375.Anchored = true
Part375.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part375.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part375.BrickColor = BrickColor.new("Bright blue")
Part375.CanCollide = false
Part375.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part375.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part375.Material = Enum.Material.Glass
Part375.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part375.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part375.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part375.brickColor = BrickColor.new("Bright blue")
SpecialMesh376.Parent = Part375
SpecialMesh376.Scale = Vector3.new(0.452499986, 1, 1)
SpecialMesh376.MeshType = Enum.MeshType.Cylinder
Part377.Parent = Model0
Part377.CFrame = CFrame.new(-0.618502736, 3.35398197, -11.388195, -0.999985635, 0.00162807188, 0.00510671316, -0.00513664866, -0.0189460143, -0.999807417, -0.00153100595, -0.999819279, 0.0189541057)
Part377.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part377.Position = Vector3.new(-0.618502736, 3.35398197, -11.388195)
Part377.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part377.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part377.Velocity = Vector3.new(4.0487393e-08, 0.00247231848, 5.32047068e-07)
Part377.Size = Vector3.new(0.25999999, 0.225500003, 0.210125014)
Part377.Anchored = true
Part377.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part377.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part377.BrickColor = BrickColor.new("Really black")
Part377.CanCollide = false
Part377.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part377.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part377.Material = Enum.Material.Metal
Part377.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part377.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part377.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part377.brickColor = BrickColor.new("Really black")
SpecialMesh378.Parent = Part377
SpecialMesh378.Scale = Vector3.new(0.5, 1, 1)
SpecialMesh378.MeshType = Enum.MeshType.Wedge
Part379.Parent = Model0
Part379.CFrame = CFrame.new(-0.575232625, 3.71340823, -19.3540096, 0.00507748965, 0.999985635, -0.00171704218, -0.999324501, 0.00513662118, 0.0363931209, 0.0364014208, 0.00153109594, 0.999336243)
Part379.Orientation = Vector3.new(-2.08999991, -0.099999994, -89.7099991)
Part379.Position = Vector3.new(-0.575232625, 3.71340823, -19.3540096)
Part379.Rotation = Vector3.new(-2.08999991, -0.099999994, -89.7099991)
Part379.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part379.Velocity = Vector3.new(-1.65053677e-08, 0.00245572673, -2.16897547e-07)
Part379.Size = Vector3.new(0.210000038, 0.200000003, 0.285374999)
Part379.Anchored = true
Part379.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part379.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part379.BrickColor = BrickColor.new("Royal purple")
Part379.CanCollide = false
Part379.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part379.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part379.Material = Enum.Material.Neon
Part379.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part379.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part379.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part379.brickColor = BrickColor.new("Royal purple")
SpecialMesh380.Parent = Part379
SpecialMesh380.Scale = Vector3.new(0.5, 0.300000012, 0.5)
SpecialMesh380.MeshType = Enum.MeshType.Wedge
Part381.Parent = Model0
Part381.CFrame = CFrame.new(-0.609601736, 3.48017144, -16.5335026, 0.999985635, -0.00133592158, 0.00519114826, 0.0051369979, -0.0377659947, -0.999273479, 0.00153099943, 0.999285877, -0.0377585888)
Part381.Orientation = Vector3.new(87.8199997, 172.169998, 172.25)
Part381.Position = Vector3.new(-0.609601736, 3.48017144, -16.5335026)
Part381.Rotation = Vector3.new(92.159996, 0.299999982, 0.0799999982)
Part381.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part381.Velocity = Vector3.new(2.0478014e-08, 0.00246159849, 2.69103225e-07)
Part381.Size = Vector3.new(0.275000006, 1.65712488, 0.359375)
Part381.Anchored = true
Part381.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part381.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part381.BrickColor = BrickColor.new("Really black")
Part381.CanCollide = false
Part381.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part381.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part381.Material = Enum.Material.Metal
Part381.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part381.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part381.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part381.brickColor = BrickColor.new("Really black")
SpecialMesh382.Parent = Part381
SpecialMesh382.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh382.MeshType = Enum.MeshType.Brick
Part383.Parent = Model0
Part383.CFrame = CFrame.new(-0.608603716, 2.57794237, -14.160059, -0.999985635, 0.00114323408, -0.00523646409, -0.00513646565, -0.483495802, 0.8753317, -0.00153109885, 0.875346065, 0.483494699)
Part383.Orientation = Vector3.new(-61.079998, -0.620000005, -179.389999)
Part383.Position = Vector3.new(-0.608603716, 2.57794237, -14.160059)
Part383.Rotation = Vector3.new(-61.0900002, -0.299999982, -179.929993)
Part383.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part383.Velocity = Vector3.new(1.63540591e-07, 0.00246654428, 2.14909824e-06)
Part383.Size = Vector3.new(0.275000006, 0.309124947, 0.343375027)
Part383.Anchored = true
Part383.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part383.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part383.BrickColor = BrickColor.new("Really black")
Part383.CanCollide = false
Part383.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part383.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part383.Material = Enum.Material.Metal
Part383.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part383.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part383.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part383.brickColor = BrickColor.new("Really black")
SpecialMesh384.Parent = Part383
SpecialMesh384.Scale = Vector3.new(0.349999994, 1, 1)
SpecialMesh384.MeshType = Enum.MeshType.Brick
Part385.Parent = Model0
Part385.CFrame = CFrame.new(-0.610497713, 3.13989329, -14.8064632, 0.999985635, -0.00162807363, 0.00510707032, 0.00513700629, 0.018946372, -0.999807417, 0.0015309992, 0.999819279, 0.0189544633)
Part385.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part385.Position = Vector3.new(-0.610497713, 3.13989329, -14.8064632)
Part385.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part385.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part385.Velocity = Vector3.new(7.44344675e-08, 0.00246519689, 9.78148478e-07)
Part385.Size = Vector3.new(0.275000006, 0.618124902, 0.209375009)
Part385.Anchored = true
Part385.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part385.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part385.BrickColor = BrickColor.new("Really black")
Part385.CanCollide = false
Part385.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part385.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part385.Material = Enum.Material.Metal
Part385.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part385.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part385.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part385.brickColor = BrickColor.new("Really black")
SpecialMesh386.Parent = Part385
SpecialMesh386.Scale = Vector3.new(0.400000006, 1, 0.899999976)
SpecialMesh386.MeshType = Enum.MeshType.Brick
Part387.Parent = Model0
Part387.CFrame = CFrame.new(-0.611324251, 3.01513863, -13.8486776, 0.999985635, -0.00162807154, 0.00510659395, 0.00513652945, 0.0189459547, -0.999807417, 0.00153100828, 0.999819279, 0.0189540461)
Part387.Orientation = Vector3.new(88.8799973, 15.0799999, 15.1700001)
Part387.Position = Vector3.new(-0.611324251, 3.01513863, -13.8486776)
Part387.Rotation = Vector3.new(88.909996, 0.289999992, 0.0899999961)
Part387.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part387.Velocity = Vector3.new(9.42162828e-08, 0.00246719248, 1.23810264e-06)
Part387.Size = Vector3.new(0.275000006, 0.200000003, 0.213375002)
Part387.Anchored = true
Part387.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part387.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part387.BrickColor = BrickColor.new("Bright blue")
Part387.CanCollide = false
Part387.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part387.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part387.Material = Enum.Material.Neon
Part387.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part387.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part387.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part387.brickColor = BrickColor.new("Bright blue")
SpecialMesh388.Parent = Part387
SpecialMesh388.Scale = Vector3.new(0.550000012, 0.25, 0.5)
SpecialMesh388.MeshType = Enum.MeshType.Wedge
Part389.Parent = Model0
Part389.CFrame = CFrame.new(-0.615387738, 3.25427985, -11.9957829, -0.999985635, -0.00162816129, -0.00510668149, -0.00513661886, 0.0189460143, 0.999807417, -0.00153109606, 0.999819279, -0.0189541057)
Part389.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part389.Position = Vector3.new(-0.615387738, 3.25427985, -11.9957829)
Part389.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part389.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part389.Velocity = Vector3.new(5.62967202e-08, 0.00247105281, 7.39798622e-07)
Part389.Size = Vector3.new(0.275000006, 0.206125051, 0.280375004)
Part389.Anchored = true
Part389.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part389.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part389.BrickColor = BrickColor.new("Really black")
Part389.CanCollide = false
Part389.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part389.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part389.Material = Enum.Material.Metal
Part389.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part389.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part389.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part389.brickColor = BrickColor.new("Really black")
SpecialMesh390.Parent = Part389
SpecialMesh390.Scale = Vector3.new(0.400000006, 0.560000002, 0.5)
SpecialMesh390.MeshType = Enum.MeshType.Wedge
Part391.Parent = Model0
Part391.CFrame = CFrame.new(-0.614540219, 3.2634635, -12.5800533, -0.999985635, -0.00162816129, -0.00510668149, -0.00513661886, 0.0189460143, 0.999807417, -0.00153109606, 0.999819279, -0.0189541057)
Part391.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part391.Position = Vector3.new(-0.614540219, 3.2634635, -12.5800533)
Part391.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part391.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part391.Velocity = Vector3.new(5.48404984e-08, 0.00246983557, 7.20662456e-07)
Part391.Size = Vector3.new(0.275000006, 0.405125052, 0.211375013)
Part391.Anchored = true
Part391.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part391.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part391.BrickColor = BrickColor.new("Really black")
Part391.CanCollide = false
Part391.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part391.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part391.Material = Enum.Material.Metal
Part391.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part391.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part391.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part391.brickColor = BrickColor.new("Really black")
SpecialMesh392.Parent = Part391
SpecialMesh392.Scale = Vector3.new(0.5, 0.560000002, 0.5)
SpecialMesh392.MeshType = Enum.MeshType.Wedge
Part393.Parent = Model0
Part393.CFrame = CFrame.new(-0.608892262, 2.75060058, -14.5502081, -0.999985635, 0.00114323408, -0.00523646409, -0.00513646565, -0.483495802, 0.8753317, -0.00153109885, 0.875346065, 0.483494699)
Part393.Orientation = Vector3.new(-61.079998, -0.620000005, -179.389999)
Part393.Position = Vector3.new(-0.608892262, 2.75060058, -14.5502081)
Part393.Rotation = Vector3.new(-61.0900002, -0.299999982, -179.929993)
Part393.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part393.Velocity = Vector3.new(1.36162924e-07, 0.00246573123, 1.78932657e-06)
Part393.Size = Vector3.new(0.275000006, 0.409124911, 0.268375039)
Part393.Anchored = true
Part393.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part393.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part393.BrickColor = BrickColor.new("Really black")
Part393.CanCollide = false
Part393.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part393.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part393.Material = Enum.Material.Metal
Part393.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part393.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part393.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part393.brickColor = BrickColor.new("Really black")
SpecialMesh394.Parent = Part393
SpecialMesh394.Scale = Vector3.new(0.349999994, 1, 1)
SpecialMesh394.MeshType = Enum.MeshType.Brick
Part395.Parent = Model0
Part395.CFrame = CFrame.new(-0.606766462, 3.43472743, -18.2343674, 0.999985635, -0.00103941432, 0.00525853038, 0.0051369979, -0.0943565816, -0.99552542, 0.00153093971, 0.995537996, -0.0943498909)
Part395.Orientation = Vector3.new(84.5800018, 176.809998, 176.87999)
Part395.Position = Vector3.new(-0.606766462, 3.43472743, -18.2343674)
Part395.Rotation = Vector3.new(95.409996, 0.299999982, 0.0599999987)
Part395.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part395.Velocity = Vector3.new(2.76838534e-08, 0.00245805481, 3.63795948e-07)
Part395.Size = Vector3.new(0.275000006, 1.04612494, 0.214375019)
Part395.Anchored = true
Part395.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part395.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part395.BrickColor = BrickColor.new("Bright blue")
Part395.CanCollide = false
Part395.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part395.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part395.Material = Enum.Material.Neon
Part395.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part395.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part395.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part395.brickColor = BrickColor.new("Bright blue")
SpecialMesh396.Parent = Part395
SpecialMesh396.Scale = Vector3.new(0.449999988, 0.899999976, 0.100000001)
SpecialMesh396.MeshType = Enum.MeshType.Brick
Part397.Parent = Model0
Part397.CFrame = CFrame.new(-0.638540506, 2.9091177, -16.128315, 0.00135860231, -0.999985635, -0.00518506905, 0.0334058255, -0.00513679488, 0.999428749, -0.999441087, -0.00153103739, 0.0333983675)
Part397.Orientation = Vector3.new(-88.0599976, -8.81999969, 98.7399979)
Part397.Position = Vector3.new(-0.638540506, 2.9091177, -16.128315)
Part397.Rotation = Vector3.new(-88.0899963, -0.299999982, 89.9199982)
Part397.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part397.Velocity = Vector3.new(1.11027532e-07, 0.00246243807, 1.45902084e-06)
Part397.Size = Vector3.new(1.625, 0.200000003, 0.296375006)
Part397.Anchored = true
Part397.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part397.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part397.BrickColor = BrickColor.new("Royal purple")
Part397.CanCollide = false
Part397.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part397.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part397.Material = Enum.Material.Neon
Part397.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part397.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part397.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part397.brickColor = BrickColor.new("Royal purple")
SpecialMesh398.Parent = Part397
SpecialMesh398.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh398.MeshType = Enum.MeshType.Wedge
Part399.Parent = Model0
Part399.CFrame = CFrame.new(-0.614644945, 3.60375571, -13.6545372, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part399.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part399.Position = Vector3.new(-0.614644945, 3.60375571, -13.6545372)
Part399.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part399.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part399.Velocity = Vector3.new(8.81826168e-10, 0.00246759667, 1.1587872e-08)
Part399.Size = Vector3.new(0.275000006, 0.51412493, 0.622375011)
Part399.Anchored = true
Part399.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part399.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part399.BrickColor = BrickColor.new("Really black")
Part399.CanCollide = false
Part399.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part399.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part399.Material = Enum.Material.Metal
Part399.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part399.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part399.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part399.brickColor = BrickColor.new("Really black")
SpecialMesh400.Parent = Part399
SpecialMesh400.Scale = Vector3.new(0.400000006, 1.04999995, 0.5)
SpecialMesh400.MeshType = Enum.MeshType.Brick
Part401.Parent = Model0
Part401.CFrame = CFrame.new(-0.577553451, 2.93009853, -15.210207, -0.00336827105, 0.999985635, -0.0041695768, 0.380026042, 0.00513680326, 0.924961627, 0.924969733, 0.00153097301, -0.380037904)
Part401.Orientation = Vector3.new(-67.659996, -179.369995, 89.2299957)
Part401.Position = Vector3.new(-0.577553451, 2.93009853, -15.210207)
Part401.Rotation = Vector3.new(-112.339996, -0.239999995, -90.1899948)
Part401.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part401.Velocity = Vector3.new(1.07700714e-07, 0.00246436079, 1.41530256e-06)
Part401.Size = Vector3.new(0.288000047, 0.200000003, 0.27837503)
Part401.Anchored = true
Part401.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part401.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part401.BrickColor = BrickColor.new("Royal purple")
Part401.CanCollide = false
Part401.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part401.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part401.Material = Enum.Material.Neon
Part401.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part401.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part401.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part401.brickColor = BrickColor.new("Royal purple")
SpecialMesh402.Parent = Part401
SpecialMesh402.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh402.MeshType = Enum.MeshType.Wedge
Part403.Parent = Model0
Part403.CFrame = CFrame.new(-0.610871017, 3.00987482, -14.1263742, -0.999985635, 0.00162795268, 0.00510695158, -0.00513688475, -0.0189460143, -0.999807417, -0.00153088232, -0.999819279, 0.0189541057)
Part403.Orientation = Vector3.new(88.8799973, 15.0799999, -164.830002)
Part403.Position = Vector3.new(-0.610871017, 3.00987482, -14.1263742)
Part403.Rotation = Vector3.new(88.909996, 0.289999992, -179.909988)
Part403.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part403.Velocity = Vector3.new(9.5050936e-08, 0.00246661413, 1.24907092e-06)
Part403.Size = Vector3.new(0.275000006, 0.207000002, 0.213375002)
Part403.Anchored = true
Part403.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part403.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part403.BrickColor = BrickColor.new("Bright blue")
Part403.CanCollide = false
Part403.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part403.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part403.Material = Enum.Material.Neon
Part403.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part403.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part403.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part403.brickColor = BrickColor.new("Bright blue")
SpecialMesh404.Parent = Part403
SpecialMesh404.Scale = Vector3.new(0.550000012, 0.25, 0.5)
SpecialMesh404.MeshType = Enum.MeshType.Wedge
Part405.Parent = Model0
Part405.CFrame = CFrame.new(-0.576041341, 2.90943861, -16.1282196, -0.00135869172, 0.999985635, -0.00518506905, -0.0334058292, 0.00513679255, 0.999428749, 0.999441028, 0.00153112656, 0.0333983749)
Part405.Orientation = Vector3.new(-88.0599976, -8.81999969, -81.2599945)
Part405.Position = Vector3.new(-0.576041341, 2.90943861, -16.1282196)
Part405.Rotation = Vector3.new(-88.0899963, -0.299999982, -90.0799942)
Part405.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part405.Velocity = Vector3.new(1.10976643e-07, 0.00246244832, 1.45835213e-06)
Part405.Size = Vector3.new(1.625, 0.200000003, 0.296375006)
Part405.Anchored = true
Part405.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part405.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part405.BrickColor = BrickColor.new("Royal purple")
Part405.CanCollide = false
Part405.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part405.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part405.Material = Enum.Material.Neon
Part405.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part405.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part405.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part405.brickColor = BrickColor.new("Royal purple")
SpecialMesh406.Parent = Part405
SpecialMesh406.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh406.MeshType = Enum.MeshType.Wedge
Part407.Parent = Model0
Part407.CFrame = CFrame.new(-0.61728102, 3.21630335, -10.6318092, -0.999985635, -0.00414685067, -0.00339615461, -0.00513672922, 0.560423911, 0.828190207, -0.00153109396, 0.828195751, -0.560437143)
Part407.Orientation = Vector3.new(-55.9099998, -179.649994, -0.529999971)
Part407.Position = Vector3.new(-0.61728102, 3.21630335, -10.6318092)
Part407.Rotation = Vector3.new(-124.089996, -0.189999998, 179.759995)
Part407.Color = Color3.new(0.0509804, 0.411765, 0.67451)
Part407.Velocity = Vector3.new(6.23185059e-08, 0.00247389474, 8.18931142e-07)
Part407.Size = Vector3.new(0.200000003, 0.46875, 0.220999971)
Part407.Anchored = true
Part407.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part407.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part407.BrickColor = BrickColor.new("Bright blue")
Part407.CanCollide = false
Part407.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part407.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part407.Material = Enum.Material.Neon
Part407.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part407.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part407.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part407.brickColor = BrickColor.new("Bright blue")
SpecialMesh408.Parent = Part407
SpecialMesh408.Scale = Vector3.new(0.5, 1, 0.25)
SpecialMesh408.MeshType = Enum.MeshType.Brick
Part409.Parent = Model0
Part409.CFrame = CFrame.new(-0.612716079, 3.04616904, -13.0423889, -0.999985635, -0.00162816129, -0.00510668149, -0.00513661886, 0.0189460143, 0.999807417, -0.00153109606, 0.999819279, -0.0189541057)
Part409.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part409.Position = Vector3.new(-0.612716079, 3.04616904, -13.0423889)
Part409.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part409.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part409.Velocity = Vector3.new(8.92959378e-08, 0.00246887235, 1.17344382e-06)
Part409.Size = Vector3.new(0.275000006, 0.35512504, 0.283374995)
Part409.Anchored = true
Part409.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part409.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part409.BrickColor = BrickColor.new("Really black")
Part409.CanCollide = false
Part409.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part409.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part409.Material = Enum.Material.Metal
Part409.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part409.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part409.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part409.brickColor = BrickColor.new("Really black")
SpecialMesh410.Parent = Part409
SpecialMesh410.Scale = Vector3.new(0.400000006, 0.560000002, 0.5)
SpecialMesh410.MeshType = Enum.MeshType.Wedge
Part411.Parent = Model0
Part411.CFrame = CFrame.new(-0.614045858, 3.38228369, -13.3029222, 0.999985635, 0.00162801193, -0.00510688825, 0.00513682282, -0.0189459547, 0.999807417, 0.00153094309, -0.999819279, -0.0189540461)
Part411.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part411.Position = Vector3.new(-0.614045858, 3.38228369, -13.3029222)
Part411.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part411.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part411.Velocity = Vector3.new(3.59996903e-08, 0.00246832939, 4.73074152e-07)
Part411.Size = Vector3.new(0.275000006, 0.204125047, 0.287375003)
Part411.Anchored = true
Part411.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part411.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part411.BrickColor = BrickColor.new("Really black")
Part411.CanCollide = false
Part411.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part411.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part411.Material = Enum.Material.Metal
Part411.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part411.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part411.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part411.brickColor = BrickColor.new("Really black")
SpecialMesh412.Parent = Part411
SpecialMesh412.Scale = Vector3.new(0.5, 0.5, 0.5)
SpecialMesh412.MeshType = Enum.MeshType.Wedge
Part413.Parent = Model0
Part413.CFrame = CFrame.new(-0.609584808, 2.93011069, -14.6988583, -0.999985635, -0.00476218108, -0.00245960802, -0.00513651408, 0.720367968, 0.693573236, -0.00153109804, 0.693575919, -0.720382035)
Part413.Orientation = Vector3.new(-43.9099998, -179.800003, -0.409999996)
Part413.Position = Vector3.new(-0.609584808, 2.93011069, -14.6988583)
Part413.Rotation = Vector3.new(-136.089996, -0.140000001, 179.729996)
Part413.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part413.Velocity = Vector3.new(1.07698781e-07, 0.00246542133, 1.41527721e-06)
Part413.Size = Vector3.new(0.275000006, 0.484124899, 0.227375031)
Part413.Anchored = true
Part413.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part413.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part413.BrickColor = BrickColor.new("Really black")
Part413.CanCollide = false
Part413.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part413.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part413.Material = Enum.Material.Metal
Part413.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part413.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part413.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part413.brickColor = BrickColor.new("Really black")
SpecialMesh414.Parent = Part413
SpecialMesh414.Scale = Vector3.new(0.349999994, 0.300000012, 1)
SpecialMesh414.MeshType = Enum.MeshType.Brick
Part415.Parent = Model0
Part415.CFrame = CFrame.new(-0.606956184, 3.40465999, -18.0096188, 0.999985635, -0.0010395617, 0.00525854016, 0.00513699278, -0.0943568796, -0.99552542, 0.00153108896, 0.995537996, -0.094350189)
Part415.Orientation = Vector3.new(84.5800018, 176.809998, 176.87999)
Part415.Position = Vector3.new(-0.606956184, 3.40465999, -18.0096188)
Part415.Rotation = Vector3.new(95.409996, 0.299999982, 0.0599999987)
Part415.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part415.Velocity = Vector3.new(3.24515206e-08, 0.00245852303, 4.26448139e-07)
Part415.Size = Vector3.new(0.275000006, 1.46012485, 0.422374964)
Part415.Anchored = true
Part415.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part415.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part415.BrickColor = BrickColor.new("Really black")
Part415.CanCollide = false
Part415.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part415.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part415.Material = Enum.Material.Metal
Part415.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part415.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part415.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part415.brickColor = BrickColor.new("Really black")
SpecialMesh416.Parent = Part415
SpecialMesh416.Scale = Vector3.new(0.400000006, 1, 0.5)
SpecialMesh416.MeshType = Enum.MeshType.Brick
Part417.Parent = Model0
Part417.CFrame = CFrame.new(-0.613238811, 3.32843637, -13.6493177, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part417.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part417.Position = Vector3.new(-0.613238811, 3.32843637, -13.6493177)
Part417.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part417.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part417.Velocity = Vector3.new(4.45380195e-08, 0.00246760761, 5.85277007e-07)
Part417.Size = Vector3.new(0.275000006, 0.320124894, 0.316374987)
Part417.Anchored = true
Part417.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part417.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part417.BrickColor = BrickColor.new("Royal purple")
Part417.CanCollide = false
Part417.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part417.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part417.Material = Enum.Material.Neon
Part417.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part417.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part417.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part417.brickColor = BrickColor.new("Royal purple")
SpecialMesh418.Parent = Part417
SpecialMesh418.Scale = Vector3.new(0.457500011, 1, 1)
SpecialMesh418.MeshType = Enum.MeshType.Cylinder
Part419.Parent = Model0
Part419.CFrame = CFrame.new(-0.616606832, 3.19626212, -11.004673, -0.999985635, -0.000250895391, -0.00535403285, -0.00513659744, -0.24046874, 0.970643461, -0.001531007, 0.970656931, 0.240463987)
Part419.Orientation = Vector3.new(-76.0800018, -1.27999997, -178.779999)
Part419.Position = Vector3.new(-0.616606832, 3.19626212, -11.004673)
Part419.Rotation = Vector3.new(-76.0899963, -0.310000002, 179.98999)
Part419.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part419.Velocity = Vector3.new(6.54963515e-08, 0.00247311778, 8.606915e-07)
Part419.Size = Vector3.new(0.275000006, 0.418250024, 0.25)
Part419.Anchored = true
Part419.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part419.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part419.BrickColor = BrickColor.new("Really black")
Part419.CanCollide = false
Part419.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part419.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part419.Material = Enum.Material.Metal
Part419.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part419.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part419.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part419.brickColor = BrickColor.new("Really black")
SpecialMesh420.Parent = Part419
SpecialMesh420.Scale = Vector3.new(0.5, 1, 0.25)
SpecialMesh420.MeshType = Enum.MeshType.Brick
Part421.Parent = Model0
Part421.CFrame = CFrame.new(-0.610599458, 3.09770298, -14.5984182, -0.999985635, 0.00510674436, -0.0016279578, -0.00513667939, -0.999807417, 0.0189470276, -0.00153088616, 0.018955119, 0.999819279)
Part421.Orientation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part421.Position = Vector3.new(-0.610599458, 3.09770298, -14.5984182)
Part421.Rotation = Vector3.new(-1.09000003, -0.0899999961, -179.709991)
Part421.Color = Color3.new(0.972549, 0.972549, 0.972549)
Part421.Velocity = Vector3.new(8.1124405e-08, 0.00246563042, 1.06606149e-06)
Part421.Size = Vector3.new(0.275000006, 0.200124964, 0.287375033)
Part421.Anchored = true
Part421.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part421.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part421.BrickColor = BrickColor.new("Institutional white")
Part421.CanCollide = false
Part421.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part421.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part421.Material = Enum.Material.Metal
Part421.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part421.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part421.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part421.brickColor = BrickColor.new("Institutional white")
SpecialMesh422.Parent = Part421
SpecialMesh422.Scale = Vector3.new(0.560000002, 1, 0.899999976)
SpecialMesh422.MeshType = Enum.MeshType.Wedge
Part423.Parent = Model0
Part423.CFrame = CFrame.new(-0.608857095, 2.56135106, -13.9388657, -0.999985635, -0.00289438874, -0.00451127253, -0.00513661513, 0.277069688, 0.960836291, -0.00153109606, 0.96084559, -0.277080595)
Part423.Orientation = Vector3.new(-73.909996, -179.069992, -1.05999994)
Part423.Position = Vector3.new(-0.608857095, 2.56135106, -13.9388657)
Part423.Rotation = Vector3.new(-106.089996, -0.25999999, 179.830002)
Part423.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part423.Velocity = Vector3.new(1.66171404e-07, 0.00246700505, 2.18366995e-06)
Part423.Size = Vector3.new(0.275000006, 0.409124941, 0.360375017)
Part423.Anchored = true
Part423.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part423.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part423.BrickColor = BrickColor.new("Really black")
Part423.CanCollide = false
Part423.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part423.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part423.Material = Enum.Material.Metal
Part423.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part423.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part423.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part423.brickColor = BrickColor.new("Really black")
SpecialMesh424.Parent = Part423
SpecialMesh424.Scale = Vector3.new(0.349999994, 1, 1)
SpecialMesh424.MeshType = Enum.MeshType.Brick
Part425.Parent = Model0
Part425.CFrame = CFrame.new(-0.610883415, 2.94288707, -13.8941879, -0.999985635, -0.00162807154, -0.00510650687, -0.00513644237, 0.0189459547, 0.999807417, -0.00153100991, 0.999819279, -0.0189540461)
Part425.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part425.Position = Vector3.new(-0.610883415, 2.94288707, -13.8941879)
Part425.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part425.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part425.Velocity = Vector3.new(1.05672896e-07, 0.00246709795, 1.38865482e-06)
Part425.Size = Vector3.new(0.275000006, 0.228, 0.213375002)
Part425.Anchored = true
Part425.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part425.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part425.BrickColor = BrickColor.new("Really black")
Part425.CanCollide = false
Part425.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part425.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part425.Material = Enum.Material.Metal
Part425.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part425.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part425.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part425.brickColor = BrickColor.new("Really black")
SpecialMesh426.Parent = Part425
SpecialMesh426.Scale = Vector3.new(0.569999993, 0.125, 0.375)
SpecialMesh426.MeshType = Enum.MeshType.Wedge
Part427.Parent = Model0
Part427.CFrame = CFrame.new(-0.612252593, 3.11727381, -13.584939, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part427.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part427.Position = Vector3.new(-0.612252593, 3.11727381, -13.584939)
Part427.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part427.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part427.Velocity = Vector3.new(7.80211593e-08, 0.00246774196, 1.02528122e-06)
Part427.Size = Vector3.new(0.275000006, 0.398124993, 0.303375006)
Part427.Anchored = true
Part427.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part427.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part427.BrickColor = BrickColor.new("Really black")
Part427.CanCollide = false
Part427.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part427.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part427.Material = Enum.Material.Metal
Part427.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part427.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part427.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part427.brickColor = BrickColor.new("Really black")
SpecialMesh428.Parent = Part427
SpecialMesh428.Scale = Vector3.new(0.5, 1, 1)
SpecialMesh428.MeshType = Enum.MeshType.Brick
Part429.Parent = Model0
Part429.CFrame = CFrame.new(-0.612551332, 3.35195827, -14.1766062, 0.999985635, 0.0047621401, -0.00246015727, 0.00513686566, -0.720367908, 0.693573296, 0.00153067405, -0.693575978, -0.720381975)
Part429.Orientation = Vector3.new(-43.9099998, -179.800003, 179.589996)
Part429.Position = Vector3.new(-0.612551332, 3.35195827, -14.1766062)
Part429.Rotation = Vector3.new(-136.089996, -0.140000001, -0.269999981)
Part429.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part429.Velocity = Vector3.new(4.08082492e-08, 0.00246650912, 5.36263883e-07)
Part429.Size = Vector3.new(0.275000006, 0.331124961, 0.412375003)
Part429.Anchored = true
Part429.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part429.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part429.BrickColor = BrickColor.new("Really black")
Part429.CanCollide = false
Part429.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part429.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part429.Material = Enum.Material.Metal
Part429.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part429.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part429.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part429.brickColor = BrickColor.new("Really black")
SpecialMesh430.Parent = Part429
SpecialMesh430.Scale = Vector3.new(0.5, 1.04999995, 0.5)
SpecialMesh430.MeshType = Enum.MeshType.Brick
Part431.Parent = Model0
Part431.CFrame = CFrame.new(-0.578086436, 2.53643656, -13.5418949, -0.00476215873, 0.999985635, -0.00245991186, 0.72036773, 0.00513670826, 0.693573475, 0.693576157, 0.00153086532, -0.720381796)
Part431.Orientation = Vector3.new(-43.9099998, -179.800003, 89.5899963)
Part431.Position = Vector3.new(-0.578086436, 2.53643656, -13.5418949)
Part431.Rotation = Vector3.new(-136.089996, -0.140000001, -90.2699966)
Part431.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part431.Velocity = Vector3.new(1.70122007e-07, 0.00246783718, 2.23558482e-06)
Part431.Size = Vector3.new(0.421999991, 0.200000003, 0.280375004)
Part431.Anchored = true
Part431.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part431.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part431.BrickColor = BrickColor.new("Royal purple")
Part431.CanCollide = false
Part431.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part431.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part431.Material = Enum.Material.Neon
Part431.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part431.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part431.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part431.brickColor = BrickColor.new("Royal purple")
SpecialMesh432.Parent = Part431
SpecialMesh432.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh432.MeshType = Enum.MeshType.Wedge
Part433.Parent = Model0
Part433.CFrame = CFrame.new(-0.647041559, 3.82817221, -13.658843, -0.00162801228, -0.999985635, 0.00510653481, 0.0189460143, -0.00513646938, -0.999807417, 0.999819279, -0.00153094972, 0.0189541057)
Part433.Orientation = Vector3.new(88.8799973, 15.0799999, 105.169998)
Part433.Position = Vector3.new(-0.647041559, 3.82817221, -13.658843)
Part433.Rotation = Vector3.new(88.909996, 0.289999992, 90.0899963)
Part433.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part433.Velocity = Vector3.new(-3.47029321e-08, 0.00246758247, -4.56033831e-07)
Part433.Size = Vector3.new(0.643000007, 0.200000003, 0.280375004)
Part433.Anchored = true
Part433.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part433.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part433.BrickColor = BrickColor.new("Royal purple")
Part433.CanCollide = false
Part433.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part433.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part433.Material = Enum.Material.Neon
Part433.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part433.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part433.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part433.brickColor = BrickColor.new("Royal purple")
SpecialMesh434.Parent = Part433
SpecialMesh434.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh434.MeshType = Enum.MeshType.Wedge
Part435.Parent = Model0
Part435.CFrame = CFrame.new(-0.610847712, 3.10699439, -14.4674244, 0.999985635, 0.00345827825, -0.00409521349, 0.00513684051, -0.400113374, 0.916451454, 0.00153079373, -0.916459262, -0.400125414)
Part435.Orientation = Vector3.new(-66.409996, -179.409988, 179.259995)
Part435.Position = Vector3.new(-0.610847712, 3.10699439, -14.4674244)
Part435.Rotation = Vector3.new(-113.589996, -0.229999989, -0.199999988)
Part435.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part435.Velocity = Vector3.new(7.96511017e-08, 0.00246590329, 1.04670062e-06)
Part435.Size = Vector3.new(0.275000006, 0.23712492, 0.375375003)
Part435.Anchored = true
Part435.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part435.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part435.BrickColor = BrickColor.new("Royal purple")
Part435.CanCollide = false
Part435.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part435.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part435.Material = Enum.Material.Neon
Part435.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part435.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part435.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part435.brickColor = BrickColor.new("Royal purple")
SpecialMesh436.Parent = Part435
SpecialMesh436.Scale = Vector3.new(0.524999976, 1.04999995, 0.800000012)
SpecialMesh436.MeshType = Enum.MeshType.Brick
Part437.Parent = Model0
Part437.CFrame = CFrame.new(-0.583012402, 3.6639781, -14.1030874, 0.00476215919, 0.999985635, 0.00246015075, -0.720367849, 0.0051368745, -0.693573356, -0.693576038, 0.00153069268, 0.720381975)
Part437.Orientation = Vector3.new(43.9099998, 0.199999988, -89.5899963)
Part437.Position = Vector3.new(-0.583012402, 3.6639781, -14.1030874)
Part437.Rotation = Vector3.new(43.9099998, 0.140000001, -89.7299957)
Part437.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part437.Velocity = Vector3.new(-8.66738503e-09, 0.00246666698, -1.13898864e-07)
Part437.Size = Vector3.new(0.496000022, 0.200000003, 0.280375004)
Part437.Anchored = true
Part437.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part437.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part437.BrickColor = BrickColor.new("Royal purple")
Part437.CanCollide = false
Part437.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part437.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part437.Material = Enum.Material.Neon
Part437.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part437.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part437.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part437.brickColor = BrickColor.new("Royal purple")
SpecialMesh438.Parent = Part437
SpecialMesh438.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh438.MeshType = Enum.MeshType.Wedge
Part439.Parent = Model0
Part439.CFrame = CFrame.new(-0.609243929, 2.84955072, -14.6524963, -0.999985635, -0.00162816211, -0.00510652829, -0.00513646565, 0.0189461932, 0.999807417, -0.00153109885, 0.999819279, -0.0189542845)
Part439.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part439.Position = Vector3.new(-0.609243929, 2.84955072, -14.6524963)
Part439.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part439.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part439.Velocity = Vector3.new(1.20472833e-07, 0.00246551796, 1.58314185e-06)
Part439.Size = Vector3.new(0.275000006, 0.287124902, 0.227375031)
Part439.Anchored = true
Part439.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part439.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part439.BrickColor = BrickColor.new("Really black")
Part439.CanCollide = false
Part439.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part439.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part439.Material = Enum.Material.Metal
Part439.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part439.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part439.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part439.brickColor = BrickColor.new("Really black")
SpecialMesh440.Parent = Part439
SpecialMesh440.Scale = Vector3.new(0.349999994, 1, 1)
SpecialMesh440.MeshType = Enum.MeshType.Brick
Part441.Parent = Model0
Part441.CFrame = CFrame.new(-0.610548377, 2.83942795, -13.765955, -0.999985635, -0.00162816129, -0.00510662561, -0.00513656298, 0.0189460143, 0.999807417, -0.00153109711, 0.999819279, -0.0189541057)
Part441.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part441.Position = Vector3.new(-0.610548377, 2.83942795, -13.765955)
Part441.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part441.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part441.Velocity = Vector3.new(1.22077964e-07, 0.002467365, 1.60423497e-06)
Part441.Size = Vector3.new(0.275000006, 0.304124922, 0.267374992)
Part441.Anchored = true
Part441.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part441.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part441.BrickColor = BrickColor.new("Really black")
Part441.CanCollide = false
Part441.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part441.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part441.Material = Enum.Material.Metal
Part441.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part441.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part441.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part441.brickColor = BrickColor.new("Really black")
SpecialMesh442.Parent = Part441
SpecialMesh442.Scale = Vector3.new(0.495000005, 1, 1)
SpecialMesh442.MeshType = Enum.MeshType.Wedge
Part443.Parent = Model0
Part443.CFrame = CFrame.new(-0.584542513, 3.82849336, -13.6587467, 0.00162807188, 0.999985635, 0.00510653481, -0.0189460143, 0.00513647031, -0.999807417, -0.999819279, 0.00153100933, 0.0189541057)
Part443.Orientation = Vector3.new(88.8799973, 15.0799999, -74.8300018)
Part443.Position = Vector3.new(-0.584542513, 3.82849336, -13.6587467)
Part443.Rotation = Vector3.new(88.909996, 0.289999992, -89.909996)
Part443.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part443.Velocity = Vector3.new(-3.47538496e-08, 0.00246759271, -4.56702992e-07)
Part443.Size = Vector3.new(0.643000007, 0.200000003, 0.280375004)
Part443.Anchored = true
Part443.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part443.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part443.BrickColor = BrickColor.new("Royal purple")
Part443.CanCollide = false
Part443.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part443.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part443.Material = Enum.Material.Neon
Part443.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part443.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part443.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part443.brickColor = BrickColor.new("Royal purple")
SpecialMesh444.Parent = Part443
SpecialMesh444.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh444.MeshType = Enum.MeshType.Wedge
Part445.Parent = Model0
Part445.CFrame = CFrame.new(-0.618139863, 3.39627433, -10.6743059, 0.999985635, -0.0024899696, 0.00474630948, 0.00513651408, 0.192273051, -0.981328189, 0.00153088931, 0.981338441, 0.192283079)
Part445.Orientation = Vector3.new(78.909996, 1.40999997, 1.52999997)
Part445.Position = Vector3.new(-0.618139863, 3.39627433, -10.6743059)
Part445.Rotation = Vector3.new(78.909996, 0.269999981, 0.140000001)
Part445.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part445.Velocity = Vector3.new(3.37812835e-08, 0.00247380603, 4.43921522e-07)
Part445.Size = Vector3.new(0.275000006, 0.28125, 0.234375)
Part445.Anchored = true
Part445.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part445.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part445.BrickColor = BrickColor.new("Really black")
Part445.CanCollide = false
Part445.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part445.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part445.Material = Enum.Material.Metal
Part445.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part445.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part445.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part445.brickColor = BrickColor.new("Really black")
SpecialMesh446.Parent = Part445
SpecialMesh446.Scale = Vector3.new(0.5, 1.04999995, 0.400000006)
SpecialMesh446.MeshType = Enum.MeshType.Brick
Part447.Parent = Model0
Part447.CFrame = CFrame.new(-0.612165928, 3.04279852, -13.3917465, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part447.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part447.Position = Vector3.new(-0.612165928, 3.04279852, -13.3917465)
Part447.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part447.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part447.Velocity = Vector3.new(8.98303796e-08, 0.00246814452, 1.18046705e-06)
Part447.Size = Vector3.new(0.275000006, 0.577124953, 0.303375006)
Part447.Anchored = true
Part447.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part447.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part447.BrickColor = BrickColor.new("Really black")
Part447.CanCollide = false
Part447.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part447.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part447.Material = Enum.Material.Metal
Part447.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part447.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part447.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part447.brickColor = BrickColor.new("Really black")
SpecialMesh448.Parent = Part447
SpecialMesh448.Scale = Vector3.new(0.400000006, 0.870000005, 0.5)
SpecialMesh448.MeshType = Enum.MeshType.Brick
Part449.Parent = Model0
Part449.CFrame = CFrame.new(-0.576728344, 2.5984447, -14.6364422, 0.00114334025, 0.999985635, -0.00523668947, -0.483495861, 0.00513671385, 0.8753317, 0.875346005, 0.00153111527, 0.483494759)
Part449.Orientation = Vector3.new(-61.079998, -0.620000005, -89.3899994)
Part449.Position = Vector3.new(-0.576728344, 2.5984447, -14.6364422)
Part449.Rotation = Vector3.new(-61.0900002, -0.299999982, -89.9300003)
Part449.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part449.Velocity = Vector3.new(1.6028963e-07, 0.00246555661, 2.10637722e-06)
Part449.Size = Vector3.new(0.423000038, 0.200000003, 0.280375004)
Part449.Anchored = true
Part449.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part449.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part449.BrickColor = BrickColor.new("Royal purple")
Part449.CanCollide = false
Part449.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part449.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part449.Material = Enum.Material.Neon
Part449.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part449.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part449.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part449.brickColor = BrickColor.new("Royal purple")
SpecialMesh450.Parent = Part449
SpecialMesh450.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh450.MeshType = Enum.MeshType.Wedge
Part451.Parent = Model0
Part451.CFrame = CFrame.new(-0.611472607, 3.24456573, -14.520874, -0.999985635, 0.000250921701, 0.00535428664, -0.00513683865, 0.240468413, -0.970643461, -0.00153109187, -0.970656991, -0.240463659)
Part451.Orientation = Vector3.new(76.0800018, 178.720001, -1.22000003)
Part451.Position = Vector3.new(-0.611472607, 3.24456573, -14.520874)
Part451.Rotation = Vector3.new(103.909996, 0.310000002, -179.98999)
Part451.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part451.Velocity = Vector3.new(5.78370134e-08, 0.002465792, 7.60040166e-07)
Part451.Size = Vector3.new(0.275000006, 0.221124932, 0.408374965)
Part451.Anchored = true
Part451.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part451.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part451.BrickColor = BrickColor.new("Really black")
Part451.CanCollide = false
Part451.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part451.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part451.Material = Enum.Material.Metal
Part451.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part451.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part451.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part451.brickColor = BrickColor.new("Really black")
SpecialMesh452.Parent = Part451
SpecialMesh452.Scale = Vector3.new(0.550000012, 1.04999995, 0.800000012)
SpecialMesh452.MeshType = Enum.MeshType.Brick
Part453.Parent = Model0
Part453.CFrame = CFrame.new(-0.610993803, 3.15083313, -14.5190973, 0.999985635, 0.00289416499, -0.00451159757, 0.00513686473, -0.2770693, 0.960836351, 0.00153079326, -0.960845709, -0.277080178)
Part453.Orientation = Vector3.new(-73.909996, -179.069992, 178.940002)
Part453.Position = Vector3.new(-0.610993803, 3.15083313, -14.5190973)
Part453.Rotation = Vector3.new(-106.089996, -0.25999999, -0.170000002)
Part453.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part453.Velocity = Vector3.new(7.26997911e-08, 0.00246579573, 9.55352903e-07)
Part453.Size = Vector3.new(0.275000006, 0.221124932, 0.408374965)
Part453.Anchored = true
Part453.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part453.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part453.BrickColor = BrickColor.new("Really black")
Part453.CanCollide = false
Part453.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part453.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part453.Material = Enum.Material.Metal
Part453.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part453.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part453.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part453.brickColor = BrickColor.new("Really black")
SpecialMesh454.Parent = Part453
SpecialMesh454.Scale = Vector3.new(0.550000012, 1.04999995, 0.800000012)
SpecialMesh454.MeshType = Enum.MeshType.Brick
Part455.Parent = Model0
Part455.CFrame = CFrame.new(-0.609657764, 2.72515392, -13.9643335, -0.999985635, -0.00162816129, -0.00510662561, -0.00513656298, 0.0189460143, 0.999807417, -0.00153109711, 0.999819279, -0.0189541057)
Part455.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part455.Position = Vector3.new(-0.609657764, 2.72515392, -13.9643335)
Part455.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part455.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part455.Velocity = Vector3.new(1.40197898e-07, 0.00246695196, 1.84235034e-06)
Part455.Size = Vector3.new(0.275000006, 0.330124915, 0.226374999)
Part455.Anchored = true
Part455.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part455.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part455.BrickColor = BrickColor.new("Really black")
Part455.CanCollide = false
Part455.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part455.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part455.Material = Enum.Material.Glass
Part455.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part455.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part455.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part455.brickColor = BrickColor.new("Really black")
SpecialMesh456.Parent = Part455
SpecialMesh456.Scale = Vector3.new(0.400000006, 1, 1)
SpecialMesh456.MeshType = Enum.MeshType.Brick
Part457.Parent = Model0
Part457.CFrame = CFrame.new(-0.577368915, 2.78939152, -14.8586674, 0.00361127499, 0.999985635, -0.00396134611, -0.85638535, 0.00513800606, 0.516312063, 0.516324997, 0.00152789324, 0.856391609)
Part457.Orientation = Vector3.new(-31.0900002, -0.269999981, -89.659996)
Part457.Position = Vector3.new(-0.577368915, 2.78939152, -14.8586674)
Part457.Rotation = Vector3.new(-31.0900002, -0.229999989, -89.7900009)
Part457.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part457.Velocity = Vector3.new(1.30012012e-07, 0.00246509351, 1.70849694e-06)
Part457.Size = Vector3.new(0.293000042, 0.200000003, 0.280375004)
Part457.Anchored = true
Part457.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part457.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part457.BrickColor = BrickColor.new("Royal purple")
Part457.CanCollide = false
Part457.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part457.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part457.Material = Enum.Material.Neon
Part457.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part457.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part457.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part457.brickColor = BrickColor.new("Royal purple")
SpecialMesh458.Parent = Part457
SpecialMesh458.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh458.MeshType = Enum.MeshType.Wedge
Part459.Parent = Model0
Part459.CFrame = CFrame.new(-0.611768007, 3.29040194, -14.4816895, -0.999985635, -0.00045009004, 0.00534120994, -0.00513681443, 0.36510545, -0.930952132, -0.00153109233, -0.930966198, -0.3651025)
Part459.Orientation = Vector3.new(68.5800018, 179.159988, -0.810000002)
Part459.Position = Vector3.new(-0.611768007, 3.29040194, -14.4816895)
Part459.Rotation = Vector3.new(111.409996, 0.310000002, 179.970001)
Part459.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part459.Velocity = Vector3.new(5.05689677e-08, 0.00246587349, 6.64530262e-07)
Part459.Size = Vector3.new(0.275000006, 0.238124937, 0.381375015)
Part459.Anchored = true
Part459.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part459.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part459.BrickColor = BrickColor.new("Royal purple")
Part459.CanCollide = false
Part459.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part459.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part459.Material = Enum.Material.Neon
Part459.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part459.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part459.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part459.brickColor = BrickColor.new("Royal purple")
SpecialMesh460.Parent = Part459
SpecialMesh460.Scale = Vector3.new(0.524999976, 1.04999995, 0.800000012)
SpecialMesh460.MeshType = Enum.MeshType.Brick
Part461.Parent = Model0
Part461.CFrame = CFrame.new(-0.605971158, 3.45052385, -18.8064079, -0.999985635, 0.00474059395, 0.00250087585, -0.00513641909, -0.714288056, -0.699833155, -0.00153127871, -0.699835896, 0.714302182)
Part461.Orientation = Vector3.new(44.4099998, 0.199999988, -179.589996)
Part461.Position = Vector3.new(-0.605971158, 3.45052385, -18.8064079)
Part461.Rotation = Vector3.new(44.4099998, 0.140000001, -179.729996)
Part461.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part461.Velocity = Vector3.new(2.51790748e-08, 0.00245686295, 3.30880596e-07)
Part461.Size = Vector3.new(0.275000006, 0.235124931, 0.586375237)
Part461.Anchored = true
Part461.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part461.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part461.BrickColor = BrickColor.new("Really black")
Part461.CanCollide = false
Part461.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part461.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part461.Material = Enum.Material.Metal
Part461.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part461.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part461.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part461.brickColor = BrickColor.new("Really black")
SpecialMesh462.Parent = Part461
SpecialMesh462.Scale = Vector3.new(0.400000006, 1.04999995, 1)
SpecialMesh462.MeshType = Enum.MeshType.Brick
Part463.Parent = Model0
Part463.CFrame = CFrame.new(-0.610880256, 2.96906447, -13.9840736, -0.999985635, -0.00162807154, -0.00510650687, -0.00513644237, 0.0189459547, 0.999807417, -0.00153100991, 0.999819279, -0.0189540461)
Part463.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part463.Position = Vector3.new(-0.610880256, 2.96906447, -13.9840736)
Part463.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part463.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part463.Velocity = Vector3.new(1.01522062e-07, 0.00246691052, 1.33410845e-06)
Part463.Size = Vector3.new(0.275000006, 0.239124984, 0.303375006)
Part463.Anchored = true
Part463.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part463.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part463.BrickColor = BrickColor.new("Really black")
Part463.CanCollide = false
Part463.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part463.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part463.Material = Enum.Material.Glass
Part463.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part463.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part463.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part463.brickColor = BrickColor.new("Really black")
SpecialMesh464.Parent = Part463
SpecialMesh464.Scale = Vector3.new(0.524999976, 1, 1)
SpecialMesh464.MeshType = Enum.MeshType.Brick
Part465.Parent = Model0
Part465.CFrame = CFrame.new(-0.63922745, 2.59812379, -14.6365376, -0.00114342954, -0.999985635, -0.00523668341, 0.483495861, -0.00513675157, 0.8753317, -0.875346065, -0.00153103401, 0.483494759)
Part465.Orientation = Vector3.new(-61.079998, -0.620000005, 90.6100006)
Part465.Position = Vector3.new(-0.63922745, 2.59812379, -14.6365376)
Part465.Rotation = Vector3.new(-61.0900002, -0.299999982, 90.0699997)
Part465.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part465.Velocity = Vector3.new(1.6034052e-07, 0.0024655466, 2.10704593e-06)
Part465.Size = Vector3.new(0.423000038, 0.200000003, 0.280375004)
Part465.Anchored = true
Part465.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part465.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part465.BrickColor = BrickColor.new("Royal purple")
Part465.CanCollide = false
Part465.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part465.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part465.Material = Enum.Material.Neon
Part465.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part465.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part465.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part465.brickColor = BrickColor.new("Royal purple")
SpecialMesh466.Parent = Part465
SpecialMesh466.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh466.MeshType = Enum.MeshType.Wedge
Part467.Parent = Model0
Part467.CFrame = CFrame.new(-0.63986814, 2.78907037, -14.8587627, -0.0036113495, -0.999985635, -0.00396139733, 0.85638535, -0.00513809687, 0.516312063, -0.516324997, -0.0015278986, 0.856391549)
Part467.Orientation = Vector3.new(-31.0900002, -0.269999981, 90.3399963)
Part467.Position = Vector3.new(-0.63986814, 2.78907037, -14.8587627)
Part467.Rotation = Vector3.new(-31.0900002, -0.229999989, 90.2099991)
Part467.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part467.Velocity = Vector3.new(1.30062929e-07, 0.00246508326, 1.70916621e-06)
Part467.Size = Vector3.new(0.293000042, 0.200000003, 0.280375004)
Part467.Anchored = true
Part467.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part467.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part467.BrickColor = BrickColor.new("Royal purple")
Part467.CanCollide = false
Part467.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part467.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part467.Material = Enum.Material.Neon
Part467.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part467.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part467.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part467.brickColor = BrickColor.new("Royal purple")
SpecialMesh468.Parent = Part467
SpecialMesh468.Scale = Vector3.new(1, 0.300000012, 0.5)
SpecialMesh468.MeshType = Enum.MeshType.Wedge
Part469.Parent = Model0
Part469.CFrame = CFrame.new(-0.610184669, 2.95239902, -14.3818283, 0.999985635, 0.00162795268, -0.00510686403, 0.0051367972, -0.0189460143, 0.999807417, 0.00153088395, -0.999819279, -0.0189541057)
Part469.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part469.Position = Vector3.new(-0.610184669, 2.95239902, -14.3818283)
Part469.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part469.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part469.Velocity = Vector3.new(1.04164627e-07, 0.00246608187, 1.36883455e-06)
Part469.Size = Vector3.new(0.275000006, 0.410999984, 0.469375014)
Part469.Anchored = true
Part469.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part469.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part469.BrickColor = BrickColor.new("Really black")
Part469.CanCollide = false
Part469.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part469.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part469.Material = Enum.Material.Glass
Part469.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part469.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part469.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part469.brickColor = BrickColor.new("Really black")
SpecialMesh470.Parent = Part469
SpecialMesh470.Scale = Vector3.new(0.5, 0.850000024, 0.699999988)
SpecialMesh470.MeshType = Enum.MeshType.Brick
Part471.Parent = Model0
Part471.CFrame = CFrame.new(-0.613238811, 3.32843637, -13.6493177, -0.999985635, -0.00162807142, -0.00510653527, -0.00513647031, 0.0189459249, 0.999807417, -0.00153100933, 0.999819279, -0.0189540163)
Part471.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part471.Position = Vector3.new(-0.613238811, 3.32843637, -13.6493177)
Part471.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part471.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part471.Velocity = Vector3.new(4.45380195e-08, 0.00246760761, 5.85277007e-07)
Part471.Size = Vector3.new(0.275000006, 0.698124886, 0.638374984)
Part471.Anchored = true
Part471.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part471.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part471.BrickColor = BrickColor.new("Really black")
Part471.CanCollide = false
Part471.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part471.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part471.Material = Enum.Material.Glass
Part471.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part471.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part471.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part471.brickColor = BrickColor.new("Really black")
SpecialMesh472.Parent = Part471
SpecialMesh472.Scale = Vector3.new(0.449999988, 1, 1)
SpecialMesh472.MeshType = Enum.MeshType.Cylinder
Part473.Parent = Model0
Part473.CFrame = CFrame.new(-0.618369102, 3.23987865, -11.0925436, 0.999985635, 0.00162807235, -0.00510680024, 0.0051367362, -0.0189461038, 0.999807417, 0.00153100432, -0.999819279, -0.0189541951)
Part473.Orientation = Vector3.new(-88.8799973, -164.919998, 164.830002)
Part473.Position = Vector3.new(-0.618369102, 3.23987865, -11.0925436)
Part473.Rotation = Vector3.new(-91.0899963, -0.289999992, -0.0899999961)
Part473.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part473.Velocity = Vector3.new(5.85802624e-08, 0.00247293455, 7.69806775e-07)
Part473.Size = Vector3.new(0.25999999, 0.578125, 0.21875)
Part473.Anchored = true
Part473.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part473.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part473.BrickColor = BrickColor.new("Really black")
Part473.CanCollide = false
Part473.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part473.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part473.Material = Enum.Material.Metal
Part473.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part473.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part473.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part473.brickColor = BrickColor.new("Really black")
SpecialMesh474.Parent = Part473
SpecialMesh474.Scale = Vector3.new(0.300000012, 1, 1)
SpecialMesh474.MeshType = Enum.MeshType.Wedge
Part475.Name = "TrueHandle"
Part475.Parent = Model0
Part475.CFrame = CFrame.new(-0.615642607, 3.34541011, -12.1349049, -0.999985635, -0.00162807154, -0.00510656228, -0.00513649778, 0.0189459547, 0.999807417, -0.00153100886, 0.999819279, -0.0189540461)
Part475.Orientation = Vector3.new(-88.8799973, -164.919998, -15.1700001)
Part475.Position = Vector3.new(-0.615642607, 3.34541011, -12.1349049)
Part475.Rotation = Vector3.new(-91.0899963, -0.289999992, 179.909988)
Part475.Color = Color3.new(0.803922, 0.803922, 0.803922)
Part475.Velocity = Vector3.new(4.18465866e-08, 0.00247076293, 5.49908464e-07)
Part475.Size = Vector3.new(0.275000006, 1.73512506, 0.280375004)
Part475.Anchored = true
Part475.BackSurface = Enum.SurfaceType.SmoothNoOutlines
Part475.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part475.BrickColor = BrickColor.new("Mid gray")
Part475.CanCollide = false
Part475.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
Part475.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
Part475.Material = Enum.Material.Metal
Part475.RightSurface = Enum.SurfaceType.SmoothNoOutlines
Part475.RotVelocity = Vector3.new(-2.08372262e-06, 1.18487212e-14, 1.58565669e-07)
Part475.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part475.brickColor = BrickColor.new("Mid gray")
SpecialMesh476.Parent = Part475
SpecialMesh476.Scale = Vector3.new(0.349999994, 1.04999995, 0.5)
SpecialMesh476.MeshType = Enum.MeshType.Brick
for i,v in pairs(mas:GetChildren()) do
	v.Parent = game:GetService("Players").LocalPlayer.Character
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
	spawn(function()
		pcall(v)
	end)
end
for i,v in pairs(Model0:GetChildren()) do
	if v:IsA("Part") then
        v.Locked = true
		v.Anchored = false
        v.CanCollide = false
	end
end
if not OldModel then
	Model0:Destroy()
end

plr = game:GetService("Players").LocalPlayer
char = playerss
hum = char.Humanoid
local cam = game.Workspace.CurrentCamera
t = char.Torso
h = char.Head
ra = char["Right Arm"]
la = char["Left Arm"]
rl = char["Right Leg"]
ll = char["Left Leg"]
tors = char.Torso
lleg = char["Left Leg"]
root = char.HumanoidRootPart
hed = char.Head
rleg = char["Right Leg"]
rarm = char["Right Arm"]
larm = char["Left Arm"]
it = Instance.new
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
cf = CFrame.new
ceuler = CFrame.fromEulerAnglesXYZ

local muter = false
local ORGID = 5801326053
local ORVOL = 8
local ORPIT = 0.85
local kan = Instance.new("Sound",char)
kan.Volume = 0
if not NoSound then
	kan.Volume = 6
end
kan.TimePosition = 0
kan.PlaybackSpeed = 1.01
kan.Pitch = 0.9
kan.SoundId = "rbxassetid://5801326053"
kan.Name = "nepnepnep"
kan.Looped = true
kan:Play()

local BanishMode = 1

function CameraShake(Times, Power)
coroutine.resume(coroutine.create(function()
FV = Instance.new("BoolValue", Character)
FV.Name = "CameraShake"
for ShakeNum=1,Times do
swait()
local ef=Power
  if ef>=1 then
   Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
  else
   ef=Power*10
   Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
  end	
end
Humanoid.CameraOffset = Vector3.new(0,0,0)
FV:Destroy()
end))
end

CamShake=function(Part,Distan,Power,Times) 
local de=Part.Position
for i,v in pairs(workspace:children()) do
 if v:IsA("Model") and v:findFirstChild("Humanoid") then
for _,c in pairs(v:children()) do
if c.ClassName=="Part" and (c.Position - de).magnitude < Distan then
local Noob=v.Humanoid
if Noob~=nil then
if Noob:FindFirstChild("CamShake")==nil then-- and Noob == Character then
--[[local ss=script.CamShake:clone()
ss.Parent=Noob
ss.Power.Value=Power
ss.Times.Value=Times
ss.Disabled=false]]
CameraShake(Times, Power)
end
end
end
end
end
end
end

function chatfunc(text,color,typet,font,timeex)
local chat = coroutine.wrap(function()
if Character:FindFirstChild("TalkingBillBoard")~= nil then
Character:FindFirstChild("TalkingBillBoard"):destroy()
end
local naeeym2 = Instance.new("BillboardGui",Character)
naeeym2.Size = UDim2.new(0,100,0,40)
naeeym2.StudsOffset = Vector3.new(0,3,0)
naeeym2.Adornee = Character.Head
naeeym2.Name = "TalkingBillBoard"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.BorderSizePixel = 0
tecks2.Text = ""
tecks2.Font = font
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = color
tecks2.TextStrokeColor3 = Color3.new(0,0,0)
tecks2.Size = UDim2.new(1,0,0.5,0)
local tecks3 = Instance.new("TextLabel",naeeym2)
tecks3.BackgroundTransparency = 1
tecks3.BorderSizePixel = 0
tecks3.Text = ""
tecks3.Font = font
tecks3.TextSize = 30
tecks3.TextStrokeTransparency = 0
if typet == "Inverted" then
tecks3.TextColor3 = Color3.new(0,0,0)
tecks3.TextStrokeColor3 = color
elseif typet == "Normal" then
tecks3.TextColor3 = color
tecks3.TextStrokeColor3 = Color3.new(0,0,0)
end
tecks3.Size = UDim2.new(1,0,0.5,0)
coroutine.resume(coroutine.create(function()
while true do
swait(1)
if chaosmode == true then
tecks2.TextColor3 = BrickColor.random().Color
tecks3.TextStrokeColor3 = BrickColor.random().Color
end
end
end))
for i = 0, 74*timeex do
swait()
tecks2.Text = text
tecks3.Text = text
end
local randomrot = math.random(1,2)
if randomrot == 1 then
for i = 1, 50 do
swait()
tecks2.Text = text
tecks3.Text = text
tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks2.TextTransparency = tecks2.TextTransparency + .04
tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks3.TextTransparency = tecks2.TextTransparency + .04
end
elseif randomrot == 2 then
	for i = 1, 50 do
swait()
tecks2.Text = text
tecks3.Text = text
tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks2.TextTransparency = tecks2.TextTransparency + .04
tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks3.TextTransparency = tecks2.TextTransparency + .04
end
end
naeeym2:Destroy()
end)
chat()
end

FELOADLIBRARY = {}
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
local Create = FELOADLIBRARY.Create

CFuncs = {	
	["Part"] = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Weld"] = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	["Sound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};

["LongSound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = char,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 30)
			end))
		end;
	};
	
	["ParticleEmitter"] = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return fp
		end;
	};

	CreateTemplate = {
	
	};
}



New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
local m = Instance.new("Model",char)

function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.05,0.05,0.05)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function CreateMesh(parent,meshtype,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = meshtype
mesh.Scale = Vector3.new(x1*20,y1*20,z1*20)
return mesh
end

function CreateSpecialMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.Scale = Vector3.new(x1,y1,z1)
return mesh
end


function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
mesh.Scale = Vector3.new(x1,y1,z1)
mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
return mesh
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end




---- WEAPON OR STUFF
local rarmor = CreateParta(m,1,0,"SmoothPlastic",BrickColor.Random())
local weaponweld = CreateWeld(rarmor,tors,rarmor,-3,0,-0.5,math.rad(0),math.rad(0),math.rad(-40),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local MainWeldS = CreateWeld(Part475,rarmor,Part475,0,0,0,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local A0 = Instance.new("Attachment",rarmor)
A0.Position = Vector3.new(-2.5,0.25,0)
local A1 = Instance.new("Attachment",rarmor)
A1.Position = Vector3.new(-4.7,0.19,0)
tl1 = Instance.new('Trail',rarmor)
tl1.Attachment0 = A0
tl1.Attachment1 = A1
tl1.Texture = "http://www.roblox.com/asset/?id=1978704853"
tl1.LightEmission = 1
tl1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
tl1.Color = ColorSequence.new(BrickColor.new('Royal purple').Color)
tl1.Lifetime = 0.8
tl1.Enabled = false




--------------- WINGS
local mainpart = CreateParta(m,1,0,"SmoothPlastic",BrickColor.Random())
local mwingweld = CreateWeld(mainpart,tors,mainpart,0,-0.5,-0.75,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local wng1a = CreateParta(m,1,0,"Neon",BrickColor.new("Alder"))
CreateMesh(wng1a,"Wedge",0.1,4,4)
CreateWeld(wng1a,mainpart,wng1a,0,-2,-2.5,math.rad(0),math.rad(70),math.rad(5),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local wng2a = CreateParta(m,1,0,"Neon",BrickColor.new("Alder"))
CreateMesh(wng2a,"Wedge",0.1,4,4)
CreateWeld(wng2a,mainpart,wng2a,0,-2,-2.5,math.rad(0),math.rad(-70),math.rad(-5),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local wng1b = CreateParta(m,1,0,"Neon",BrickColor.new("Alder"))
CreateMesh(wng1b,"Wedge",0.1,1.5,3)
CreateWeld(wng1b,mainpart,wng1b,0,-1,-2.25,math.rad(180),math.rad(-110),math.rad(-5),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local wng2b = CreateParta(m,1,0,"Neon",BrickColor.new("Alder"))
CreateMesh(wng2b,"Wedge",0.1,1.5,3)
CreateWeld(wng2b,mainpart,wng2b,0,-1,-2.25,math.rad(180),math.rad(110),math.rad(5),0,0,0,math.rad(0),math.rad(0),math.rad(0))
------


function lerp(object, newCFrame, alpha)
  return object:lerp(newCFrame, alpha)
end

function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
  local Part = Create("Part")({
    Parent = Parent,
    Reflectance = Reflectance,
    Transparency = Transparency,
    CanCollide = false,
    Locked = true,
    BrickColor = BrickColor.new(tostring(BColor)),
    Name = Name,
    Size = Size,
    Material = Material
  })
  Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
  RemoveOutlines(Part)
  return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
  local Msh = Create(Mesh)({
    Parent = Part,
    Offset = OffSet,
    Scale = Scale
  })
  if Mesh == "SpecialMesh" then
    Msh.MeshType = MeshType
    Msh.MeshId = MeshId
  end
  return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
  local Weld = Create("Weld")({
    Parent = Parent,
    Part0 = Part0,
    Part1 = Part1,
    C0 = C0,
    C1 = C1
  })
  return Weld
end

Player=game:GetService("Players").LocalPlayer
Character=playerss 
PlayerGui=Player.PlayerGui 
Backpack=Player.Backpack 
Torso=Character.Torso 
Head=Character.Head 
Humanoid=Character.Humanoid
m=Instance.new('Model',Character)
LeftArm=Character["Left Arm"] 
LeftLeg=Character["Left Leg"] 
RightArm=Character["Right Arm"] 
RightLeg=Character["Right Leg"] 
LS=Torso["Left Shoulder"] 
LH=Torso["Left Hip"] 
RS=Torso["Right Shoulder"] 
RH=Torso["Right Hip"] 
Face = Head.face
Neck=Torso.Neck
it=Instance.new
attacktype=1
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
cloaked=false
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false 
attackdebounce = false 
deb=false
equipped=true
hand=false
MMouse=nil
combo=0
mana=0
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
local Effects={}
local gun=false
local shoot=false
local sine = 0
local change = 1
player=nil 

mouse=Player:GetMouse()
--save shoulders 
RSH, LSH=nil, nil 
--welds 
RW, LW=Instance.new("Weld"), Instance.new("Weld") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
LH=Torso["Left Hip"]
RH=Torso["Right Hip"]
TorsoColor=Torso.BrickColor
function NoOutline(Part)
Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end
player=Player 
ch=Character
RSH=ch.Torso["Right Shoulder"] 
LSH=ch.Torso["Left Shoulder"] 
-- 
RSH.Parent=nil 
LSH.Parent=nil 
-- 
RW.Name="Right Shoulder"
RW.Part0=ch.Torso 
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RW.C1=cf(0, 0.5, 0) 
RW.Part1=ch["Right Arm"] 
RW.Parent=ch.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=ch.Torso 
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LW.C1=cf(0, 0.5, 0) 
LW.Part1=ch["Left Arm"] 
LW.Parent=ch.Torso 

local Stats=Instance.new("BoolValue")
Stats.Name="Stats"
Stats.Parent=Character
local Atk=Instance.new("NumberValue")
Atk.Name="Damage"
Atk.Parent=Stats
Atk.Value=1
local Def=Instance.new("NumberValue")
Def.Name="Defense"
Def.Parent=Stats
Def.Value=1
local Speed=Instance.new("NumberValue")
Speed.Name="Speed"
Speed.Parent=Stats
Speed.Value=1
local Mvmt=Instance.new("NumberValue")
Mvmt.Name="Movement"
Mvmt.Parent=Stats
Mvmt.Value=1

local donum=0
 

function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
local fp=it("Part")
fp.formFactor=formfactor 
fp.Parent=parent
fp.Reflectance=reflectance
fp.Transparency=transparency
fp.CanCollide=false 
fp.Locked=true
fp.BrickColor=brickcolor
fp.Name=name
fp.Size=size
fp.Position=Torso.Position 
NoOutline(fp)
fp.Material="SmoothPlastic"
fp:BreakJoints()
return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
local mesh=it(Mesh) 
mesh.Parent=part
if Mesh=="SpecialMesh" then
mesh.MeshType=meshtype
if meshid~="nil" then
mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
end
end
mesh.Offset=offset
mesh.Scale=scale
return mesh
end
 
function weld(parent,part0,part1,c0)
local weld=it("Weld") 
weld.Parent=parent
weld.Part0=part0 
weld.Part1=part1 
weld.C0=c0
return weld
end
 
local Color1=Torso.BrickColor

local bodvel=Instance.new("BodyVelocity")
local bg=Instance.new("BodyGyro")

function swait(num)
if num==0 or num==nil then
game:service'RunService'.Stepped:wait(0)
else
for i=0,num do
game:service'RunService'.Stepped:wait(0)
end
end
end
 
 
so = function(id,par,vol,pit) 
coroutine.resume(coroutine.create(function()
local sou = Instance.new("Sound",char)
sou.Volume = 0
if not NoSound then
	sou.Volume=vol
end
sou.Pitch=pit or 1
sou.SoundId=id
swait() 
sou:play() 
game:GetService("Debris"):AddItem(sou,6)
end))
end
 
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

local function CFrameFromTopBack(at, top, back)
local right = top:Cross(back)
return CFrame.new(at.x, at.y, at.z,
right.x, top.x, back.x,
right.y, top.y, back.y,
right.z, top.z, back.z)
end

function Triangle(a, b, c)
local edg1 = (c-a):Dot((b-a).unit)
local edg2 = (a-b):Dot((c-b).unit)
local edg3 = (b-c):Dot((a-c).unit)
if edg1 <= (b-a).magnitude and edg1 >= 0 then
a, b, c = a, b, c
elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
a, b, c = b, c, a
elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
a, b, c = c, a, b
else
assert(false, "unreachable")
end
 
local len1 = (c-a):Dot((b-a).unit)
local len2 = (b-a).magnitude - len1
local width = (a + (b-a).unit*len1 - c).magnitude
 
local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)
 
local list = {}
 
if len1 > 0.01 then
local w1 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w1,5)
w1.Material = "SmoothPlastic"
w1.FormFactor = 'Custom'
w1.BrickColor = BrickColor.new("Really red")
w1.Transparency = 0
w1.Reflectance = 0
w1.Material = "SmoothPlastic"
w1.CanCollide = false
local l1 = Instance.new("PointLight",w1)
l1.Color = Color3.new(170,0,0)
NoOutline(w1)
local sz = Vector3.new(0.2, width, len1)
w1.Size = sz
local sp = Instance.new("SpecialMesh",w1)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
w1:BreakJoints()
w1.Anchored = true
w1.Parent = workspace
w1.Transparency = 0.7
table.insert(Effects,{w1,"Disappear",.01})
w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
table.insert(list,w1)
end
 
if len2 > 0.01 then
local w2 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w2,5)
w2.Material = "SmoothPlastic"
w2.FormFactor = 'Custom'
w2.BrickColor = BrickColor.new("Really red")
w2.Transparency = 0
w2.Reflectance = 0
w2.Material = "SmoothPlastic"
w2.CanCollide = false
local l2 = Instance.new("PointLight",w2)
l2.Color = Color3.new(170,0,0)
NoOutline(w2)
local sz = Vector3.new(0.2, width, len2)
w2.Size = sz
local sp = Instance.new("SpecialMesh",w2)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
w2:BreakJoints()
w2.Anchored = true
w2.Parent = workspace
w2.Transparency = 0.7
table.insert(Effects,{w2,"Disappear",.01})
w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
table.insert(list,w2)
end
return unpack(list)
end
 

function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
  if hit.Parent == nil then
    return
  end
  local h = hit.Parent:FindFirstChildOfClass("Humanoid")
  for _, v in pairs(hit.Parent:children()) do
    if v:IsA("Humanoid") then
      h = v
    end
  end
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil or h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return
    end
    local c = Create("ObjectValue")({
      Name = "creator",
      Value = game:service("Players").LocalPlayer,
      Parent = h
    })
    game:GetService("Debris"):AddItem(c, 0.5)
    if HitSound ~= nil and HitPitch ~= nil then
      CFuncs.Sound.Create(HitSound, hit, 1, HitPitch)
    end
    local Damage = math.random(minim, maxim)
    local blocked = false
    local block = hit.Parent:findFirstChild("Block")
    if block ~= nil and block.className == "IntValue" and block.Value > 0 then
      blocked = true
      block.Value = block.Value - 1
      print(block.Value)
    end
    if blocked == false then
	DamageFling(hit.Parent)
      if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health and h.Parent.Name ~= "Hologram" then
        print("gained kill")
      end
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
    else
	DamageFling(hit.Parent)
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
    end
    if Type == "Knockdown" then
      local hum = hit.Parent.Humanoid
      hum.PlatformStand = true
      coroutine.resume(coroutine.create(function(HHumanoid)

        HHumanoid.PlatformStand = true
      end), hum)
      local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
      local bodvol = Create("BodyVelocity")({
        velocity = angle * knockback,
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      local rl = Create("BodyAngularVelocity")({
        P = 3000,
        maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
        angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodvol, 0.5)
      game:GetService("Debris"):AddItem(rl, 0.5)
    elseif Type == "Normal" then
      local vp = Create("BodyVelocity")({
        P = 500,
        maxForce = Vector3.new(math.huge, 0, math.huge),
        velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
      })
      if knockback > 0 then
        vp.Parent = hit.Parent.Torso
      end
      game:GetService("Debris"):AddItem(vp, 0.5)
    elseif Type == "Up" then
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 1)
    elseif Type == "Normal" then
      local hum = hit.Parent.Humanoid
      if hum ~= nil then
        for i = 0, 2 do
          Effects.Sphere.Create(BrickColor.new("Bright red"), hit.Parent.Torso.CFrame * cn(0, 0, 0) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
        end
      end
    elseif Type == "UpKnock" then
      local hum = hit.Parent.Humanoid
      hum.PlatformStand = true
      if hum ~= nil then
        hitr = true
      end
      coroutine.resume(coroutine.create(function(HHumanoid)

        HHumanoid.PlatformStand = false
        hitr = false
      end), hum)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 1)
    elseif Type == "Snare" then
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Slashnare" then
      Effects.Block.Create(BrickColor.new("Pastel Blue"), hit.Parent.Torso.CFrame * cn(0, 0, 0), 15*4, 15*4, 15*4, 3*4, 3*4, 3*4, 0.07)
      for i = 1, math.random(4, 5) do
        Effects.Sphere.Create(BrickColor.new("Teal"), hit.Parent.Torso.CFrame * cn(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
      end
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Spike" then
      CreateBigIceSword(hit.Parent.Torso.CFrame)
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Normal" then
      local BodPos = Create("BodyPosition")({
        P = 50000,
        D = 1000,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      local BodGy = Create("BodyGyro")({
        maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
        P = 20000,
        Parent = hit.Parent.Torso,
        cframe = hit.Parent.Torso.CFrame
      })
      hit.Parent.Torso.Anchored = true
      coroutine.resume(coroutine.create(function(Part)
        Part.Anchored = false
      end), hit.Parent.Torso)
      game:GetService("Debris"):AddItem(BodPos, 3)
      game:GetService("Debris"):AddItem(BodGy, 3)
    end
    local debounce = Create("BoolValue")({
      Name = "DebounceHit",
      Parent = hit.Parent,
      Value = true
    })
    game:GetService("Debris"):AddItem(debounce, Delay)
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = Player
    c.Parent = h
    game:GetService("Debris"):AddItem(c, 0.5)
  end
end
function ShowDamage(Pos, Text, Time, Color)
  local Rate = 0.1
  local Pos = Pos or Vector3.new(0, 0, 0)
  local Text = Text or ""
  local Time = Time or 2
  local Color = Color or Color3.new(1, 0, 1)
  local EffectPart = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
  EffectPart.Anchored = true
  local BillboardGui = Create("BillboardGui")({
    Size = UDim2.new(3, 0, 3, 0),
    Adornee = EffectPart,
    Parent = EffectPart
  })
  local TextLabel = Create("TextLabel")({
    BackgroundTransparency = 1,
    Size = UDim2.new(1, 0, 1, 0),
    Text = Text,
    TextColor3 = Color3.new(1,1,1),
    TextStrokeColor3 = Color3.new(0,0,0),
    TextStrokeTransparency = 0.25,
    TextScaled = true,
    Font = Enum.Font.Fantasy,
    TextSize = 24,
    Parent = BillboardGui
  })
  game.Debris:AddItem(EffectPart, Time + 0.1)
  EffectPart.Parent = game:GetService("Workspace")
  delay(0, function()
    local Frames = Time / Rate
    for Frame = 1, Frames do
      swait(Rate)
      local Percent = Frame / Frames
      TextLabel.Text = Text
      EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent*2, 0)
    end
    for Frame = 1, Frames do
      swait(Rate)
      local Percent = Frame / Frames
      TextLabel.Text = Text
    end
    for Frame = 1, Frames do
      swait(Rate)
      local Percent = Frame / Frames
      TextLabel.TextTransparency = Percent
      TextLabel.Text = Text
      TextLabel.TextStrokeTransparency = Percent
    end
    if EffectPart and EffectPart.Parent then
      EffectPart:Destroy()
    end
  end)
end
function MagniDamage(Part, magni, mindam, maxdam, knock, Type,Sound)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChildOfClass("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://" ..Sound, 1)
        end
      end
      local head = c:findFirstChild("UpperTorso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://" ..Sound, 1)
        end
      end
    end
  end
end


function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 
----

function dmg(dude)
if dude.Name ~= Character then
local bgf = Instance.new("BodyGyro",dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
--[[local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"]]--
local ds = coroutine.wrap(function()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("Part") or v:IsA("MeshPart") then
v.Name = "DEMINISHED"
CFuncs["Sound"].Create("rbxassetid://763718160", v, 0.75, 1.1)
CFuncs["Sound"].Create("rbxassetid://782353443", v, 1, 1)
for i = 0, 1 do
sphere2(1,"Add",v.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,10,-0.01,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
end
end
end
wait(0.5)
targetted = nil
CFuncs["Sound"].Create("rbxassetid://62339698", char, 0.25, 0.285)
coroutine.resume(coroutine.create(function()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("Accessory") then

end
if v:IsA("Humanoid") then

end
if v:IsA("CharacterMesh") then

end
if v:IsA("Model") then

end
if v:IsA("Part") or v:IsA("MeshPart") then
for x, o in pairs(v:GetChildren()) do
if o:IsA("Decal") then
end
end
coroutine.resume(coroutine.create(function()
v.Material = "Neon"
v.CanCollide = false
v.Anchored = false
local bld = Instance.new("ParticleEmitter",v)
bld.LightEmission = 1
bld.Texture = "rbxassetid://363275192" ---284205403
bld.Color = ColorSequence.new(BrickColor.new("Royal purple").Color)
bld.Rate = 500
bld.Lifetime = NumberRange.new(1)
bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,2.25,0),NumberSequenceKeypoint.new(1,0,0)})
bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,1,0)})
bld.Speed = NumberRange.new(2,5)
bld.VelocitySpread = 50000
bld.Rotation = NumberRange.new(-500,500)
bld.RotSpeed = NumberRange.new(-500,500)
local sbs = Instance.new("BodyPosition", v)
sbs.P = 3000
sbs.D = 1000
sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
sbs.position = v.Position + Vector3.new(math.random(-2,2),10 + math.random(-2,2),math.random(-2,2))
v.Color = BrickColor.new("Royal purple").Color
coroutine.resume(coroutine.create(function()
for i = 0, 49 do
swait(1)
end
for i = 0, 4 do
slash(math.random(10,50)/10,3,true,"Round","Add","Out",v.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.0025,0.01),math.random(10,100)/2500,BrickColor.new("White"))
end
block(1,"Add",v.CFrame,vt(0,0,0),0.1,0.1,0.1,BrickColor.new("Royal purple"),BrickColor.new("Royal purple").Color)
CFuncs["Sound"].Create("rbxassetid://782353117", v, 0.25, 1.2)
CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.5, 0.75)
bld.Speed = NumberRange.new(10,25)
bld.Drag = 5
bld.Acceleration = vt(0,2,0)
wait(0.5)
bld.Enabled = false
wait(4)
coroutine.resume(coroutine.create(function()
for i = 0, 99 do
swait()
end
end))
end))
end))
end
end
end))
end)
ds()
end
end

function sphere(bonuspeed,type,pos,scale,value,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.Color = color3
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.Color = color3
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,color3,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.Color = color3
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

function waveEff(bonuspeed,type,typeoftrans,pos,scale,value,value2,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
rngm.MeshId = "rbxassetid://20329976"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
end
local randomrot = math.random(1,2)
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
end
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(5*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-5*bonuspeed/2),0)
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
local type = type
local rotenable = rotatingop
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
if typeofshape == "Normal" then
rngm.MeshId = "rbxassetid://662586858"
elseif typeofshape == "Round" then
rngm.MeshId = "rbxassetid://662585058"
end
rngm.Scale = scale
local scaler2 = 1/10
if type == "Add" then
scaler2 = 1*value/10
elseif type == "Divide" then
scaler2 = 1/value/10
end
local randomrot = math.random(1,2)
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed/10
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed/10
end
if rotenable == true then
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
end
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
end
rng:Destroy()
end))
end

rarmor.Attachment.Name = "Attachment2"
function FindNearestTorso(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") then
			if v:findFirstChild("Torso") or v:findFirstChild("UpperTorso") then
				if v ~= Character then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end 
				end 
			end 
		end 
	end
	return List
end


local dashing = false
local floatmode = false
local OWS = hum.WalkSpeed
local equipped = false
Instance.new("ForceField",char).Visible = false
Humanoid.Animator.Parent = nil
------------------
function equip()
	attack = true
	equipped = true
	hum.WalkSpeed = 0
tl1.Enabled = true
for i = 0, 9 do
end
CFuncs["Sound"].Create("rbxassetid://1368637781", rarmor, 2.5, 1.25)
CFuncs["Sound"].Create("rbxassetid://200633077", rarmor, 1, 1)
CFuncs["Sound"].Create("rbxassetid://169380495", rarmor, 0.5, 1.1)
	for i = 0, 2, 0.1 do
		swait()
hum.CameraOffset = vt(math.random(-5,5)/50,math.random(-5,5)/50,math.random(-5,5)/50)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(10),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-10)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(-20)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-20),math.rad(-30),math.rad(130)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(-13),math.rad(10),math.rad(-10)),.3)
end
hum.CameraOffset = vt(0,0,0)
weaponweld.Part0 = rarm
for i = 0, 2, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-40),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(5)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.1,0.1,0)*angles(math.rad(0),math.rad(0),math.rad(40)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(-40)),.3)
RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.65)*angles(math.rad(100),math.rad(0),math.rad(-23)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(110),math.rad(0),math.rad(-85)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
end
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*4
MagniDamage(hitb, 4, 40,73, 0, "Normal",153092213)
CFuncs["Sound"].Create("rbxassetid://200633196", rarmor, 1, 1.05)
CFuncs["Sound"].Create("rbxassetid://200633108", rarmor, 1.5, 1.025)
CFuncs["Sound"].Create("rbxassetid://234365549", rarmor, 1, 1)
for i = 0, 2, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(50),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(-0.1,-0.25,0)*angles(math.rad(10),math.rad(0),math.rad(-50)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(50)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(80),math.rad(0),math.rad(70)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(100),math.rad(0),math.rad(-50)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
end
hitb:Destroy()
hum.WalkSpeed = Speed
OWS = hum.WalkSpeed
	attack = false
end

function unequip()
	attack = true
	equipped = false
	hum.WalkSpeed = 0
hum.WalkSpeed = 16
OWS = hum.WalkSpeed
tl1.Enabled = false
CFuncs["Sound"].Create("rbxassetid://200633029", rarmor, 1, 1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.5)
weaponweld.Part0 = tors
	attack = false
end

------------------
function attackone()
attack = true
hum.WalkSpeed = Speed
for i = 0, 2, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-40),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(5)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.1,0.1,0)*angles(math.rad(0),math.rad(0),math.rad(40)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(-40)),.3)
RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.65)*angles(math.rad(100),math.rad(0),math.rad(-23)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(110),math.rad(0),math.rad(-85)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
end
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*4
MagniDamage(hitb, 4, 24,30, 0, "Normal",153092213)
CFuncs["Sound"].Create("rbxassetid://200633196", rarmor, 1, 1.05)
CFuncs["Sound"].Create("rbxassetid://200633108", rarmor, 1.5, 1.025)
CFuncs["Sound"].Create("rbxassetid://234365549", rarmor, 1, 1)
for i = 0, 1, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(50),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(-0.1,-0.25,0)*angles(math.rad(10),math.rad(0),math.rad(-50)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(50)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(80),math.rad(0),math.rad(70)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(100),math.rad(0),math.rad(-50)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
end
hitb:Destroy()
attack = false
hum.WalkSpeed = Speed
end
function attacktwo()
attack = true
hum.WalkSpeed = Speed
for i = 0, 1, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(20),math.rad(5)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(-0.1,0.1,0)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(40)),.3)
RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.65)*angles(math.rad(100),math.rad(0),math.rad(-23)),.3)
LW.C0=clerp(LW.C0,cf(-0.5,0.5,-0.25)*angles(math.rad(90),math.rad(0),math.rad(40)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(180),math.rad(0)),.3)
end
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*4
MagniDamage(hitb, 4, 24,30, 0, "Normal",153092213)
CFuncs["Sound"].Create("rbxassetid://200633281", rarmor, 1, 1.05)
CFuncs["Sound"].Create("rbxassetid://161006195", rarmor, 1.5, 1.025)
for i = 0, 1, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-30),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(20)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.2,-0.25,0)*angles(math.rad(10),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(-90)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(80),math.rad(0),math.rad(20)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(100),math.rad(0),math.rad(-50)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(180),math.rad(70)),.3)
end
attack = false
hum.WalkSpeed = Speed
end
function attackthree()
attack = true
hum.WalkSpeed = Speed
for i = 0, 1, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-30),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(5)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(-0.1,0.1,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-30),math.rad(0),math.rad(53)),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(-10)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(90),math.rad(-20)),.3)
end
for x = 0, 2 do
CFuncs["Sound"].Create("rbxassetid://200633108", rarmor, 1, 1.05)
CFuncs["Sound"].Create("rbxassetid://234365573", rarmor, 1.5, 1.025)
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*4
MagniDamage(hitb, 4, 12,15, 0, "Normal",153092213)
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(40),math.rad(20)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.2,-0.25,0)*angles(math.rad(-2),math.rad(0),math.rad(80)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-20)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(0),math.rad(30),math.rad(90)),.3)
end
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(40),math.rad(20)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.2,-0.25,0)*angles(math.rad(-2),math.rad(0),math.rad(80)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-20)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(180)),.3)
end
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(40),math.rad(20)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.2,-0.25,0)*angles(math.rad(-2),math.rad(0),math.rad(80)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-20)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(0),math.rad(-30),math.rad(270)),.3)
end
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(40),math.rad(20)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.2,-0.25,0)*angles(math.rad(-2),math.rad(0),math.rad(80)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-20)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
end
end
attack = false
hum.WalkSpeed = Speed
end
------------------
function spinnyblade()
attack = true
hum.WalkSpeed = 16
hum.JumpPower = 0
CFuncs["Sound"].Create("rbxassetid://1368583274", root, 4.5, 1)
local bgui = Instance.new("BillboardGui",root)
bgui.Size = UDim2.new(25, 0, 25, 0)
local imgc = Instance.new("ImageLabel",bgui)
imgc.BackgroundTransparency = 1
imgc.ImageTransparency = 1
imgc.Size = UDim2.new(1,0,1,0)
imgc.Image = "rbxassetid://997291547"
imgc.ImageColor3 = Color3.new(0,0.5,1)
local imgc2 = imgc:Clone()
imgc2.Parent = bgui
imgc2.Position = UDim2.new(-0.5,0,-0.5,0)
imgc2.Size = UDim2.new(2,0,2,0)
imgc2.ImageColor3 = Color3.new(0.5,0,1)
for i = 0, 1, 0.1 do
		swait()
bgui.Size = bgui.Size - UDim2.new(0.25, 0, 0.25, 0)
hum.CameraOffset = vt(math.random(-10,10)/50,math.random(-10,10)/50,math.random(-10,10)/50)
	RH.C0=clerp(RH.C0,cf(1,-0.5,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-40),math.rad(10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.1,0.2,-0.3)*angles(math.rad(10),math.rad(0),math.rad(50)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(-50)),.3)
RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.65)*angles(math.rad(100),math.rad(0),math.rad(-23)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(110),math.rad(0),math.rad(-85)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
end
imgc.ImageTransparency = 1
hum.CameraOffset = vt(0,0,0)
for i = 0, 9 do
end
CFuncs["Sound"].Create("rbxassetid://430315987", root, 1.5, 1)
CFuncs["Sound"].Create("rbxassetid://1295446488", root, 3, 1)
for x = 0, 20 do
CFuncs["Sound"].Create("rbxassetid://200633281", rarmor, 1, 1.05)
CFuncs["Sound"].Create("rbxassetid://161006195", rarmor, 1.5, 1.025)
MagniDamage(tors, 10, 60,85, 0, "Normal",153092213)
CFuncs["Sound"].Create("rbxassetid://200632992", rarmor, 1.25, 1)
for i = 0, 1, 0.6 do
		swait()
root.CFrame = root.CFrame + root.CFrame.lookVector*2
root.Velocity = vt(0,0,0)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.5)*angles(math.rad(0),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
end
CFuncs["Sound"].Create("rbxassetid://200632992", rarmor, 1.25, 1)
MagniDamage(tors, 10, 60,85, 0, "Normal",153092213)
for i = 0, 1, 0.6 do
		swait()
root.CFrame = root.CFrame + root.CFrame.lookVector*3
root.Velocity = vt(0,0,0)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.5)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
end
CFuncs["Sound"].Create("rbxassetid://200632992", rarmor, 1.25, 1)
MagniDamage(tors, 10, 60,85, 0, "Normal",153092213)
for i = 0, 1, 0.6 do
		swait()
root.CFrame = root.CFrame + root.CFrame.lookVector*3
root.Velocity = vt(0,0,0)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.5)*angles(math.rad(180),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
end
CFuncs["Sound"].Create("rbxassetid://200632992", rarmor, 1.25, 1)
MagniDamage(tors, 10, 60,85, 0, "Normal",153092213)
for i = 0, 1, 0.6 do
		swait()
root.CFrame = root.CFrame + root.CFrame.lookVector*3
root.Velocity = vt(0,0,0)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.5)*angles(math.rad(270),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
end
end
hum.WalkSpeed = 0
for i = 0, 5, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.2)
LH.C0=clerp(LH.C0,cf(-1,-0.6,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(20),math.rad(-12)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.1,0.2,-0.35)*angles(math.rad(10),math.rad(0),math.rad(-40)),.2)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(40)),.2)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(110)),.2)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0)*angles(math.rad(45),math.rad(0),math.rad(-20)),.2)
weaponweld.C1=clerp(weaponweld.C1,cf(2,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.2)
end
bgui:Destroy()
attack = false
hum.WalkSpeed = Speed
hum.JumpPower = 50
end

function darkspin()
attack = true
hum.WalkSpeed = 16
hum.JumpPower = 0
CFuncs["Sound"].Create("rbxassetid://1368583274", root, 4.5, 1)
local bgui = Instance.new("BillboardGui",root)
bgui.Size = UDim2.new(25, 0, 25, 0)
local imgc = Instance.new("ImageLabel",bgui)
imgc.BackgroundTransparency = 1
imgc.ImageTransparency = 1
imgc.Size = UDim2.new(1,0,1,0)
imgc.Image = "rbxassetid://997291547"
imgc.ImageColor3 = Color3.new(0,0.5,1)
local imgc2 = imgc:Clone()
imgc2.Parent = bgui
imgc2.Position = UDim2.new(-0.5,0,-0.5,0)
imgc2.Size = UDim2.new(2,0,2,0)
imgc2.ImageColor3 = Color3.new(0.5,0,1)
for i = 0, 1, 0.1 do
		swait()
bgui.Size = bgui.Size - UDim2.new(0.25, 0, 0.25, 0)
hum.CameraOffset = vt(math.random(-10,10)/50,math.random(-10,10)/50,math.random(-10,10)/50)
	RH.C0=clerp(RH.C0,cf(1,-0.5,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-40),math.rad(10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.1,0.2,-0.3)*angles(math.rad(10),math.rad(0),math.rad(50)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(-50)),.3)
RW.C0=clerp(RW.C0,cf(1.25,0.5,-0.65)*angles(math.rad(100),math.rad(0),math.rad(-23)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(110),math.rad(0),math.rad(-85)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
end
imgc.ImageTransparency = 1
hum.CameraOffset = vt(0,0,0)
for i = 0, 9 do
end
CFuncs["Sound"].Create("rbxassetid://430315987", root, 1.5, 1)
CFuncs["Sound"].Create("rbxassetid://1295446488", root, 3, 1)
for x = 0, 20 do
CFuncs["Sound"].Create("rbxassetid://200633281", rarmor, 1, 1.05)
CFuncs["Sound"].Create("rbxassetid://161006195", rarmor, 1.5, 1.025)
MagniDamage(tors, 10, 60,85, 0, "Normal",153092213)
CFuncs["Sound"].Create("rbxassetid://200632992", rarmor, 1.25, 1)
for i = 0, 1, 0.6 do
		swait()
root.CFrame = root.CFrame + root.CFrame.lookVector*6
root.Velocity = vt(0,0,0)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.5)*angles(math.rad(0),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
end
CFuncs["Sound"].Create("rbxassetid://200632992", rarmor, 1.25, 1)
MagniDamage(tors, 10, 60,85, 0, "Normal",153092213)
for i = 0, 1, 0.6 do
		swait()
root.CFrame = root.CFrame + root.CFrame.lookVector*4
root.Velocity = vt(0,0,0)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.5)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
end
CFuncs["Sound"].Create("rbxassetid://200632992", rarmor, 1.25, 1)
MagniDamage(tors, 10, 60,85, 0, "Normal",153092213)
for i = 0, 1, 0.6 do
		swait()
root.CFrame = root.CFrame + root.CFrame.lookVector*5
root.Velocity = vt(0,0,0)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.5)*angles(math.rad(180),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
end
CFuncs["Sound"].Create("rbxassetid://200632992", rarmor, 1.25, 1)
MagniDamage(tors, 10, 60,85, 0, "Normal",153092213)
for i = 0, 1, 0.6 do
		swait()
root.CFrame = root.CFrame + root.CFrame.lookVector*4
root.Velocity = vt(0,0,0)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0.5)*angles(math.rad(270),math.rad(0),math.rad(90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(90)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.3)
end
end
hum.WalkSpeed = 0
for i = 0, 5, 0.1 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.2)
LH.C0=clerp(LH.C0,cf(-1,-0.6,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(20),math.rad(-12)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0.1,0.2,-0.35)*angles(math.rad(10),math.rad(0),math.rad(-40)),.2)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(40)),.2)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(110)),.2)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0)*angles(math.rad(45),math.rad(0),math.rad(-20)),.2)
weaponweld.C1=clerp(weaponweld.C1,cf(2,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.2)
end
bgui:Destroy()
attack = false
hum.WalkSpeed = Speed
hum.JumpPower = 50
end

function eightbitmegablade()
attack = true
hum.WalkSpeed = 0
hum.JumpPower = 0
CFuncs["Sound"].Create("rbxassetid://1368583274", larm, 4.5, 1.2)
local OverCut = false
cam.CameraSubject = Humanoid
cam.CameraType = "Scriptable"
coroutine.resume(coroutine.create(function()
while true do
swait()
if OverCut == false then
cam.CFrame = lerp(cam.CFrame, root.CFrame * cf(1, 1.5, -6) * ceuler(math.rad(10), math.rad(170), math.rad(-20)), 0.1)
else
break
end
end
end))
for i = 0, 4, 0.1 do
swait()
sphere2(5,"Add",larm.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.1,-0.01,BrickColor.new("Toothpaste"),BrickColor.new("Toothpaste").Color)
slash(math.random(20,40)/10,5,true,"Round","Add","Out",larm.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.025,0.001,0.025),-0.025,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0),math.rad(-6)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(3)),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-50)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15),math.rad(5),math.rad(50)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-13),math.rad(-40),math.rad(20)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(170),math.rad(10),math.rad(0)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(130),math.rad(0)),.3)
end
OverCut = true
local orb = Instance.new("Part", char)
orb.Anchored = true
orb.BrickColor = BrickColor.new("Toothpaste")
orb.CanCollide = false
orb.FormFactor = 3
orb.Name = "Ring"
orb.Material = "Neon"
orb.Size = Vector3.new(1, 1, 1)
orb.Transparency = 0.5
orb.TopSurface = 0
orb.BottomSurface = 0
local orbm = Instance.new("SpecialMesh", orb)
orbm.MeshType = "FileMesh"
orbm.MeshId = "rbxassetid://361629844"
orbm.Scale = vt(30,60,60)
orb.CFrame = root.CFrame*CFrame.new(0,50,0)
for i = 0, 24 do
end
CFuncs["Sound"].Create("rbxassetid://1368637781", orb, 7.5, 1)
local a = Instance.new("Part",workspace)
a.Name = "Direction"	
a.Anchored = true
a.Transparency = 1
a.CanCollide = false
local ray = Ray.new(
orb.CFrame.p,                           -- origin
(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
) 
local ignore = orb
local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
a.BottomSurface = 10
a.TopSurface = 10
local distance = (orb.CFrame.p - position).magnitude
a.Size = Vector3.new(0.1, 0.1, 0.1)
a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
orb.CFrame = a.CFrame
for i = 0, 7, 0.1 do
swait()
ray = Ray.new(
orb.CFrame.p,                           -- origin
(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
) 
hit, position, normal = workspace:FindPartOnRay(ray, ignore)
distance = (orb.CFrame.p - position).magnitude
a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
orb.CFrame = a.CFrame
cam.CFrame = lerp(cam.CFrame, root.CFrame * cf(20, 65, 55) * ceuler(math.rad(-20), math.rad(0), math.rad(10)), 0.2)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0),math.rad(-6)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(40),math.rad(3)),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-90)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(90)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-13),math.rad(-20),math.rad(20)),.3)
LW.C0=clerp(LW.C0,cf(-1.25,0.5,-0.5)*angles(math.rad(100),math.rad(0),math.rad(60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(130),math.rad(0)),.3)
end
cam.CameraType = "Custom"
orb.Anchored = false
a:Destroy()
local bv = Instance.new("BodyVelocity")
bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
bv.velocity = orb.CFrame.lookVector*250
bv.Parent = orb
local hitted = false
CFuncs["Sound"].Create("rbxassetid://466493476", orb, 7.5, 0.7)
waveEff(2,"Add","Out",orb.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(5,1,5),0.5,0.1,BrickColor.new("Cyan"))
coroutine.resume(coroutine.create(function()
while true do
swait(2)
if hitted == false and orb.Parent ~= nil then
elseif hitted == true and orb.Parent == nil then
break
end
end
end))
orb.Touched:connect(function(hit) 
if hitted == false and hit.Parent ~= char then
hitted = true
MagniDamage(orb, 30, 72,95, 0, "Normal",153092213)
CFuncs["Sound"].Create("rbxassetid://763717897", orb, 10, 1)
CFuncs["Sound"].Create("rbxassetid://1295446488", orb, 9, 0.75)
for i = 0, 24 do
end
orb.Anchored = true
orb.Transparency = 1
coroutine.resume(coroutine.create(function()
for i = 0, 4, 0.1 do
swait()
hum.CameraOffset = vt(math.random(-10,10)/25,math.random(-10,10)/25,math.random(-10,10)/25)
end
hum.CameraOffset = vt(0,0,0)
end))
wait(10)
orb:Destroy()
end
end)
game:GetService("Debris"):AddItem(orb, 10)
for i = 0, 2, 0.1 do
swait()
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0),math.rad(-6)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(3)),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.4,0)*angles(math.rad(0),math.rad(0),math.rad(-70)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(70)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-13),math.rad(-40),math.rad(20)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-80)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(130),math.rad(0)),.3)
end
attack = false
hum.WalkSpeed = Speed
hum.JumpPower = 50
end

function bladespinagain()
attack = true
hum.WalkSpeed = 40
hum.JumpPower = 0
CFuncs["Sound"].Create("rbxassetid://1368598393", rarmor, 2, 1)
CFuncs["Sound"].Create("rbxassetid://1368583274", rarmor, 2.5, 1)
for x = 0, 1 do
CFuncs["Sound"].Create("rbxassetid://200633108", rarmor, 2, 1.05)
CFuncs["Sound"].Create("rbxassetid://234365573", rarmor, 2.5, 1.025)
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
end
for i = 0, 1, 0.6 do
		swait()
hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(90),math.rad(0)),.3)
end
for i = 0, 1, 0.6 do
		swait()
hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(180),math.rad(0)),.3)
end
for i = 0, 1, 0.6 do
		swait()
hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(270),math.rad(0)),.3)
end
end
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*8
hitb.CFrame = hitb.CFrame*CFrame.new(0,1,0)
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
for i = 0, 24 do
end
CFuncs["Sound"].Create("rbxassetid://313205954", root, 4,1)
CFuncs["Sound"].Create("rbxassetid://1368637781", rarmor, 4,1)
CFuncs["Sound"].Create("rbxassetid://763718160", rarmor, 5, 1.1)
CFuncs["Sound"].Create("rbxassetid://782353443", rarmor, 6, 1)
--CFuncs["Sound"].Create("rbxassetid://1548538202", rarmor, 4,1)
for i = 0, 2, 0.1 do
		swait()
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
hum.CameraOffset = vt(math.random(-10,10)/25,math.random(-10,10)/25,math.random(-10,10)/25)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-20),math.rad(-10)),.9)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.9)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0)*angles(math.rad(0),math.rad(0),math.rad(80)),.9)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.9)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(70)),.9)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-60)),.9)
weaponweld.C1=clerp(weaponweld.C1,cf(2,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.9)
end
hum.CameraOffset = vt(0,0,0)
hitb:Destroy()
attack = false
hum.WalkSpeed = Speed
hum.JumpPower = 50
end

function darkbruh()
attack = true
hum.WalkSpeed = hum.WalkSpeed
hum.JumpPower = 0
CFuncs["Sound"].Create("rbxassetid://1368598393", rarmor, 2, 1)
CFuncs["Sound"].Create("rbxassetid://1368583274", rarmor, 2.5, 1)
for x = 0, 1 do
CFuncs["Sound"].Create("rbxassetid://200633108", rarmor, 2, 1.05)
CFuncs["Sound"].Create("rbxassetid://234365573", rarmor, 2.5, 1.025)
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
end
for i = 0, 1, 0.6 do
		swait()
hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(90),math.rad(0)),.3)
end
for i = 0, 1, 0.6 do
		swait()
hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(180),math.rad(0)),.3)
end
end
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*16
hitb.CFrame = hitb.CFrame*CFrame.new(0,1,0)
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
for i = 0, 24 do
end
CFuncs["Sound"].Create("rbxassetid://313205954", root, 4,1)
CFuncs["Sound"].Create("rbxassetid://1368637781", rarmor, 4,1)
CFuncs["Sound"].Create("rbxassetid://763718160", rarmor, 5, 1.1)
CFuncs["Sound"].Create("rbxassetid://782353443", rarmor, 6, 1)
--CFuncs["Sound"].Create("rbxassetid://1548538202", rarmor, 4,1)
for i = 0, 2, 0.1 do
		swait()
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
hum.CameraOffset = vt(math.random(-10,10)/25,math.random(-10,10)/25,math.random(-10,10)/25)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-20),math.rad(-10)),.9)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.9)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0)*angles(math.rad(0),math.rad(0),math.rad(80)),.9)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.9)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(70)),.9)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-60)),.9)
weaponweld.C1=clerp(weaponweld.C1,cf(2,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.9)
end
hum.CameraOffset = vt(0,0,0)
hitb:Destroy()
attack = false
hum.WalkSpeed = Speed
hum.JumpPower = 50
end

function SCYTHEslash2()
attack = true
hum.WalkSpeed = 90
hum.JumpPower = 0
CFuncs["Sound"].Create("rbxassetid://1368598393", rarmor, 2, 1)
CFuncs["Sound"].Create("rbxassetid://1368583274", rarmor, 2.5, 1)
for x = 0, 1 do
CFuncs["Sound"].Create("rbxassetid://200633108", rarmor, 2, 1.05)
CFuncs["Sound"].Create("rbxassetid://234365573", rarmor, 2.5, 1.025)
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(65),math.rad(0)),.3)
end
end
wait(0.05)
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*8
hitb.CFrame = hitb.CFrame*CFrame.new(0,1,0)
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
for i = 0, 24 do
end
CFuncs["Sound"].Create("rbxassetid://313205954", root, 4,1)
CFuncs["Sound"].Create("rbxassetid://1368637781", rarmor, 4,1)
CFuncs["Sound"].Create("rbxassetid://763718160", rarmor, 5, 1.1)
CFuncs["Sound"].Create("rbxassetid://782353443", rarmor, 6, 1)
--CFuncs["Sound"].Create("rbxassetid://1548538202", rarmor, 4,1)
for i = 0, 2, 0.1 do
		swait()
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
hum.CameraOffset = vt(math.random(-10,10)/25,math.random(-10,10)/25,math.random(-10,10)/25)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-20),math.rad(-10)),.9)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.9)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0)*angles(math.rad(0),math.rad(0),math.rad(80)),.9)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.9)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(70)),.9)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-60)),.9)
weaponweld.C1=clerp(weaponweld.C1,cf(2,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.9)
end
hum.CameraOffset = vt(0,0,0)
hitb:Destroy()
attack = false
hum.WalkSpeed = Speed
hum.JumpPower = 50
end

function axeslash()
attack = true
hum.WalkSpeed = 100
hum.JumpPower = 0
CFuncs["Sound"].Create("rbxassetid://1368598393", rarmor, 2, 1)
CFuncs["Sound"].Create("rbxassetid://1368583274", rarmor, 2.5, 1)
for x = 0, 1 do
CFuncs["Sound"].Create("rbxassetid://200633108", rarmor, 2, 1.05)
CFuncs["Sound"].Create("rbxassetid://234365573", rarmor, 2.5, 1.025)
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(65),math.rad(0)),.3)
end
end
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*8
hitb.CFrame = hitb.CFrame*CFrame.new(0,1,0)
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
for i = 0, 24 do
end
CFuncs["Sound"].Create("rbxassetid://313205954", root, 4,1)
CFuncs["Sound"].Create("rbxassetid://1368637781", rarmor, 4,1)
CFuncs["Sound"].Create("rbxassetid://763718160", rarmor, 5, 1.1)
CFuncs["Sound"].Create("rbxassetid://782353443", rarmor, 6, 1)
--CFuncs["Sound"].Create("rbxassetid://1548538202", rarmor, 4,1)
for i = 0, 2, 0.1 do
		swait()
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
hum.CameraOffset = vt(math.random(-10,10)/25,math.random(-10,10)/25,math.random(-10,10)/25)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-20),math.rad(-10)),.9)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.9)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0)*angles(math.rad(0),math.rad(0),math.rad(80)),.9)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.9)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(70)),.9)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-60)),.9)
weaponweld.C1=clerp(weaponweld.C1,cf(2,0,0)*angles(math.rad(90),math.rad(0),math.rad(-90)),.9)
end
hum.CameraOffset = vt(0,0,0)
hitb:Destroy()
attack = false
hum.WalkSpeed = Speed
hum.JumpPower = 50
end

function darkslash()
attack = true
hum.WalkSpeed = 80
hum.JumpPower = 0
CFuncs["Sound"].Create("rbxassetid://1368598393", rarmor, 2, 1)
CFuncs["Sound"].Create("rbxassetid://1368583274", rarmor, 2.5, 1)
for x = 0, 1 do
CFuncs["Sound"].Create("rbxassetid://200633108", rarmor, 2, 1.05)
CFuncs["Sound"].Create("rbxassetid://234365573", rarmor, 2.5, 1.025)
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(0),math.rad(0),math.rad(-60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(-15),math.rad(180),math.rad(90)),.3)
end
end
wait(0.06)
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*8
hitb.CFrame = hitb.CFrame*CFrame.new(0,1,0)
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
for i = 0, 24 do
end
CFuncs["Sound"].Create("rbxassetid://313205954", root, 4,1)
CFuncs["Sound"].Create("rbxassetid://1368637781", rarmor, 4,1)
CFuncs["Sound"].Create("rbxassetid://763718160", rarmor, 5, 1.1)
CFuncs["Sound"].Create("rbxassetid://782353443", rarmor, 6, 1)
--CFuncs["Sound"].Create("rbxassetid://1548538202", rarmor, 4,1)
for i = 0, 2, 0.1 do
		swait()
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
hum.CameraOffset = vt(math.random(-10,10)/25,math.random(-10,10)/25,math.random(-10,10)/25)
	RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-20),math.rad(-10)),.9)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.9)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0)*angles(math.rad(0),math.rad(0),math.rad(80)),.9)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(-80)),.9)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(70)),.9)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-60)),.9)
weaponweld.C1=clerp(weaponweld.C1,cf(2,0,0)*angles(math.rad(0),math.rad(180),math.rad(90)),.9)
end
hum.CameraOffset = vt(0,0,0)
hitb:Destroy()
attack = false
hum.WalkSpeed = Speed
hum.JumpPower = 50
end

function smack()
attack = true
hum.WalkSpeed = 3
hum.JumpPower = 0
CFuncs["Sound"].Create("rbxassetid://1368598393", rarmor, 2, 1)
CFuncs["Sound"].Create("rbxassetid://1368583274", rarmor, 2.5, 1)
for x = 0, 1 do
CFuncs["Sound"].Create("rbxassetid://200633108", rarmor, 2, 1.05)
CFuncs["Sound"].Create("rbxassetid://234365573", rarmor, 2.5, 1.025)
for i = 0, 1, 0.6 do
		swait()
	RH.C0=clerp(RH.C0,cf(1,-0.5,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-10)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(-55),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(0)),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,0)*angles(math.rad(-60),math.rad(0),math.rad(-0)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(64),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(80)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-60)),.3)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0 + -0 * math.sin(sine / 0.5)),math.rad(-90 + -5 * math.sin(sine / 40)),math.rad(0 + -0.1 * math.sin(sine / 0.5))),.3)
end
end
wait(0.08)
local hitb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.Random())
hitb.Anchored = true
hitb.CFrame = root.CFrame + root.CFrame.lookVector*8
hitb.CFrame = hitb.CFrame*CFrame.new(0,1,0)
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
for i = 0, 24 do
end
CFuncs["Sound"].Create("rbxassetid://313205954", root, 4,1)
CFuncs["Sound"].Create("rbxassetid://1368637781", rarmor, 4,1)
CFuncs["Sound"].Create("rbxassetid://763718160", rarmor, 5, 1.1)
CFuncs["Sound"].Create("rbxassetid://782353443", rarmor, 6, 1)
--CFuncs["Sound"].Create("rbxassetid://1548538202", rarmor, 4,1)
for i = 0, 2, 0.1 do
		swait()
MagniDamage(hitb, 8, 92,158, 0, "Normal",153092213)
hum.CameraOffset = vt(math.random(-10,10)/25,math.random(-10,10)/25,math.random(-10,10)/25)
	RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(20),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-20),math.rad(-10)),.9)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(15),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.9)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,0)*angles(math.rad(30),math.rad(0),math.rad(0)),.9)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(0)),.9)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(70)),.9)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-60)),.9)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0 + -0 * math.sin(sine / 0.5)),math.rad(-90 + -5 * math.sin(sine / 40)),math.rad(0 + -0.1 * math.sin(sine / 0.5))),.3)
end
hum.CameraOffset = vt(0,0,0)
hitb:Destroy()
attack = false
hum.WalkSpeed = Speed
hum.JumpPower = 50
end

function superjump()
attack = true
hum.WalkSpeed = 0
hum.JumpPower = 0
CFuncs["Sound"].Create("rbxassetid://1368637781", root, 7.5, 1)
for i = 0, 2, 0.1 do
		swait()
hum.CameraOffset = vt(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)
root.Velocity = vt(0,0,0)
	RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(20)),.4)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(40)),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.5,-1)*angles(math.rad(20),math.rad(0),math.rad(0)),.4)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4),math.rad(0),math.rad(0)),.4)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(40)),.4)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(10),math.rad(0),math.rad(-40)),.4)
end
CFuncs["Sound"].Create("rbxassetid://477843807", root, 7, 1.05)
local lat1 = Instance.new("Attachment",larm)
lat1.Position = Vector3.new(1,-1,0.5)
local lat2 = Instance.new("Attachment",larm)
lat2.Position = Vector3.new(-1,-1,-0.5)
local rat1 = Instance.new("Attachment",rarm)
rat1.Position = Vector3.new(1,-1,-0.5)
local rat2 = Instance.new("Attachment",rarm)
rat2.Position = Vector3.new(-1,-1,0.5)
local tl1 = Instance.new('Trail',larm)
tl1.Attachment0 = lat1
tl1.Attachment1 = lat2
tl1.Texture = "http://www.roblox.com/asset/?id=1049219073"
tl1.LightEmission = 1
tl1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.05, 0),NumberSequenceKeypoint.new(1, 1)})
tl1.Color = ColorSequence.new(BrickColor.new('Royal purple').Color,BrickColor.new('Royal purple').Color)
tl1.Lifetime = 5
local tl2 = tl1:Clone()
tl2.Attachment0 = rat1
tl2.Attachment1 = rat2
tl2.Parent = rarm
hum.JumpPower = 20
hum.Jump = true
swait()
hum.JumpPower = 0
root.Velocity = vt(0,250,0) + root.CFrame.lookVector*250
for i = 0, 49 do
end
coroutine.resume(coroutine.create(function()
for i = 0, 2, 0.1 do
swait()
hum.CameraOffset = vt(math.random(-10,10)/50,math.random(-10,10)/50,math.random(-10,10)/50)
end
hum.CameraOffset = vt(0,0,0)
wait(3)
tl1.Enabled = false
tl2.Enabled = false
game:GetService("Debris"):AddItem(tl1, 5)
game:GetService("Debris"):AddItem(tl2, 5)
game:GetService("Debris"):AddItem(rat1, 5)
game:GetService("Debris"):AddItem(rat2, 5)
game:GetService("Debris"):AddItem(lat1, 5)
game:GetService("Debris"):AddItem(lat2, 5)
end))
CFuncs["Sound"].Create("rbxassetid://1295446488", root, 10, 1)
for i = 0, 3, 0.1 do
		swait()
RH.C0=clerp(RH.C0,cf(1,-0.45,-0.45)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-20)),.4)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(30)),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.75,0)*angles(math.rad(40),math.rad(0),math.rad(0)),.4)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20),math.rad(0),math.rad(0)),.4)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-30),math.rad(0),math.rad(20)),.4)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(-30),math.rad(0),math.rad(-20)),.4)
end
coroutine.resume(coroutine.create(function()
for i = 0, 54 do
swait()
end
end))
attack = false
if equipped == false then
hum.WalkSpeed = 16
else
hum.WalkSpeed = Speed
end
hum.JumpPower = 50
end
------------------


local attacktype = 1
mouse.Button1Down:connect(function()
if equipped == true then
  if attack == false and attacktype == 1 then
    attacktype = 2
    attackone()
  elseif attack == false and attacktype == 2 then
    attacktype = 3
    attacktwo()
  elseif attack == false and attacktype == 3 then
    attacktype = 1
    attackthree()
  --[[elseif attack == false and attacktype == 4 then
    attacktype = 1
    --attackfour()]]--
  end
end
end)
mouse.KeyDown:connect(function(k)
if k == "f" and attack == false and equipped == false then
	maybe:FindFirstChildOfClass("AlignOrientation").Attachment1 = rarmor.Attachment
    maybe:FindFirstChildOfClass("AlignPosition").Attachment1 = rarmor.Attachment2

    rarmor.Attachment2.Position = Vector3.new(-1.5, -0.100, 0)
    rarmor.Attachment.Rotation = Vector3.new(-1.1, 2, 5000)
	equip()
elseif k == "f" and attack == false and equipped == true then
	maybe:FindFirstChildOfClass("AlignOrientation").Attachment1 = playerss.Torso.WaistBackAttachment
    maybe:FindFirstChildOfClass("AlignPosition").Attachment1 = playerss.Torso.WaistBackAttachment

    playerss.Torso.WaistBackAttachment.Position = Vector3.new(-0, 0.26, 0.6)
    playerss.Torso.WaistBackAttachment.Orientation = Vector3.new(-4.16, -179.28, 160.7)
   unequip()
end
if k == "y" and attack == false and equipped == false then
	maybe:FindFirstChildOfClass("AlignOrientation").Attachment1 = rarmor.Attachment
    maybe:FindFirstChildOfClass("AlignPosition").Attachment1 = rarmor.Attachment2

    rarmor.Attachment2.Position = Vector3.new(-1.25, 0.28, -0)
    rarmor.Attachment.Rotation = Vector3.new(-0, -0, -290)
elseif k == "y" and attack == false and equipped == true then
	maybe:FindFirstChildOfClass("AlignOrientation").Attachment1 = playerss.Torso.WaistBackAttachment
    maybe:FindFirstChildOfClass("AlignPosition").Attachment1 = playerss.Torso.WaistBackAttachment

    playerss.Torso.WaistBackAttachment.Position = Vector3.new(-0, 0.26, 0.6)
    playerss.Torso.WaistBackAttachment.Orientation = Vector3.new(-4.16, -179.28, 125.7)
end
if k == "2" and attack == false then
       hum.WalkSpeed = 40
       Speed = 40
       kan.Pitch = 0.92
       kan.SoundId = "rbxassetid://183142252"
		BanishMode = 2
	end

if k == "1" and attack == false then
      hum.WalkSpeed = 24
      Speed = 24
      kan.Pitch = 0.91
      kan.SoundId = "rbxassetid://5801326053"
		BanishMode = 1
	end

if k == "3" and attack == false then
      hum.WalkSpeed = 13.8
      Speed = 13.8
      kan.Pitch = 0.8
      kan.SoundId = "rbxassetid://4565857495"
		BanishMode = 4
	end

if k == "4" and attack == false then
      hum.WalkSpeed = 8
      Speed = 8
      kan.Pitch = 0.9
      kan.SoundId = "rbxassetid://4466439348"
		BanishMode = 5
	end

if k == "5" and attack == false then
      hum.WalkSpeed = 35
      Speed = 35
      kan.Pitch = 1
      kan.SoundId = "rbxassetid://264721135"
		BanishMode = 7
	end

if k == "r" and attack == false then
superjump()
end
if k == "v" and attack == false then
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
g1.CFrame = CFrame.new(playerss:FindFirstChild("HumanoidRootPart").Position,mouse.Hit.p)
game:GetService("Debris"):AddItem(g1,.05)
playerss:FindFirstChild("HumanoidRootPart").CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,3.3,0)
end
plr.Chatted:connect(function(message)
if message == "/sit" and attack == false then
Speed = 0
hum.WalkSpeed = 0
      BanishMode = 2000
    end

if message == "/glitch" and attack == false and BanishMode == 5 then
Speed = 8
hum.WalkSpeed = 8
kan.Pitch = 0.6
      BanishMode = 1000
      kan.Pitch = 0.6
wait(0.02)
      kan.Pitch = 0.5
wait(0.02)
kan.Pitch = 0.467
    end

if message:sub(1,3) == "id/" then
ORGID = message:sub(4)
kan.TimePosition = 0
kan:Play()
elseif message:sub(1,6) == "pitch/" then
ORPIT = message:sub(7)
elseif message:sub(1,4) == "vol/" then
ORVOL = message:sub(5)
elseif message:sub(1,5) == "skip/" then
kan.TimePositcion = message:sub(6)
end
end)
if equipped == true then

if k == "z" and attack == false then
spinnyblade()
end


if k == "x" and attack == false then
eightbitmegablade()
end
if k == "q" and attack == false and BanishMode == 2 then
axeslash()
end
if k == "q" and attack == false and BanishMode == 4 then
darkslash()
end
if k == "q" and attack == false and BanishMode == 5 then
smack()
end
if k == "e" and attack == false and BanishMode == 4 then
darkspin()
end
if k == "c" and attack == false then
bladespinagain()
end
end
if k == "l" and muter == false then
muter = true
kan.Volume = 0
elseif k == "l" and muter == true then
muter = false
if not NoSound then
	kan.Volume = 1.25
end
end
end)


idleanim=.25
while true do
swait()
if muter == false then
if not NoSound then
	kan.Volume = ORVOL
end
else
kan.Volume = 6
end

  sine = sine + change
local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
if equipped==true or equipped==false then
if attack==false then
idle=idle+1
else
idle=0
end
if idle>=500 then
if attack==false then
--Sheath()
end
end
if RootPart.Velocity.y > 1 and hitfloor==nil then 
Anim="Jump"
if attack==false then
RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(-tors.Velocity.Y/6),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(25)),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(-25)),.1)
if equipped == false then
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(130),math.rad(0)),.3)
end
end
elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
Anim="Fall"
if attack==false then
RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(-tors.Velocity.Y/6),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2.5),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(55)),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(-55)),.1)
if equipped == false then
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(130),math.rad(0)),.3)
end
end
elseif torvel<1 and hitfloor~=nil then
Anim="Idle"
if attack==false and BanishMode == 1 then
if equipped == false then
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 20)  - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + 2 * math.cos(sine / 40)),math.rad(-15),math.rad(0 + 2 * math.cos(sine / 20))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 20) - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 - 2 * math.cos(sine / 40)),math.rad(1),math.rad(0 - 2 * math.cos(sine / 20))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.02 * math.cos(sine / 40),-0.05 - 0.05 * math.cos(sine / 20))*angles(math.rad(0 + 2 * math.cos(sine / 20)),math.rad(0 + 2 * math.cos(sine / 40)),math.rad(30 + 3 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0 - 7 * math.cos(sine / 40)),math.rad(-30 - 3 * math.cos(sine / 40))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-6 + 5 * math.cos(sine / 26)),math.rad(-10 - 6 * math.cos(sine / 24)),math.rad(13 - 5 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-13 - 1 * math.cos(sine / 25)),math.rad(10 + 2 * math.cos(sine / 24)),math.rad(10 + 2 * math.cos(sine / 34))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
RH.C0=clerp(RH.C0,cf(1,-0.5 + -0.266 * math.sin(sine / 20)  - 0.05 * math.sin(sine / 40),-0.25)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6 + 4 * math.cos(sine / 40)),math.rad(0 - 8 * math.cos(sine / 40)),math.rad(-10 + 5 * math.cos(sine / 20) - 6 * math.cos(sine / 40))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + -0.266 * math.sin(sine / 20) - 0.05 * math.sin(sine / 40),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6 - 4 * math.cos(sine / 40)),math.rad(10 - 8 * math.cos(sine / 40)),math.rad(10 - 5 * math.cos(sine / 20) - 3 * math.cos(sine / 40))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.05 * math.cos(sine / 40),1 - 0.266 * math.cos(sine / 20))*angles(math.rad(6 + -5 * math.cos(sine / 20)),math.rad(0 + 5 * math.cos(sine / 40)),math.rad(-20 + 16 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20 - 4 * math.sin(sine / 42)),math.rad(0 - 4 * math.sin(sine / 40)),math.rad(20 - 30 * math.sin(sine / 40))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.3 * math.sin(sine / 20),0.1)*angles(math.rad(-13 + 3 * math.cos(sine / 26)),math.rad(-20 - 3 * math.cos(sine / 24)),math.rad(20 - 5 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.3 * math.sin(sine / 20),0.1)*angles(math.rad(-13 - 3 * math.cos(sine / 25)),math.rad(10 + 3 * math.cos(sine / 24)),math.rad(-10 + 5 * math.cos(sine / 34))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(190 + -90 * math.sin(sine / 40)),math.rad(0)),.3)
end
end
if attack==false and BanishMode == 7 then
if equipped == false then
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 20)  - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + 2 * math.cos(sine / 40)),math.rad(-15),math.rad(0 + 2 * math.cos(sine / 20))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 20) - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 - 2 * math.cos(sine / 40)),math.rad(1),math.rad(0 - 2 * math.cos(sine / 20))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.02 * math.cos(sine / 40),-0.05 - 0.05 * math.cos(sine / 20))*angles(math.rad(0 + 2 * math.cos(sine / 20)),math.rad(0 + 2 * math.cos(sine / 40)),math.rad(30 + 3 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2),math.rad(0 - 7 * math.cos(sine / 40)),math.rad(-30 - 3 * math.cos(sine / 40))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-6 + 5 * math.cos(sine / 26)),math.rad(-10 - 6 * math.cos(sine / 24)),math.rad(13 - 5 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-13 - 1 * math.cos(sine / 25)),math.rad(10 + 2 * math.cos(sine / 24)),math.rad(10 + 2 * math.cos(sine / 34))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(190 + -600 * math.sin(sine / 40))),.3)
else
RH.C0=clerp(RH.C0,cf(1,-0.5 + -0.266 * math.sin(sine / 20)  - 0.05 * math.sin(sine / 40),-0.25)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6 + 4 * math.cos(sine / 40)),math.rad(0 - 8 * math.cos(sine / 40)),math.rad(-10 + 5 * math.cos(sine / 20) - 6 * math.cos(sine / 40))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + -0.266 * math.sin(sine / 20) - 0.05 * math.sin(sine / 40),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6 - 4 * math.cos(sine / 40)),math.rad(10 - 8 * math.cos(sine / 40)),math.rad(10 - 5 * math.cos(sine / 20) - 3 * math.cos(sine / 40))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.05 * math.cos(sine / 40),1 - 0.266 * math.cos(sine / 20))*angles(math.rad(6 + -5 * math.cos(sine / 20)),math.rad(0 + 5 * math.cos(sine / 40)),math.rad(10 + 16 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(1+math.random(-10,10)), math.rad(0+math.random(-10,10)), math.rad(0+math.random(-10,10))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.3 * math.sin(sine / 20),0.1)*angles(math.rad(10 + 3 * math.cos(sine / 26)),math.rad(8 - 3 * math.cos(sine / 24)),math.rad(20 - 5 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.3 * math.sin(sine / 20),0.1)*angles(math.rad(10 - 3 * math.cos(sine / 25)),math.rad(10 + 3 * math.cos(sine / 24)),math.rad(-10 + 5 * math.cos(sine / 34))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0.5 + 5 * math.cos(sine / 30),0,-1.5)*angles(math.rad(0),math.rad(0),math.rad(190 + -800 * math.sin(sine / 40))),.3)
end
end
if attack==false and BanishMode == 2 then
if equipped == false then
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 20)  - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + 2 * math.cos(sine / 40)),math.rad(-15),math.rad(0 + 2 * math.cos(sine / 20))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 20) - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 - 2 * math.cos(sine / 40)),math.rad(1),math.rad(0 - 2 * math.cos(sine / 20))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.02 * math.cos(sine / 40),-0.05 - 0.05 * math.cos(sine / 20))*angles(math.rad(0 + 2 * math.cos(sine / 20)),math.rad(0 + 2 * math.cos(sine / 40)),math.rad(30 + 3 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10 - 15 * math.cos(sine / 0.5)),math.rad(5 - 15 * math.cos(sine / 0.5)),math.rad(20 - 20 * math.cos(sine / 0.5))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-6 + 5 * math.cos(sine / 26)),math.rad(-10 - 6 * math.cos(sine / 24)),math.rad(13 - 5 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-13 - 1 * math.cos(sine / 25)),math.rad(10 + 2 * math.cos(sine / 24)),math.rad(10 + 2 * math.cos(sine / 34))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 20)  - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6 + 4 * math.cos(sine / 40)),math.rad(0 - 8 * math.cos(sine / 40)),math.rad(10 + -5 * math.cos(sine / 40) - 6 * math.cos(sine / 40))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 20) - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6 - 4 * math.cos(sine / 40)),math.rad(10 - 8 * math.cos(sine / 40)),math.rad(-10 - -5 * math.cos(sine / 40) - 3 * math.cos(sine / 40))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.06 * math.cos(sine / 40),-0.05 - 0.08 * math.cos(sine / 20))*angles(math.rad(22 + -5 * math.cos(sine / 20)),math.rad(1 + 0.5 * math.cos(sine / 40)),math.rad(-10 + 8 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10 - 15 * math.cos(sine / 0.5)),math.rad(5 - 15 * math.cos(sine / 0.5)),math.rad(20 - 20 * math.cos(sine / 0.5))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.155 * math.sin(sine / 20),0.1)*angles(math.rad(25 + 3 * math.cos(sine / 26)),math.rad(30 - 3 * math.cos(sine / 24)),math.rad(60 - 5 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.155 * math.sin(sine / 20),0.1)*angles(math.rad(25 - 3 * math.cos(sine / 25)),math.rad(10 + 3 * math.cos(sine / 24)),math.rad(-10 + 5 * math.cos(sine / 34))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(180 + -360 * math.sin(sine / 40)),math.rad(0)),.3)
end
end

if attack==false and BanishMode == 4 then
if equipped == false then
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 20)  - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + 2 * math.cos(sine / 40)),math.rad(-15),math.rad(0 + 2 * math.cos(sine / 20))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 20) - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 - 2 * math.cos(sine / 40)),math.rad(1),math.rad(0 - 2 * math.cos(sine / 20))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.02 * math.cos(sine / 40),-0.05 - 0.05 * math.cos(sine / 20))*angles(math.rad(0 + 2 * math.cos(sine / 20)),math.rad(0 + 2 * math.cos(sine / 40)),math.rad(30 + 3 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10 - 15 * math.cos(sine / 0.5)),math.rad(5 - 15 * math.cos(sine / 0.5)),math.rad(20 - 20 * math.cos(sine / 0.5))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-6 + 5 * math.cos(sine / 26)),math.rad(-10 - 6 * math.cos(sine / 24)),math.rad(13 - 5 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-13 - 1 * math.cos(sine / 25)),math.rad(10 + 2 * math.cos(sine / 24)),math.rad(10 + 2 * math.cos(sine / 34))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
RH.C0=clerp(RH.C0,cf(1,-1 + -0.05 * math.cos(sine / 80)  - 0.02 * math.cos(sine / 80),-0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6 + 4 * math.cos(sine / 80)),math.rad(10 - 8 * math.cos(sine / 80)),math.rad(10 + -5 * math.cos(sine / 80) - 6 * math.cos(sine / 80))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 80) - 0.02 * math.cos(sine / 80),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6 - 4 * math.cos(sine / 80)),math.rad(10 - 8 * math.cos(sine / 80)),math.rad(-10 - -5 * math.cos(sine / 80) - 6 * math.cos(sine / 80))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.1 * math.cos(sine / 80),0 - 0.095 * math.cos(sine / 80),-0 - 0.122 * math.cos(sine / 40))*angles(math.rad(12.6 + -5 * math.cos(sine / 40)),math.rad(1 + 0.5 * math.cos(sine / 40)),math.rad(-10 + 8 * math.cos(sine / 80))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(18+math.random(-30,30)), math.rad(0+math.random(-30,30)), math.rad(0+math.random(-30,30))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.2 * math.sin(sine / 40),0.1)*angles(math.rad(20+math.random(-10,10)), math.rad(10+math.random(-10,10)), math.rad(12+math.random(-10,10))),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.2 * math.sin(sine / 40),0.1)*angles(math.rad(25 - 3 * math.cos(sine / 25)),math.rad(30 + 3 * math.sin(sine / 40)),math.rad(-10 + 5 * math.cos(sine / 34))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0 + -0.1 * math.sin(sine / 0.5)),math.rad(180 + -90 * math.sin(sine / 40)),math.rad(0 + -0.1 * math.sin(sine / 0.5))),.3)
end
end

if attack==false and BanishMode == 5 then
if equipped == false then
kan.Pitch = 0.95
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 20)  - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + 2 * math.cos(sine / 40)),math.rad(-15),math.rad(0 + 2 * math.cos(sine / 20))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 20) - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 - 2 * math.cos(sine / 40)),math.rad(1),math.rad(0 - 2 * math.cos(sine / 20))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.02 * math.cos(sine / 40),-0.05 - 0.05 * math.cos(sine / 20))*angles(math.rad(0 + 2 * math.cos(sine / 20)),math.rad(0 + 2 * math.cos(sine / 40)),math.rad(-30 + 10 * math.sin(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(1+math.random(-10,10)), math.rad(0+math.random(-10,10)), math.rad(0+math.random(-10,10))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-6 + 5 * math.cos(sine / 26)),math.rad(-10 - 6 * math.cos(sine / 24)),math.rad(13 - 5 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-13 - 1 * math.cos(sine / 25)),math.rad(10 + 2 * math.cos(sine / 24)),math.rad(10 + 2 * math.cos(sine / 34))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
kan.Pitch = 0.778
RH.C0=clerp(RH.C0,cf(1,-1 + -0.255 * math.cos(sine / 40)  - 0 * math.cos(sine / 40),-0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-8 + 0 * math.cos(sine / 80)),math.rad(0 - 0 * math.cos(sine / 80)),math.rad(0 + -0 * math.cos(sine / 80) - 0 * math.cos(sine / 40))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + -0.255 * math.cos(sine / 40) - 0 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-8 - 0 * math.cos(sine / 80)),math.rad(0 - 0 * math.cos(sine / 80)),math.rad(0 - -0 * math.cos(sine / 80) - 0 * math.cos(sine / 40))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf( 0 + 0 * math.cos(sine / 40),0 - 0 * math.cos(sine / 40),0 - -0.255 * math.cos(sine / 40))*angles(math.rad(1 + -0.1 * math.cos(sine / 40)),math.rad(1 + 0.1 * math.cos(sine / 40)),math.rad(-1 + 2 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(1+math.random(-10,10)), math.rad(0+math.random(-10,10)), math.rad(0+math.random(-10,10))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.585 + -0.277 * math.sin(sine / 40),0.1)*angles(math.rad(-20+math.random(-10,10)), math.rad(10+math.random(-10,10)), math.rad(-150+math.random(-10,10))),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + -0.277 * math.sin(sine / 40),0.1)*angles(math.rad(5 - 3 * math.cos(sine / 25)),math.rad(0 + 10 * math.sin(sine / 40)),math.rad(-12 + -11 * math.cos(sine / 40))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0 + -0 * math.sin(sine / 0.5)),math.rad(-90 + -5 * math.sin(sine / 40)),math.rad(0 + -0.1 * math.sin(sine / 0.5))),.3)
end
end

if attack==false and BanishMode == 1000 then
if equipped == false then
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 20)  - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + 2 * math.cos(sine / 40)),math.rad(-15),math.rad(0 + 2 * math.cos(sine / 20))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 20) - 0.02 * math.cos(sine / 40),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3 - 2 * math.cos(sine / 40)),math.rad(1),math.rad(0 - 2 * math.cos(sine / 20))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.02 * math.cos(sine / 40),-0.05 - 0.05 * math.cos(sine / 20))*angles(math.rad(0 + 2 * math.cos(sine / 20)),math.rad(0 + 2 * math.cos(sine / 40)),math.rad(30 + 3 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(1+math.random(-10,10)), math.rad(0+math.random(-10,10)), math.rad(0+math.random(-10,10))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-6 + 5 * math.cos(sine / 26)),math.rad(-10 - 6 * math.cos(sine / 24)),math.rad(13 - 5 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-13 - 1 * math.cos(sine / 25)),math.rad(10 + 2 * math.cos(sine / 24)),math.rad(10 + 2 * math.cos(sine / 34))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
RH.C0=clerp(RH.C0,cf(1 + 0 * (1+math.random(-10,10)),-1 + -0.255 * (1+math.random(-10,10))  - 0 * (1+math.random(-10,10)),-0 + 0 * (1+math.random(-10,10)))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-8 + 0 * math.cos(sine / 80)),math.rad(0 - 0 * math.cos(sine / 80)),math.rad(0 + -0 * math.cos(sine / 80) - 0 * math.cos(sine / 40))),.1)
LH.C0=clerp(LH.C0,cf(-1 + 0 * (1+math.random(-10,10)),-1 + -0.255 * (1+math.random(-10,10)) - 0 * (1+math.random(-10,10)),0 + 0 * (1+math.random(-10,10)))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-8 - 0 * math.cos(sine / 80)),math.rad(0 - 0 * math.cos(sine / 80)),math.rad(0 - -0 * math.cos(sine / 80) - 0 * math.cos(sine / 40))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf( 0 + 0 * (1+math.random(-10,10)),0 - 0 * (1+math.random(-10,10)),0 - -0.255 * (1+math.random(-2.5,10)))*angles(math.rad(1 + -0.1 * math.cos(sine / 40)),math.rad(1 + 0.1 * math.cos(sine / 40)),math.rad(-10 + 2 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(1+math.random(-10,10)), math.rad(0+math.random(-10,10)), math.rad(0+math.random(-10,10))),.1)
RW.C0=clerp(RW.C0,cf(1.45 + 0 * (1+math.random(-10,10)),0.585 + -0.277 * (1+math.random(-10,10)),-0.15 - 0 * (1+math.random(-10,10)))*angles(math.rad(-20+math.random(-10,10)), math.rad(10+math.random(-10,10)), math.rad(-150+math.random(-10,10))),.1)
LW.C0=clerp(LW.C0,cf(-1.45 + 0 * (1+math.random(-10,10)),0.5 + -0.277 * (1+math.random(-10,10)),0.1 - 0 * (1+math.random(-10,10)))*angles(math.rad(5 - 3 * math.cos(sine / 25)),math.rad(0 + 10 * math.sin(sine / 40)),math.rad(-12 + -11 * math.cos(sine / 40))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0 + -0 * math.sin(sine / 0.5)),math.rad(-90 + -5 * math.sin(sine / 40)),math.rad(0 + -0.1 * math.sin(sine / 0.5))),.3)
end
end

if attack==false and BanishMode == "KAR" then
RH.C0=clerp(RH.C0,cf(1,0.255 + 0.05 * math.cos(sine / 20)  - 0.05 * math.cos(sine / 40),-0.8)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3 + 2 * math.cos(sine / 40)),math.rad(-15),math.rad(0 + 2 * math.cos(sine / 20))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1.45 + 0.05 * math.cos(sine / 20) - 0.02 * math.cos(sine / 40),0)*angles(math.rad(-0),math.rad(-90),math.rad(90))*angles(math.rad(-3 - 2 * math.cos(sine / 40)),math.rad(1),math.rad(0 - 2 * math.cos(sine / 20))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.02 * math.cos(sine / 40),-1.25 - 0.05 * math.cos(sine / 20))*angles(math.rad(0 + 2 * math.cos(sine / 20)),math.rad(0 + 2 * math.cos(sine / 40)),math.rad(0 + 3 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-0 - 40 * math.cos(sine / 0.5)),math.rad(2 - 45 * math.cos(sine / 0.5)),math.rad(0 - 40 * math.cos(sine / 0.5))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(-10 + 5 * math.cos(sine / 26)),math.rad(-10 - 6 * math.cos(sine / 24)),math.rad(-20 - 20 * math.cos(sine / 1))),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(180 - 1 * math.cos(sine / 25)),math.rad(10 + 2 * math.cos(sine / 24)),math.rad(20 + 2 * math.cos(sine / 1))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(190 + -90 * math.sin(sine / 40)),math.rad(0)),.3)
end

if attack==false and BanishMode == 2000 then
RH.C0=clerp(RH.C0,cf(1,-1.45 + 0.05 * math.cos(sine / 20)  - 0.05 * math.cos(sine / 40),0)*angles(math.rad(10),math.rad(90),math.rad(90))*angles(math.rad(-3 + 2 * math.cos(sine / 40)),math.rad(-15),math.rad(0 + 2 * math.cos(sine / 20))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1.45 + 0.05 * math.cos(sine / 20) - 0.05 * math.cos(sine / 40),0)*angles(math.rad(10),math.rad(-90),math.rad(-90))*angles(math.rad(-3 - 2 * math.cos(sine / 40)),math.rad(1),math.rad(0 - 2 * math.cos(sine / 20))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.02 * math.cos(sine / 40),0 - 0.02 * math.cos(sine / 40),-1.75 - 0.05 * math.cos(sine / 20))*angles(math.rad(0 + 2 * math.cos(sine / 20)),math.rad(0 + 2 * math.cos(sine / 40)),math.rad(0 + 3 * math.cos(sine / 40))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-0 - 2 * math.cos(sine / 8)),math.rad(0 - 2 * math.cos(sine / 16)),math.rad(0 - 2 * math.cos(sine / 8))),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(10 + 5 * math.cos(sine / 26)),math.rad(-10 - 4 * math.cos(sine / 24)),math.rad(20 - 2 * math.cos(sine / 24))),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5 + 0.05 * math.cos(sine / 28),0.1)*angles(math.rad(10 - 5 * math.cos(sine / 25)),math.rad(10 + 4 * math.cos(sine / 24)),math.rad(-20 + 2 * math.cos(sine / 24))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(190 + -90 * math.sin(sine / 40)),math.rad(0)),.3)
end

elseif torvel>2 and torvel<42 and hitfloor~=nil then
Anim="Walk"
if attack==false and BanishMode == 1 then
if equipped == false then
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 + 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 8))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5 - 5 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 10 * math.cos(sine / 8))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(0 - 50 * math.cos(sine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 4))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
RH.C0=clerp(RH.C0,cf(1,-0.5 - -0.266 * math.sin(sine / 22),-0.6)*angles(math.rad(-10),math.rad(90),math.rad(-20))*angles(math.rad(0),math.rad(0),math.rad(-4 + 2 * math.sin(sine / 22))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - -0.266 * math.sin(sine / 22),-0)*angles(math.rad(10),math.rad(-90),math.rad(20))*angles(math.rad(0),math.rad(0),math.rad(6 + 2 * math.sin(sine / 22))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,1.1 + 0.34 * math.cos(sine / 22))*angles(math.rad(45 - 2 * math.sin(sine / 22)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 22))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5 + 4 * math.cos(sine / 22)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 10 * math.cos(sine / 22))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.255 * math.sin(sine / 22))*angles(math.rad(-10),math.rad(0),math.rad(15 - 2 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.255 * math.sin(sine / 22))*angles(math.rad(0 + 3 * math.sin(sine / 22)),math.rad(0),math.rad(-5 + 3 * math.sin(sine / 22))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(190 + -90 * math.sin(sine / 40)),math.rad(0)),.3)
end
end
if attack==false and BanishMode == 7 then
if equipped == false then
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 + 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 8))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5 - 5 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 10 * math.cos(sine / 8))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(0 - 50 * math.cos(sine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 4))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
RH.C0=clerp(RH.C0,cf(1,-0.5 - -0.266 * math.sin(sine / 22),-0.6)*angles(math.rad(-10),math.rad(90),math.rad(-20))*angles(math.rad(0),math.rad(0),math.rad(-4 + 2 * math.sin(sine / 22))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - -0.266 * math.sin(sine / 22),-0)*angles(math.rad(10),math.rad(-90),math.rad(20))*angles(math.rad(0),math.rad(0),math.rad(6 + 2 * math.sin(sine / 22))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,1.1 + 0.34 * math.cos(sine / 22))*angles(math.rad(45 - 2 * math.sin(sine / 22)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 22))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(1+math.random(-10,10)), math.rad(0+math.random(-10,10)), math.rad(0+math.random(-10,10))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.255 * math.sin(sine / 22))*angles(math.rad(-10),math.rad(0),math.rad(15 - 2 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.255 * math.sin(sine / 22))*angles(math.rad(0 + 3 * math.sin(sine / 22)),math.rad(0),math.rad(-5 + 3 * math.sin(sine / 22))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0.5 + 5 * math.cos(sine / 30),0,-1.5)*angles(math.rad(0),math.rad(0),math.rad(190 + -800 * math.sin(sine / 40))),.3)
end
end
if attack==false and BanishMode == 2 then
if equipped == false then
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 + 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 8))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5 - 5 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 10 * math.cos(sine / 8))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(0 - 50 * math.cos(sine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 4))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
RH.C0=clerp(RH.C0,cf(1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 85 * math.cos(sine / 6))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 85 * math.cos(sine / 6))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.05 + 0.15 * math.cos(sine / 3))*angles(math.rad(15 - 4 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 6))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-6 - 15 * math.cos(sine / 0.5)),math.rad(6 - 15 * math.cos(sine / 0.5)),math.rad(10 - 20 * math.cos(sine / 0.5))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 4.6))*angles(math.rad(-40),math.rad(0),math.rad(25 - 2 * math.cos(sine / 34))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.5 * math.cos(sine / 6))*angles(math.rad(0 + 140 * math.cos(sine / 6)),math.rad(0),math.rad(-5 + 20 * math.cos(sine / 3))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(190 + -360 * math.sin(sine / 40)),math.rad(0)),.3)
end
end
if attack==false and BanishMode == 4 then
if equipped == false then
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 + 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 8))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20+math.random(-30,30)), math.rad(0+math.random(-30,30)), math.rad(0+math.random(-30,30))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(0 - 50 * math.cos(sine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 4))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 12),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 16)),math.rad(0 + 22 * math.cos(sine / 16))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 12),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 16)),math.rad(0 + 22 * math.cos(sine / 16))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 + 0.05 * math.cos(sine / 12))*angles(math.rad(10 + 3 * math.cos(sine / 12)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 16))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30+math.random(-30,30)), math.rad(0+math.random(-30,30)), math.rad(0+math.random(-30,30))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 16))*angles(math.rad(12 - 12 * math.cos(sine / 16)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 8))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 16))*angles(math.rad(12 + 12 * math.cos(sine / 16)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 8))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(190 + -100 * math.sin(sine / 80)),math.rad(0)),.3)
end
end

if attack==false and BanishMode == 5 then
if equipped == false then
kan.Pitch = 0.95
RH.C0=clerp(RH.C0,cf(1,-1 + 0.2 * math.sin(sine / 8),-0.12 + 0.2 * math.cos(sine / 8))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + -40 * math.cos(sine / 8))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + -0.2 * math.sin(sine / 8),-0.12 + -0.2 * math.cos(sine / 8))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + -40 * math.cos(sine / 8))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 + 0.05 * math.cos(sine / 4))*angles(math.rad(10 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1),math.rad(0 - root.RotVelocity.Y - 6 * math.sin(sine / 8))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(3+math.random(-10,10)), math.rad(0+math.random(-25,12)), math.rad(0+math.random(-10,10))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + -0.25 * math.sin(sine / 8))*angles(math.rad(12 + 18 * math.cos(sine / 8)),math.rad(0),math.rad(0 + 0 * math.cos(sine / 4))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - -0.25 * math.sin(sine / 8))*angles(math.rad(12 + -18 * math.cos(sine / 8)),math.rad(0),math.rad(0 + 0 * math.cos(sine / 4))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
kan.Pitch = 0.778
RH.C0=clerp(RH.C0,cf(1,-1 + 0.2 * math.sin(sine / 12),-0.12 + 0.2 * math.cos(sine / 12))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 12)),math.rad(0 + -22 * math.cos(sine / 12))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + -0.2 * math.sin(sine / 12),-0.12 + -0.2 * math.cos(sine / 12))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 12)),math.rad(0 + -22 * math.cos(sine / 12))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 + 0.05 * math.cos(sine / 6))*angles(math.rad(10 + 3 * math.cos(sine / 6)),math.rad(0 + root.RotVelocity.Y/0.6),math.rad(0 - root.RotVelocity.Y - 6 * math.sin(sine / 12))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(3+math.random(-10,10)), math.rad(0+math.random(-25,12)), math.rad(0+math.random(-10,10))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + -0.25 * math.sin(sine / 12))*angles(math.rad(12 + 18 * math.cos(sine / 12)),math.rad(0),math.rad(0 + 0 * math.cos(sine / 6))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - -0.25 * math.sin(sine / 12))*angles(math.rad(95 + -3 * math.cos(sine / 12)),math.rad(0),math.rad(0 + 0 * math.cos(sine / 6))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(-90 + -2 * math.sin(sine / 80)),math.rad(0)),.3)
end
end

if attack==false and BanishMode == 1000 then
if equipped == false then
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 + 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 8))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20+math.random(-100,100)), math.rad(0+math.random(-100,100)), math.rad(0+math.random(-100,100))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(0 - 50 * math.cos(sine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 4))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
RH.C0=clerp(RH.C0,cf(1 + 0.2 * (1+math.random(-5,5)),-1 + 0.2 * (1+math.random(-5,5)),0 + 0.1 * (1+math.random(-5,5)))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 18)),math.rad(0 + -22 * math.cos(sine / 18))),.1)
LH.C0=clerp(LH.C0,cf(-1 + 0.2 * (1+math.random(-5,5)),-1 + 0.2 * (1+math.random(-5,5)),0 + -0.1 * (1+math.random(-5,5)))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 18)),math.rad(0 + -22 * math.cos(sine / 18))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(-0 + 0.05 * (1+math.random(-10,10)),-0.05 + 0.05 * (1+math.random(-10,10)),-0.05 + 0.05 * (1+math.random(-10,10)))*angles(math.rad(10 + 3 * math.cos(sine / 9)),math.rad(0 + root.RotVelocity.Y/1),math.rad(0 - root.RotVelocity.Y - -6 * math.sin(sine / 18))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(3+math.random(-100,100)), math.rad(0+math.random(-100,100)), math.rad(0+math.random(-100,100))),.1)
RW.C0=clerp(RW.C0,cf(1.5 + 0.05 * (1+math.random(-20,20)),0.5 + 0.05 * (1+math.random(-20,20)),0 + 0.05 * (1+math.random(-20,20)))*angles(math.rad(-20+math.random(-10,10)), math.rad(0+math.random(-10,10)), math.rad(215+math.random(-10,10))),.1)
LW.C0=clerp(LW.C0,cf(-1.5 + 0.05 * (1+math.random(-20,20)),0.5 + 0.05 * (1+math.random(-20,20)),0 - -0.25 * (1+math.random(-20,20)))*angles(math.rad(12 + -18 * math.cos(sine / 18)),math.rad(0),math.rad(0 + 0 * math.cos(sine / 9))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(-90 + -2 * math.sin(sine / 80)),math.rad(0)),.3)
end
end

if attack==false and BanishMode == 3 then
if equipped == false then
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 + 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 8))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5 - 5 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 10 * math.cos(sine / 8))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(0 - 50 * math.cos(sine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 4))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(-3,0,-0.5)*angles(math.rad(0),math.rad(0),math.rad(-40)),.3)
else
RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 45 * math.cos(sine / 8))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 + 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 8))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-0 - 35 * math.cos(sine / 0.5)),math.rad(10 - 30 * math.cos(sine / 0.5)),math.rad(0 - 25 * math.cos(sine / 0.5))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(0 - 50 * math.cos(sine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 4))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
weaponweld.C1=clerp(weaponweld.C1,cf(0,1,0)*angles(math.rad(0),math.rad(190 + -999 * math.sin(sine / 40)),math.rad(0)),.3)
end
end
elseif torvel>=42 and hitfloor~=nil then
Anim="Run"
if attack==false then
RH.C0=clerp(RH.C0,cf(1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 85 * math.cos(sine / 6))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.15 * math.cos(sine / 3),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 + 85 * math.cos(sine / 6))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.05 + 0.15 * math.cos(sine / 3))*angles(math.rad(15 - 4 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 6))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5 + 4 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 10 * math.cos(sine / 6))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.5 * math.cos(sine / 6))*angles(math.rad(0 - 140 * math.cos(sine / 6)),math.rad(0),math.rad(5 - 20 * math.cos(sine / 3))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.5 * math.cos(sine / 6))*angles(math.rad(0 + 140 * math.cos(sine / 6)),math.rad(0),math.rad(-5 + 20 * math.cos(sine / 3))),.1)
end
end
end
end
------
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe ban sword",
	Callback = function()
		Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
-----OPTIONS
 
local IsDead = false
local StateMover = true
 
local playerss = workspace.non
local bbv,bullet
if Bypass == "death" then
	bullet = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	bullet.Transparency = 0
	bullet.Massless = true
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end
 
	bbv = Instance.new("BodyPosition",bullet)
    bbv.Position = playerss.Torso.CFrame.p
end
 
if Bypass == "death" then
coroutine.wrap(function()
	while true do
		if not playerss or not playerss:FindFirstChildOfClass("Humanoid") or playerss:FindFirstChildOfClass("Humanoid").Health <= 0 then IsDead = true; return end
		if StateMover then
			bbv.Position = playerss.Torso.CFrame.p
    		bullet.Position = playerss.Torso.CFrame.p
		end
		game:GetService("RunService").RenderStepped:wait()
	end
end)()
end
 
local CDDF = {}
local DamageFling = function(DmgPer)
	if IsDead or Bypass ~= "death" or (DmgPer.Name == playerss.Name and DmgPer.Name == "non") or CDDF[DmgPer] or not DmgPer or not DmgPer:FindFirstChildOfClass("Humanoid") or DmgPer:FindFirstChildOfClass("Humanoid").Health <= 0 then return end
	CDDF[DmgPer] = true; StateMover = false
	local PosFling = (DmgPer:FindFirstChild("HumanoidRootPart") and DmgPer:FindFirstChild("HumanoidRootPart") .CFrame.p) or (DmgPer:FindFirstChildOfClass("Part") and DmgPer:FindFirstChildOfClass("Part").CFrame.p)
    bbav = Instance.new("BodyAngularVelocity",bullet)
    bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
    bbav.P = 1000000000000000000000000000
    bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
    game:GetService("Debris"):AddItem(bbav,0.1)
    bullet.Rotation = playerss.Torso.Rotation
	for _=1,15 do
		bbv.Position = PosFling
		bullet.Position = PosFling
		wait(0.03)
	end
	bbv.Position = playerss.Torso.CFrame.p
    bullet.Position = playerss.Torso.CFrame.p
	CDDF[DmgPer] = false; StateMover = true
end
 
 
 
local plr = game.Players.LocalPlayer
local char = workspace.non
local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")
 
 
-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")
 
frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false
 
 
lastframe = tick()
script.Heartbeat:Fire()
 
local Plr = game:GetService("Players").LocalPlayer
local Player = game:GetService("Players").LocalPlayer
local Character = workspace.non
 
 
 
 
local Hats = {
    gun = Character:WaitForChild("MeshPartAccessory"),
 
}
Hats.gun.Handle.AccessoryWeld:Remove()
local function align(i,v)
local att0 = Instance.new("Attachment", i)
att0.Position = Vector3.new(0,0,0)
local att1 = Instance.new("Attachment", v)
att1.Position = Vector3.new(0,-0.9,-2.6)
local AP = Instance.new("AlignPosition", i)
AP.Attachment0 = att0
AP.Attachment1 = att1
AP.RigidityEnabled = false
AP.ReactionForceEnabled = false
AP.ApplyAtCenterOfMass = true
AP.MaxForce = 9999999
AP.MaxVelocity = math.huge
AP.Responsiveness = 1000000000000
local AO = Instance.new("AlignOrientation", i)
AO.Attachment0 = att0
AO.Attachment1 = att1
AO.ReactionTorqueEnabled = true
AO.PrimaryAxisOnly = false
AO.MaxTorque = 9999999
AO.MaxAngularVelocity = math.huge
AO.Responsiveness = 10000000000000
end
align(Hats.gun.Handle, Character["Right Arm"])
 
Hats.gun.Handle.Attachment.Orientation = Vector3.new(223,-90,0)
 
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------
 
-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
local Create = function(c)
    return function(p)
        local i = Instance.new(c)
        for k,v in pairs(p) do i[k] = v end
        return i
    end
end
 
-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent.Name ~= plr.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:GetService("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------
 
-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------
 
function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end
 
 
CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end
 
 
-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end
 
function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 1
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end
 
function Eviscerate(dude)
	if dude.Name ~= char.Name and dude.Name ~= plr.Name then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Part") or v:IsA("MeshPart") then
						coroutine.resume(coroutine.create(function()
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							coroutine.resume(coroutine.create(function()
								wait(0.5)
								PartEmmit1.Enabled = false
								wait(3)
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end
 
function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end
 
function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 1
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end
 
function SoulSteal(dude)
if dude.Name ~= char.Name and dude.Name ~= plr.Name then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
function chatfunc(text, color)
	local chat = coroutine.wrap(function()
		if char:FindFirstChild("TalkingBillBoard") ~= nil then
			char:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local naeeym2 = Instance.new("BillboardGui", char)
		naeeym2.Size = UDim2.new(0, 100, 0, 40)
		naeeym2.StudsOffset = Vector3.new(0, 5, 0)
		naeeym2.Adornee = hed
		naeeym2.Name = "TalkingBillBoard"
		local tecks2 = Instance.new("TextLabel", naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SciFi"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 1
		tecks2.TextColor3 = color
		tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
		tecks2.Size = UDim2.new(1, 0, 0.5, 0)
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
				tecks2.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
				tecks2.Rotation = math.random(-5, 5)
			end
		end))
		for i = 1, string.len(text) do
			CFuncs.Sound.Create("rbxassetid://274118116", hed, 5.25, 0.115)
			tecks2.Text = string.sub(text, 1, i)
			swait(1)
		end
		wait(1)
		naeeym2:Destroy()
	end)
	chat()
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------
 
 
-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 703597239
local SONG2 = 853707984
local Music = Instance.new("Sound",tors)
Music.Volume = 2.5
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
----------------------------------------------------------------------------------
hum.WalkSpeed = 16
hum.JumpPower = 57
hum.Animator.Parent = nil
----------------------------------------------------------------------------------
local Blobby = Instance.new("Part", char)
Blobby.Name = "Blob"
Blobby.CanCollide = false
Blobby.BrickColor = BrickColor.new("Really black")
Blobby.Transparency = 1
Blobby.Material = "Plastic"
Blobby.Size = Vector3.new(1, 1, 2)
Blobby.TopSurface = Enum.SurfaceType.Smooth
Blobby.BottomSurface = Enum.SurfaceType.Smooth
 
local Weld = Instance.new("Weld", Blobby)
Weld.Part0 = ra
Weld.Part1 = Blobby
Weld.C1 = CFrame.new(0, -2, 1.1)
Weld.C0 = CFrame.Angles(Rad(-86),0,0)
 
local M2 = Instance.new("SpecialMesh")
M2.Parent = Blobby
M2.MeshId = "http://www.roblox.com/asset/?id=10604848"
M2.TextureId = "http://www.roblox.com/asset/?id=10605252"
M2.Scale = Vector3.new(1, 1, 1)
 
--[[local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0, 3.5, 0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"
--naeeym2.PlayerToHideFrom = Player
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Fight Me"
tecks2.Font = Enum.Font.Bodoni
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 1
tecks2.TextColor3 = Color3.new(0, 0, 0)
tecks2.TextStrokeColor3 = Color3.new(1, 1, 1)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2]]
-------------------------------------------------------
--End Customization--
-------------------------------------------------------
 
 
-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
function Ban()
	attack = true
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
 	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 9.5)) do
		DamageFling(v)
	end
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
	attack = false
end
function BigBan()
	attack = true
	Weld.C0 = CFrame.Angles(Rad(-90), Rad(-25), Rad(0))
	for i = 0, 3.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-6), Rad(45)), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
 	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 14.5)) do
		DamageFling(v)
	end
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(75), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-6), Rad(45)), 0.2)
	end
	Weld.C0 = CFrame.Angles(Rad(-86),0,0)
	attack = false
end
function BANN()
	attack = true
	M2.Scale = Vector3.new(2, 2, 2)
	for i = 0, 4.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(-20)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(.6* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-.8* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(156), Rad(-.6), Rad(45)), 0.2)
	end
	Cso("147722910", char, 10, 1)
	CameraEnshaking(2, 35)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
	Effects.Ring.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0) * angles(math.rad(90), math.rad(0), math.rad(0)), 0.5, 0.5, 0.1, 2, 2, 0, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 7, 10, 15, -0.1, 15, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 6, 10, 15, -0.1, 15, 0.02)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 4, 10, 15, -0.1, 15, 0.01)
 	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 19.5)) do
		DamageFling(v)
	end
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
	M2.Scale = Vector3.new(1, 1, 1)
	attack = false
end
-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 2
        hum.WalkSpeed = 38.82
	end
end)
mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 1
        hum.WalkSpeed = 16
	end
end)
mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 'e' then
			BigBan()
		elseif key == 'r' then
			BANN()
		elseif key == 't' then
			Cso("1450018171", hed, 10, 1)
		end
	end
end)
mouse.Button1Down:connect(function(key)
	if attack == false then
		Ban()
	end
end)
 
 
 
 
 
 
 
-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		--Aura(5, 0.15, "Add", root.CFrame * CFrame.new(math.random(-5, 5), -10, math.random(-5, 5)) * CFrame.Angles(math.rad(90), 0, 0), 1.5, 1.5, 10, -0.015, maincolor, 0, "Sphere")
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(190), Rad(-.6), Rad(13)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel > 2 and torvel < 25 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(6 - 6.5 * Sin(sine / 7)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8* Player_Size - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8* Player_Size + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(190) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-37)  * Cos(sine / 7) , Rad(8 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
			end
		elseif torvel >= 25 and hitfloor ~= nil then
			Anim = "Sprint"
			change = 1.35
			if attack == false then
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
			RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925* Player_Size - 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         	LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925* Player_Size + 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(215) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-75) , Rad(8 * Cos(sine / 7)) ,	Rad(-13) + la.RotVelocity.Y / 75), 0.15)
			end
		end
	end
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 1.5
	Music.Parent = tors
	Music:Resume()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe neptunian V (free)",
	Callback = function()
		loadstring(game:HttpGet("https://pastebin.com/raw/mPU8ujvn", true))()
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe zen (free)",
	Callback = function()
		loadstring(game:HttpGet('https://pastebin.com/raw/dC8vY4YU'))()
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe mad man",
	Callback = function()
		


--Netless is activated------
------------------------
--Keybinds:-------------
--Click - Punch---------
--C - Crouch------------
------------------------
--The Main Script------
----------------------
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
game:GetService("RunService").Heartbeat:connect(function()
v.Velocity = Vector3.new(0,35,0)
wait(0.5)
end)
end
end

game:GetService("StarterGui"):SetCore("SendNotification", { 
	Title = "Notification";
	Text = "Netless activated";
	Icon = "rbxthumb://type=Asset&id=5107182114&w=150&h=150"})
Duration = 16;

HumanDied = false
local reanim
function noplsmesh(hat)
_G.OldCF=workspace.Camera.CFrame
oldchar=game.Players.LocalPlayer.Character
game.Players.LocalPlayer.Character=workspace[game.Players.LocalPlayer.Name]
for i,v in next, workspace[game.Players.LocalPlayer.Name][hat]:GetDescendants() do
if v:IsA('Mesh') or v:IsA('SpecialMesh') then
v:Remove()
end
end
game.Players.LocalPlayer.Character=oldchar
wait()
workspace.Camera.CFrame=_G.OldCF
game.Players.LocalPlayer.Character=oldchar
end
_G.ClickFling=false -- Set this to true if u want.
loadstring(game:HttpGet(('https://raw.githubusercontent.com/OofHead-FE/nexo-before-deleted/main/NexoPD'),true))()

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

speed = 1
sine = 1
srv = game:GetService('RunService')

function hatset(yes,part,c1,c0,nm)
reanim[yes].Handle.AccessoryWeld.Part1=reanim[part]
reanim[yes].Handle.AccessoryWeld.C1=c1 or CFrame.new()
reanim[yes].Handle.AccessoryWeld.C0=c0 or CFrame.new()--3bbb322dad5929d0d4f25adcebf30aa5
if nm==true then
noplsmesh(yes)
end
end

--put the hat script converted below

reanim = game.Players.LocalPlayer.Character.CWExtra.NexoPD
RJ = reanim.HumanoidRootPart.RootJoint
RS = reanim.Torso['Right Shoulder']
LS = reanim.Torso['Left Shoulder']
RH = reanim.Torso['Right Hip']
LH = reanim.Torso['Left Hip']
Root = reanim.HumanoidRootPart
NECK = reanim.Torso.Neck
NECK.C0 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
NECK.C1 = CF(0,-0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C1 = CF(-0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C1 = CF(0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))

Mode='1'

mousechanger=game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(k)
if k == 'q' then-- first mode
Mode='1'
elseif k == 'c' then-- second mode
Mode='2'
elseif k == 'ayowtf' then-- third mode
Mode='3'
end
end)



attacklol=game.Players.LocalPlayer:GetMouse().Button1Down:Connect(function()
Mode='Attack0'
wait(0.3) -- Time Of Attack
Mode='Attack1'
wait(0.2) -- Time Of Attack
Mode='Attack2'
end)



coroutine.wrap(function()
while true do -- anim changer
if HumanDied then mousechanger:Disconnect() break end
sine = sine + speed
local rlegray = Ray.new(reanim["Right Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)
local llegray = Ray.new(reanim["Left Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)
local rightvector = (Root.Velocity * Root.CFrame.rightVector).X + (Root.Velocity * Root.CFrame.rightVector).Z
local lookvector = (Root.Velocity * Root.CFrame.lookVector).X + (Root.Velocity * Root.CFrame.lookVector).Z
if lookvector > reanim.Humanoid.WalkSpeed then
lookvector = reanim.Humanoid.WalkSpeed
end
if lookvector < -reanim.Humanoid.WalkSpeed then
lookvector = -reanim.Humanoid.WalkSpeed
end
if rightvector > reanim.Humanoid.WalkSpeed then
rightvector = reanim.Humanoid.WalkSpeed
end
if rightvector < -reanim.Humanoid.WalkSpeed then
rightvector = -reanim.Humanoid.WalkSpeed
end
local lookvel = lookvector / reanim.Humanoid.WalkSpeed
local rightvel = rightvector / reanim.Humanoid.WalkSpeed
if Mode == '1' then
if Root.Velocity.y > 1 then -- jump
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*ANGLES(RAD(3+0*math.cos(sine/10)),RAD(0+0*math.cos(sine/10)),RAD(0+0*math.cos(sine/10))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-8+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0*math.cos(sine/6),0.2+0.05*math.cos(sine/6),0+0*math.cos(sine/6))*ANGLES(RAD(-24+0*math.cos(sine/6)),RAD(0+0*math.cos(sine/6)),RAD(10+0*math.cos(sine/6))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.5+0*math.cos(sine/6),1+0.05*math.cos(sine/6),-0.2+0*math.cos(sine/6))*ANGLES(RAD(141+0*math.cos(sine/6)),RAD(0+0*math.cos(sine/6)),RAD(0+0*math.cos(sine/6))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/6),-0.4+0*math.cos(sine/6),-0.3+0*math.cos(sine/6))*ANGLES(RAD(1+0*math.cos(sine/6)),RAD(-8+0*math.cos(sine/6)),RAD(5+0*math.cos(sine/6))),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/6),0+0*math.cos(sine/6),-1+0*math.cos(sine/6))*ANGLES(RAD(-22+0*math.cos(sine/6)),RAD(0+0*math.cos(sine/6)),RAD(-6+0*math.cos(sine/6))),.3)
elseif Root.Velocity.y < -1 then -- fall
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*ANGLES(RAD(-26+0*math.cos(sine/10)),RAD(0+0*math.cos(sine/10)),RAD(0+0*math.cos(sine/10))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-8+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0*math.cos(sine/6),0.4+0.05*math.cos(sine/6),-0.2+0*math.cos(sine/6))*ANGLES(RAD(16+0*math.cos(sine/6)),RAD(7+0*math.cos(sine/6)),RAD(32+0*math.cos(sine/6))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.5+0*math.cos(sine/6),0.4+0.05*math.cos(sine/6),-0.2+0*math.cos(sine/6))*ANGLES(RAD(25+0*math.cos(sine/6)),RAD(0+0*math.cos(sine/6)),RAD(-28+0*math.cos(sine/6))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/6),-0.4+0*math.cos(sine/6),-0.3+0*math.cos(sine/6))*ANGLES(RAD(1+0*math.cos(sine/6)),RAD(-8+0*math.cos(sine/6)),RAD(5+0*math.cos(sine/6))),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/6),-0.3+0*math.cos(sine/6),-1+0*math.cos(sine/6))*ANGLES(RAD(-22+0*math.cos(sine/6)),RAD(0+0*math.cos(sine/6)),RAD(-6+0*math.cos(sine/6))),.3)
elseif Root.Velocity.Magnitude < 2 then -- idle
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*ANGLES(RAD(0+-2*math.cos(sine/10)),RAD(0+0*math.cos(sine/10)),RAD(0+0*math.cos(sine/10))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/10),-0.6+0.1*math.cos(sine/10),0+0*math.cos(sine/10))*ANGLES(RAD(0+0*math.cos(sine/10)),RAD(0+0*math.cos(sine/10)),RAD(0+0*math.cos(sine/10))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0*math.cos(sine/10),0.2+0.05*math.cos(sine/10),0+0*math.cos(sine/10))*ANGLES(RAD(45+0*math.cos(sine/10)),RAD(0+0*math.cos(sine/10)),RAD(10+0*math.cos(sine/10))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.5+0*math.cos(sine/10),0.2+0.05*math.cos(sine/10),0+0*math.cos(sine/10))*ANGLES(RAD(36+0*math.cos(sine/10)),RAD(0+0*math.cos(sine/10)),RAD(-8+0*math.cos(sine/10))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/10),-0.4+-0.1*math.cos(sine/10),-0.3+0*math.cos(sine/10))*ANGLES(RAD(1+0*math.cos(sine/10)),RAD(-31+0*math.cos(sine/10)),RAD(5+0*math.cos(sine/10))),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/10),-0.38+-0.1*math.cos(sine/10),-0.2+0*math.cos(sine/10))*ANGLES(RAD(0+0*math.cos(sine/10)),RAD(39+0*math.cos(sine/10)),RAD(-4+0*math.cos(sine/10))),.3)
elseif Root.Velocity.Magnitude < 20 then -- walk
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*ANGLES(RAD(1+0*math.cos(sine/10)),RAD(0+0*math.cos(sine/10)),RAD(0+0*math.cos(sine/10))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/3),-0.6+0.1*math.cos(sine/3),0+0*math.cos(sine/3))*ANGLES(RAD(-8+0*math.cos(sine/3)),RAD(0+0*math.cos(sine/3)),RAD(0+0*math.cos(sine/3))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0*math.cos(sine/6),0.2+0.05*math.cos(sine/6),0+0*math.cos(sine/6))*ANGLES(RAD(45+-7*math.cos(sine/6)),RAD(0+-59*math.cos(sine/6)),RAD(47+0*math.cos(sine/6))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.5+0*math.cos(sine/6),0.2+0.05*math.cos(sine/6),0+0*math.cos(sine/6))*ANGLES(RAD(36+17*math.cos(sine/6)),RAD(0+-81*math.cos(sine/6)),RAD(-51+0*math.cos(sine/6))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/6),-0.4+-0.1*math.cos(sine/6),-0.3+0*math.cos(sine/6))*ANGLES(RAD(1+32*math.cos(sine/6)),RAD(-8+0*math.cos(sine/6)),RAD(5+0*math.cos(sine/6))),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/6),-0.38+0*math.cos(sine/6),-0.2+0*math.cos(sine/6))*ANGLES(RAD(1.2+-32*math.cos(sine/6)),RAD(16+0*math.cos(sine/6)),RAD(-4+0*math.cos(sine/6))),.3)
elseif Root.Velocity.Magnitude > 20 then -- run
--run clerp here
end
elseif Mode == '2' then
if Root.Velocity.y > 1 then -- jump
--jump clerp here
elseif Root.Velocity.y < -1 then -- fall
--fall clerp here
elseif Root.Velocity.Magnitude < 2 then -- idle
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-57+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-51+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1.2+0*math.cos(sine/13),0.5+0*math.cos(sine/13),-0.5+0*math.cos(sine/13))*ANGLES(RAD(143+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-26+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.3+0*math.cos(sine/13),0.5+0*math.cos(sine/13),-0.5+0*math.cos(sine/13))*ANGLES(RAD(141+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(25+0*math.cos(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),0.82+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(51+0*math.cos(sine/13)),RAD(-14+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),0.82+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(51+0*math.cos(sine/13)),RAD(14+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Root.Velocity.Magnitude < 20 then -- walk
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(54+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-90+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),1+-0.4*math.cos(sine/13),-1+0*math.cos(sine/13))*ANGLES(RAD(181+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),1+0.4*math.cos(sine/13),-1+0*math.cos(sine/13))*ANGLES(RAD(180+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),0+0.3*math.cos(sine/13),-1+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),0+-0.3*math.cos(sine/13),-1+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(1+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Root.Velocity.Magnitude > 20 then -- run
--jopa
end
elseif Mode == '3' then
if Root.Velocity.y > 1 then -- jump
--jump clerp here
elseif Root.Velocity.y < -1 then -- fall
--fall clerp here
elseif Root.Velocity.Magnitude < 2 then -- idle
--idle clerp here
elseif Root.Velocity.Magnitude < 20 then -- walk
--walk clerp here
elseif Root.Velocity.Magnitude > 20 then -- run
--run clerp here
end
elseif Mode == 'Attack0' then
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-6+0*math.cos(sine/13)),RAD(30+0*math.cos(sine/13)),RAD(5+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(3+0*math.cos(sine/13)),RAD(-31+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0.3+0*math.cos(sine/13))*ANGLES(RAD(88+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.5+0*math.cos(sine/13),0.3+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(92+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-31+0*math.cos(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-6+0*math.cos(sine/13)),RAD(-19+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-4+0*math.cos(sine/13)),RAD(12+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Mode == 'Attack1' then
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-6+0*math.cos(sine/13)),RAD(-28+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-13+0*math.cos(sine/13)),RAD(23+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0*math.cos(sine/13),0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13))*ANGLES(RAD(88+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-26+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.5+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-22+0*math.cos(sine/13)),RAD(5+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-0.82+0*math.cos(sine/13),-0.4+0*math.cos(sine/13))*ANGLES(RAD(-2+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Mode == 'Attack2' then
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-6+0*math.cos(sine/13)),RAD(-28+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-6+0*math.cos(sine/13)),RAD(30+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(81+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(3+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.5+0*math.cos(sine/13),0.2+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(5+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
end
srv.RenderStepped:Wait()
end
end)()

--This was copied from neptunian V
local muter = false
local ORGID = 6214466272
local ORVOL = 1.15
local ORPIT = 1.01
local kan = Instance.new("Sound",char)
kan.Volume = 0
if not NoSound then
	kan.Volume = 1.15
end
kan.TimePosition = 0
kan.PlaybackSpeed = 1.01
kan.Pitch = 1.01
kan.SoundId = "rbxassetid://6214466272"
kan.Name = "mariowashere"
kan.Looped = true
kan:Play()
--Created using Nexo Animator
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe soldier (free)",
	Callback = function()
		loadstring(game:HttpGet('https://pastebin.com/raw/EURiWBBn'))()
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe elio blasio (free)",
	Callback = function()
--hat needed: https://www.roblox.com/catalog/7806887000/CR-L-4-Back
--// SETTINGS \\ --

local Fling = true --// Recommended: true
local FlingBlockInvisible = false --// Recommended: false (So you can see the flinging block)
local HighlightFlingBlock = false --// Recommended: true
local FlingHighlightColor = Color3.fromRGB(55,55,255) --// First is R, Second is G, Third is B
local GunHatId = 6678230540 -- // (https://www.roblox.com/catalog/7806887000/CR-L-4-Back)
--// GunHatId is the HatId you will use as the gun for the script, you must have the hat equipped.




-- // MAIN \\ --

local HAT_NAME = game:GetObjects("rbxassetid://"..tostring(GunHatId))[1].Name

-- // Uses Mizt's bypass \\ --

Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()

local IsDead = false
local StateMover = true

local playerss = workspace.non
local bbv,bullet
if Bypass == "death" then
	bullet = game.Players.LocalPlayer.Character["Torso"]
	bullet.Transparency = (FlingBlockInvisible ~= true and 0 or 1)
	bullet.Massless = true
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end

	bbv = Instance.new("BodyPosition",bullet)
    bbv.Position = playerss.Torso.CFrame.p
end

if Bypass == "death" then
coroutine.wrap(function()
	while true do
		if not playerss or not playerss:FindFirstChildOfClass("Humanoid") or playerss:FindFirstChildOfClass("Humanoid").Health <= 0 then IsDead = true; return end
		if StateMover then
			bbv.Position = playerss.Torso.CFrame.p
    		bullet.Position = playerss.Torso.CFrame.p
		end
		game:GetService("RunService").RenderStepped:wait()
	end
end)()
end

--[[local force = Instance.new("BodyForce",bullet)
force.Force = Vector3.new(800,800,800)]]--

if HighlightFlingBlock ~= false then
    local Highlight = Instance.new("SelectionBox")
    Highlight.Adornee = bullet
    Highlight.Color3 = (typeof(FlingHighlightColor)=="Color3" and FlingHighlightColor) or (Color3.fromRGB(55,55,255))
    Highlight.Parent = bullet
    Highlight.Name = "HighlightBox"
end

bbav = Instance.new("BodyAngularVelocity",bullet)
    bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
    bbav.P = 100000000000000000000000000000
    bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)

local CDDF = {}
local DamageFling = function(DmgPer)
    if Fling ~= true then return end
	if IsDead or Bypass ~= "death" or (DmgPer.Name == playerss.Name and DmgPer.Name == "non") or CDDF[DmgPer] or not DmgPer or not DmgPer:FindFirstChildOfClass("Humanoid") or DmgPer:FindFirstChildOfClass("Humanoid").Health <= 0 then return end
	CDDF[DmgPer] = true; StateMover = false
	local PosFling = (DmgPer:FindFirstChild("HumanoidRootPart") and DmgPer:FindFirstChild("HumanoidRootPart") .CFrame.p) or (DmgPer:FindFirstChildOfClass("Part") and DmgPer:FindFirstChildOfClass("Part").CFrame.p)
    bullet.Rotation = playerss.Torso.Rotation
    bbav = Instance.new("BodyAngularVelocity",bullet)
    bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
    bbav.P = 100000000000000000000000000000
    bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)

	for _=1,15 do
		bbv.Position = PosFling
		bullet.Position = PosFling
		wait(0.03)
	end
	bbav:Destroy()
	bbv.Position = playerss.Torso.CFrame.p
    bullet.Position = playerss.Torso.CFrame.p
	CDDF[DmgPer] = false; StateMover = true
end

wait(.2)
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
game:GetService("RunService").Heartbeat:connect(function()
v.Velocity = Vector3.new(0,30,0)
wait(0.5)
end)
end
end

local Aligns = 0
function Align(Part0,Part1,Position,Rotation)
    Aligns = Aligns + 1
	local a0,a1 = Instance.new("Attachment",Part0), Instance.new("Attachment",Part1)
	a1.Position = Position or Vector3.new()
	a1.Rotation = Rotation or Vector3.new()
	local ap = Instance.new("AlignPosition", Part0)
	ap.Attachment0 = a0
	ap.Attachment1 = a1
	local ao = Instance.new("AlignOrientation", Part0)
	ao.Name = "AO-"..Aligns
	ap.Name = "AP-"..Aligns
	ao.Attachment0 = a0
	ao.Attachment1 = a1
	ap.ApplyAtCenterOfMass = true;
	ap.MaxForce = 67752;
	ap.MaxVelocity = math.huge/9e110;
	ap.ReactionForceEnabled = false;
	ap.Responsiveness = 200;
	ap.RigidityEnabled = false;
	ao.MaxAngularVelocity = math.huge/9e110;
	ao.MaxTorque = 67752;
	ao.PrimaryAxisOnly = false;
	ao.ReactionTorqueEnabled = false;
	ao.Responsiveness = 200;
	ao.RigidityEnabled = false;
	return a1
end

local HumanoidIsDead = false

local Player=game.Players.LocalPlayer
local Character=workspace.non
local Gun = Character[HAT_NAME]
local GunHandle = Gun.Handle
GunHandle.AccessoryWeld:Destroy()
GunHandle.SpecialMesh:Destroy()
wait()
GunHandle.Parent=workspace
local hum = Character.Humanoid
local LeftArm=Character["Left Arm"]
local LeftLeg=Character["Left Leg"]
local RightArm=Character["Right Arm"]
local RightLeg=Character["Right Leg"]
local Root=Character["HumanoidRootPart"]
local Head=Character["Head"]
local Torso=Character["Torso"]
local Neck=Torso["Neck"]
local mouse = Player:GetMouse()
local walking = false
local jumping = false
local attacking = false
local firsttime = false
local tauntdebounce = false
local position = nil
local MseGuide = true
local running = false
local settime = 0
local sine = 0
local t = 0
local ws = 18
local change = 1
local combo1 = true
local equip = false
local dgs = 75
local combo2 = false
local switch1 = true
local switch2 = false
local firsttime2 = false
local combo3 = false
local gunallowance = false
local shooting = false
local RunSrv = game:GetService("RunService")
local RenderStepped = game:GetService("RunService").RenderStepped
local removeuseless = game:GetService("Debris")

coroutine.wrap(function()
	while true do
		wait()
		if not Character or not Character:FindFirstChild("Humanoid") or Character:FindFirstChild("Humanoid").Health <= 0 then
			HumanoidIsDead = true
			break
		end
	end
end)()

local HEADLERP = Instance.new("ManualWeld")
HEADLERP.Parent = Head
HEADLERP.Part0 = Head
HEADLERP.Part1 = Head
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local TORSOLERP = Instance.new("ManualWeld")
TORSOLERP.Parent = Root
TORSOLERP.Part0 = Torso
TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local ROOTLERP = Instance.new("ManualWeld")
ROOTLERP.Parent = Root
ROOTLERP.Part0 = Root
ROOTLERP.Part1 = Torso
ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTARMLERP = Instance.new("ManualWeld")
RIGHTARMLERP.Parent = RightArm
RIGHTARMLERP.Part0 = RightArm
RIGHTARMLERP.Part1 = Torso
RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTARMLERP = Instance.new("ManualWeld")
LEFTARMLERP.Parent = LeftArm
LEFTARMLERP.Part0 = LeftArm
LEFTARMLERP.Part1 = Torso
LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTLEGLERP = Instance.new("ManualWeld")
RIGHTLEGLERP.Parent = RightLeg
RIGHTLEGLERP.Part0 = RightLeg
RIGHTLEGLERP.Part1 = Torso
RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTLEGLERP = Instance.new("ManualWeld")
LEFTLEGLERP.Parent = LeftLeg
LEFTLEGLERP.Part0 = LeftLeg
LEFTLEGLERP.Part1 = Torso
LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local function weldBetween(a, b)
    local weld = Instance.new("ManualWeld", a)
    weld.Part0 = a
    weld.Part1 = b
    weld.C0 = a.CFrame:inverse() * b.CFrame
    return weld
end

function MAKETRAIL(PARENT,POSITION1,POSITION2,LIFETIME,COLOR)
A = Instance.new("Attachment", PARENT)
A.Position = POSITION1
A.Name = "A"
B = Instance.new("Attachment", PARENT)
B.Position = POSITION2
B.Name = "B"
tr1 = Instance.new("Trail", PARENT)
tr1.Attachment0 = A
tr1.Attachment1 = B
tr1.Enabled = true
tr1.Lifetime = LIFETIME
tr1.TextureMode = "Static"
tr1.LightInfluence = 0
tr1.Color = COLOR
tr1.Transparency = NumberSequence.new(0, 1)
end

tommygun = Instance.new("Part",Character)
tommygun.Size = Vector3.new(2,2,2)
tommygun.CFrame = RightArm.CFrame
tommygun.CanCollide = false
tommygun.Transparency=1
tommygunweld = Instance.new("Weld",tommygun)
GUN_A1=Align(GunHandle,tommygun,Vector3.new(),Vector3.new(187,-80,180))
tommygunweld.Part0 = tommygun
tommygunweld.Part1 = RightArm
tommygunweld.C0 = tommygun.CFrame:inverse() * RightArm.CFrame * CFrame.new(0,-.80,1.25) * CFrame.Angles(math.rad(98),math.rad(0),0)
mtommygun = Instance.new("SpecialMesh", tommygun)
mtommygun.MeshType = "FileMesh"
mtommygun.Scale = Vector3.new(1, 1, 1)
mtommygun.MeshId,mtommygun.TextureId = 'http://www.roblox.com/asset/?id=116679805','http://www.roblox.com/asset/?id=116679995'
shootbox = Instance.new("Part",Character)
shootbox.Size = Vector3.new(.2,.2,.2)
shootbox.Transparency=1
shootbox.CanCollide = false
shootbox.Transparency = 1
shootbox.CFrame = tommygun.CFrame
shootboxweld = weldBetween(shootbox,tommygun)
shootboxweld.C0 = CFrame.new(0,-.05,2.62)
light = Instance.new("PointLight", shootbox)
light.Color = BrickColor.new("Bright yellow").Color
light.Range = 5
light.Brightness = 11
light.Enabled = false
particlemiter1 = Instance.new("ParticleEmitter", shootbox)
particlemiter1.Enabled = false
particlemiter1.Texture = "rbxassetid://461242617"
particlemiter1.Lifetime = NumberRange.new(.1)
particlemiter1.Size = NumberSequence.new(1,0)
particlemiter1.Rate = 20
particlemiter1.RotSpeed = NumberRange.new(0)
particlemiter1.Speed = NumberRange.new(0)
tommygunammo = Instance.new("Part",Character)
tommygunammo.Size = Vector3.new(2,2,2)
tommygunammo.CFrame = tommygun.CFrame
tommygunammo.CanCollide = false
tommygunammoweld = Instance.new("Weld",tommygunammo)
tommygunammoweld.Part0 = tommygunammo
tommygunammoweld.Part1 = tommygun
tommygunammo.Transparency = 1
tommygunammoweld.C0 = tommygun.CFrame:inverse() * tommygun.CFrame * CFrame.new(0,.4,.25) * CFrame.Angles(math.rad(0),math.rad(0),0)
mtommygunammo = Instance.new("SpecialMesh", tommygunammo)
mtommygunammo.MeshType = "FileMesh"
mtommygunammo.Scale = Vector3.new(1, 1, 1)
mtommygunammo.MeshId,mtommygunammo.TextureId = 'http://www.roblox.com/asset/?id=116740155','http://www.roblox.com/asset/?id=116679995'


coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v.Name == "Animate" then v:Remove()
end
end
end)()

function damagealll(Radius,Position)		
	local Returning = {}		
	for _,v in pairs(workspace:GetChildren()) do		
		if v~=Character and v:FindFirstChildOfClass('Humanoid') and v:FindFirstChild('Torso') or v:FindFirstChild('UpperTorso') then
if v:FindFirstChild("Torso") then		
			local Mag = (v.Torso.Position - Position).magnitude		
			if Mag < Radius then		
				table.insert(Returning,v)		
			end
elseif v:FindFirstChild("UpperTorso") then	
			local Mag = (v.UpperTorso.Position - Position).magnitude		
			if Mag < Radius then		
				table.insert(Returning,v)		
			end
end	
		end		
	end		
	return Returning		
end

function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end

doomtheme = Instance.new("Sound", Torso)
doomtheme.Volume = 1
doomtheme.Name = "doomtheme"
doomtheme.Looped = true
doomtheme.SoundId = "rbxassetid://318812395"
doomtheme:Play()

Torso.ChildRemoved:connect(function(removed)
if removed.Name == "doomtheme" then

doomtheme = Instance.new("Sound", Torso)
doomtheme.Volume = 1
doomtheme.Name = "doomtheme"
doomtheme.Looped = true
doomtheme.SoundId = "rbxassetid://318812395"
doomtheme:Play()
end
end)

function SOUND(PARENT,ID,VOL,LOOP,REMOVE)
so = Instance.new("Sound")
so.Parent = PARENT
so.SoundId = "rbxassetid://"..ID
so.Volume = VOL
so.Looped = LOOP
so:Play()
removeuseless:AddItem(so,REMOVE)
end

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='t' then
if tauntdebounce then return end
tauntdebounce = true
local b1 = Instance.new("BillboardGui",Head)
b1.Size = UDim2.new(0,4,0,1.6)
b1.StudsOffset = Vector3.new(0,0,0)
b1.Name = "laff"
b1.AlwaysOnTop = true
b1.StudsOffset = Vector3.new(0,2,0)
b1.Adornee = Head
removeuseless:AddItem(b1,3)
local b2 = Instance.new("TextLabel",b1)
b2.BackgroundTransparency = 1
b2.Text = "HeHeHeHeHeHeHe..."
b2.Font = "Garamond"
b2.TextSize = 30
b2.Name = "lafftext"
b2.TextStrokeTransparency = 0
b2.TextColor3 = BrickColor.new("Grey").Color
b2.TextStrokeColor3 = Color3.new(0,0,0)
b2.Size = UDim2.new(1,0,.5,0)
laff = Instance.new("Sound",Head)
laff.SoundId = "rbxassetid://2126502539"
laff.Volume = 5
laff:Play()
wait(5)
laff:Remove()
tauntdebounce = false
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='e' then
if debounce then return end
if equip then
g1:Remove()
light.Enabled = false
pcall(function()
temmy:Remove()
end)
for i,v in pairs(tommygun:GetDescendants()) do
if v.Name == "temmy" then v:Remove()
end
end
light.Enabled = false
particlemiter1.Enabled = false
hum.CameraOffset = Vector3.new(0,0,0)
attacking = false
equip = false
shooting = false
gunallowance = false
ws = 18
else
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
g1.CFrame = CFrame.new(Root.Position,mouse.Hit.p)
attacking = true
debounce = true
equip = true
coroutine.wrap(function()
while equip do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.1)
ws = 10
swait()
if Root.Velocity.y > 1 then
position = "Jump3"
elseif Root.Velocity.y < -1 then
position = "Falling3"
elseif Root.Velocity.Magnitude > 2 and running == false and attacking == true then
position = "Walk3"
elseif Root.Velocity.Magnitude < 2 and running == false and attacking == true then
position = "Idle4"
end
end
end)()
coroutine.wrap(function()
while equip do
swait()
settime = 0.05
sine = sine + change
if position == "Jump3" and attacking and not running then
change = .65
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Falling3" and attacking and not running then
change = .65
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.4)
elseif position == "Walk3" and attacking == true and running == false then
change = .65
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0.05*math.sin(sine/4), 0) * CFrame.Angles(math.rad(0), math.rad(-50), math.rad(0)),.2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0), math.cos(25 * math.cos(sine/8))), 0.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0) , math.cos(25 * math.cos(sine/8))), 0.1)
elseif position == "Idle4" and attacking == true and running == false then
change = .65
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/25), 0) * CFrame.Angles(math.rad(0), math.rad(-50), math.rad(0)),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/25), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/25), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.1)
end
end
end)()
SOUND(RightArm,898163129,6,false,2)
for i = 1, 30 do
tommygunweld.C0 = tommygunweld.C0:lerp(CFrame.new(0,-.68,1.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-12)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1, 0.1, 0.4) * CFrame.Angles(math.rad(-90), math.rad(-60), math.rad(0)), 0.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)), 0.25)
swait()
end
gunallowance = true
mouse.Button1Down:connect(function()
if gunallowance then
particlemiter1.Enabled = true
temmy = Instance.new("Sound",tommygun)
temmy.SoundId = "rbxassetid://2204318084"
temmy.Volume = 6
temmy.Name = "temmy"
temmy.Looped = true
temmy:Play()
shooting = true
end
end)
mouse.Button1Up:connect(function()
if gunallowance then
hum.CameraOffset = Vector3.new(0,0,0)
light.Enabled = false
particlemiter1.Enabled = false
pcall(function()
temmy:Remove()
end)
for i,v in pairs(tommygun:GetDescendants()) do
if v.Name == "temmy" then v:Remove()
end
end
shooting = false
end
end)
coroutine.wrap(function()
if firsttime2 then return end
firsttime2 = true
while true do
swait(3)
if shooting then
if switch1 then
switch1 = false
switch2 = true
light.Enabled = true
elseif switch2 then
switch1 = true
switch2 = false
light.Enabled = false
end
pcall(function()
if mouse.Target.Parent:FindFirstChildOfClass("Humanoid") then
DamageFling(mouse.Target.Parent)
end
end)
end
end
end)()
coroutine.wrap(function()
if firsttime then return end
firsttime = true
while true do
if shooting then
    pcall(function()
if mouse.Target.Parent:FindFirstChildOfClass("Humanoid") then
DamageFling(mouse.Target.Parent)
end
end)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90), math.rad(0 - 10 * math.sin(sine)), math.rad(0)), 0.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1, 0.1 + .4 * math.sin(sine), 0.4) * CFrame.Angles(math.rad(-90), math.rad(-60), math.rad(0)), 0.25)
elseif not shooting then
end
swait()
end
end)()
debounce = false
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='z' then
print("Music switched to 1")
id = 2199374985
doomtheme.SoundId = "rbxassetid://"..id
doomtheme:Play()
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='v' then
print("Music switched to 4")
id = 2111948183
doomtheme.SoundId = "rbxassetid://"..id
doomtheme:Play()
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='x' then
print("Music switched to 2")
id = 318812395
doomtheme.SoundId = "rbxassetid://"..id
doomtheme:Play()
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='c' then
print("Music switched to 3")
id = 180337897
doomtheme.SoundId = "rbxassetid://"..id
doomtheme:Play()
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='b' then
print("Music switched to 5")
id = 649148458
doomtheme.SoundId = "rbxassetid://"..id
doomtheme:Play()
end
end)


checks1 = coroutine.wrap(function() -------Checks
while true do
if HumanoidIsDead then break end
if Root.Velocity.y > 1 then
position = "Jump"
elseif Root.Velocity.y < -1 then
position = "Falling"
elseif Root.Velocity.Magnitude < 2 then
position = "Idle"
elseif Root.Velocity.Magnitude < 20 then
position = "Walking"
elseif Root.Velocity.Magnitude > 20 then
position = "Running"
else
end
wait()
end
end)
checks1()

function ray(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function ray2(StartPos, EndPos, Distance, Ignore)
local DIRECTION = CFrame.new(StartPos,EndPos).lookVector
return ray(StartPos, DIRECTION, Distance, Ignore)
end

OrgnC0 = Neck.C0
local movelimbs = coroutine.wrap(function()
while RunSrv.RenderStepped:wait() do
if HumanoidIsDead then break end
TrsoLV = Torso.CFrame.lookVector
Dist = nil
Diff = nil
if not MseGuide then
print("Failed to recognize")
else
local _, Point = Workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist = (Head.CFrame.p-Point).magnitude
Diff = Head.CFrame.Y-Point.Y
local _, Point2 = Workspace:FindPartOnRay(Ray.new(LeftArm.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist2 = (LeftArm.CFrame.p-Point).magnitude
Diff2 = LeftArm.CFrame.Y-Point.Y
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
Neck.C0 = Neck.C0:lerp(OrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), .1)
end
end
end)
movelimbs()
immortal = {}
for i,v in pairs(Character:GetDescendants()) do
	if v:IsA("BasePart") and v.Name ~= "lmagic" and v.Name ~= "rmagic" then
		if v ~= Root and v ~= Torso and v ~= Head and v ~= RightArm and v ~= LeftArm and v ~= RightLeg and v.Name ~= "lmagic" and v.Name ~= "rmagic" and v ~= LeftLeg then
			v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(immortal,{v,v.Parent,v.Material,v.Color,v.Transparency})
	elseif v:IsA("JointInstance") then
		table.insert(immortal,{v,v.Parent,nil,nil,nil})
	end
end
for e = 1, #immortal do
	if immortal[e] ~= nil then
		local STUFF = immortal[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
if levitate then
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= eyo1 and PART.Name ~= eyo2 and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
else
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
end
	end
end
coroutine.wrap(function()
while true do
if HumanoidIsDead then break end
if hum.Health < .1 then
deadsound = Instance.new("Sound", Torso)
deadsound.Volume = 6
deadsound.SoundId = "rbxassetid://1411352723"
deadsound:Play()
end
wait()
end
end)()

local anims = coroutine.wrap(function()
while true do
if HumanoidIsDead then break end
settime = 0.05
sine = sine + change
if position == "Jump" and attacking == false then
change = 1
tommygunweld.C0 = tommygunweld.C0:lerp(CFrame.new(0,-.80,1.25) * CFrame.Angles(math.rad(98),math.rad(0),0),.25)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Jump2" and attacking == false then
change = 1
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
elseif position == "Falling" and attacking == false then
change = 1
tommygunweld.C0 = tommygunweld.C0:lerp(CFrame.new(0,-.80,1.25) * CFrame.Angles(math.rad(98),math.rad(0),0),.25)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
elseif position == "Falling2" and attacking == false then
change = 1
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
elseif position == "Walking" and attacking == false and running == false then
change = 1.2
walking = true
tommygunweld.C0 = tommygunweld.C0:lerp(CFrame.new(0,-.80,1.25) * CFrame.Angles(math.rad(98),math.rad(0),0),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,1,0) * CFrame.Angles(math.rad(180),math.rad(1),math.rad(10)), 0.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5 + Root.RotVelocity.Y / 85,.35,.5*math.sin(sine/8)) * CFrame.Angles(math.rad(-35*math.sin(sine/8)),math.rad(0*math.sin(sine/8)),math.rad(10 + Root.RotVelocity.Y / 10, math.sin(20 * math.sin(sine/4)))),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0.05*math.sin(sine/4), 0) * CFrame.Angles(math.rad(-10), math.rad(5 * math.cos(sine/7)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/10))), 0.1)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0), math.cos(25 * math.cos(sine/8))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0) , math.cos(25 * math.cos(sine/8))), 0.3)
elseif position == "Idle" and attacking == false and running == false then
change = .5
tommygunweld.C0 = tommygunweld.C0:lerp(CFrame.new(0,-.80,1.25) * CFrame.Angles(math.rad(98),math.rad(0),0),.25)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3 + .1 * math.sin(sine/12),1 + .1 * math.sin(sine/12),0) * CFrame.Angles(math.rad(180),math.rad(1),math.rad(8 + 5 * math.sin(sine/12))), 0.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.59 - .05 * math.sin(sine/12), 0.1 -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(-2), math.rad(2), math.rad(8  - 6 * math.sin(sine/12))), .2)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.1)
elseif position == "Idle2" and attacking == false and running == false then
change = .75
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0 - 3 * math.sin(sine/9)),0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 - 3 * math.sin(sine/9)), math.rad(-35 + 5 * math.sin(sine/9))), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
elseif position == "Walking2" and attacking == false and running == false then
ws = 50
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
elseif position == "Running" and attacking == false then
change = 1
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(0, .5, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-1.24+.6*math.sin(sine/4)/1.4, 0.54, 0-0.8*math.sin(sine/4))*CFrame.Angles(math.rad(6+140*math.sin(sine/4)/1.2), math.rad(0), math.rad(20+70*math.sin(sine/4))), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(0,.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(-20 - 0 * math.sin(sine/4)), math.rad(0 + 6 * math.sin(sine/4)), math.rad(0) + Root.RotVelocity.Y / 30, math.sin(10 * math.sin(sine/4))), 0.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*-math.sin(sine/4)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.6+0.1*math.sin(sine/4),.7*-math.sin(sine/4)) * CFrame.Angles(math.rad(15+ -50 * math.sin(sine/4)),0,0),.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*math.sin(sine/4)),.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.6-0.1*math.sin(sine/4),.7*math.sin(sine/4)) * CFrame.Angles(math.rad(15 + 50 * math.sin(sine/4)),0,0),.3)
end
swait()
end
end)
anims()
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe ender (free)",
	Callback = function()
		





local player = game.Players.LocalPlayer
local character1 = player.Character
local mouse = player:GetMouse()

local fakebody = Instance.new("Part", character1)
fakebody.Transparency = 1
fakebody.Anchored = true
fakebody.CanCollide = false
fakebody.Position = character1.Head.Position
wait()
_G.ReanimationType = "PDeath" --PDeath, Fling, Simple
_G.Velocity = Vector3.new(36,0,0)
_G.FlingBlock = true
_G.FlingBlockTransparency = 1
_G.HighlightFlingBlock = true
_G.FlingBlockPosition = "Part"
_G.HighlightFlingBlockColor = Color3.fromRGB(255,0,0)

loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/Reanimation.lua/main/Main/Main.lua"))()
wait(1)

mouse.KeyDown:connect(function(key)
    if key == "e" then
    character1.Reanimate.Part.Position = mouse.Hit.p
    end
end)

FELOADLIBRARY = {}
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
local FavIDs = {
	340106355, --Nefl Crystals
	927529620, --Dimension
	876981900, --Fantasy
	398987889, --Ordinary Days
	1117396305, --Oh wait, it's you.
	885996042, --Action Winter Journey
	919231299, --Sprawling Idiot Effigy
	743466274, --Good Day Sunshine
	727411183, --Knife Fight
	1402748531, --The Earth Is Counting On You!
	595230126 --Robot Language
	}

Bypass = "a"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait()
local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name)
local char = character1.Reanimate
local hum = char.Humanoid
local ra = char["Right Arm"]
local la= char["Left Arm"]
local rl= char["Right Leg"]
local ll = char["Left Leg"]
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
local CF = CFrame.new
local angles = CFrame.Angles
local attack = false
local Euler = CFrame.fromEulerAnglesXYZ
local Rad = math.rad
local IT = Instance.new
local BrickC = BrickColor.new
local Cos = math.cos
local Acos = math.acos
local Sin = math.sin
local Asin = math.asin
local Abs = math.abs
local Mrandom = math.random
local Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
local necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local RSH, LSH = nil, nil 
local RW = Instance.new("Weld") 
local LW = Instance.new("Weld")
local RH = tors["Right Hip"]
local LH = tors["Left Hip"]
local RSH = tors["Right Shoulder"] 
local LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
local Effects = {}


-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait()
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait()
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end

local Create = FELOADLIBRARY.Create

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent.Name ~= plr.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:service("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			--h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			--h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------

function CreateSound(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = Instance.new("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end

function Eviscerate(dude)
	if dude.Name ~= char.Name and dude.Name ~= plr.Name then
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Part") or v:IsA("MeshPart") then
						coroutine.resume(coroutine.create(function()
							v.CanCollide = false
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							coroutine.resume(coroutine.create(function()
								wait(0.5)
								PartEmmit1.Enabled = false
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end
function SphereAura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
                        rng.BrickColor = BrickColor.random()
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end
function SoulSteal(dude)
if dude.Name ~= char.Name and dude.Name ~= plr.Name then
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",char)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------
--[[
		Thanks for using Build-To-Lua by jarredbcv.
]]--

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
	
Gaunty = New("Model",char,"Gaunty",{})
Handle = New("Part",Gaunty,"Handle",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1, 1.26999998, 1),CFrame = CFrame.new(-5.67319345, 3.02064276, -77.6615906, 0.999894261, 0.010924357, 0.00963267777, -0.0110270018, 0.999882579, 0.0106679145, -0.00951499958, -0.0107729975, 0.999897003),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Handle,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.82765579, 3.62595344, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.161155701, 0.603512526, 0.00862884521, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-6.13765526, 3.62595367, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.471122265, 0.600126028, 0.00564575195, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.5176549, 3.62595415, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.148812294, 0.606899738, 0.0116195679, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.21765471, 3.62595463, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.448780537, 0.610177517, 0.014503479, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-6.13765526, 2.53595448, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.459102631, -0.489744425, -0.00598144531, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.82765627, 2.53595448, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.149136543, -0.486357927, -0.00299835205, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.51765537, 2.53595448, -77.6579361, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.160831451, -0.48297143, -1.52587891e-05, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.21765566, 2.53595424, -77.6579361, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.460799217, -0.479694128, 0.00286865234, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.07999992, 0.279999971, 1.06999993),CFrame = CFrame.new(-5.66865063, 3.64553881, -77.6613617, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(-0.00235080719, 0.624869347, 0.00694274902, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66490126, 3.73544312, -77.6652145, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.000443935394, 0.714845657, 0.00408172607, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66480446, 3.52554965, -77.65522, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.00275993347, 0.504870415, 0.0118331909, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.07999992, 0.279999971, 1.06999993),CFrame = CFrame.new(-5.6686511, 2.55553746, -77.6613541, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.00966835022, -0.465003252, -0.00468444824, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66490126, 2.64544272, -77.6652145, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.0124630928, -0.375026226, -0.00754547119, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66480494, 2.43554902, -77.65522, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.0147790909, -0.585001707, 0.000205993652, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 3.62595463, -78.1079407, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(-0.0018901825, 0.61005497, -0.439842224, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 3.62595558, -77.8179321, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(-0.00464963913, 0.606931448, -0.149864197, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 3.62595606, -77.4879303, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(-0.00278997421, 0.603431463, 0.180152893, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 3.62595654, -77.1979294, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(-0.00554895401, 0.600307703, 0.470123291, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 2.53595638, -77.1979294, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.0064702034, -0.489563704, 0.458496094, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 2.53595614, -77.4879303, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.00922966003, -0.486439705, 0.168525696, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265558, 2.53595638, -77.8179245, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.00736999512, -0.482939243, -0.161483765, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 2.53595614, -78.1079254, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.0101289749, -0.479815245, -0.451454163, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765547, 3.62595677, -77.1979218, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(-0.00554943085, 0.600307941, 0.47013092, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 3.62595701, -77.4879303, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(-0.00278949738, 0.603432655, 0.180152893, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765451, 3.62595749, -77.8179321, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.000350952148, 0.606987953, -0.149810791, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765451, 3.62595749, -78.107933, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.00311040878, 0.61011219, -0.439788818, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.53595734, -78.107933, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.0151295662, -0.479759216, -0.451416016, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.5359571, -77.8179245, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.0123701096, -0.482883692, -0.161437988, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.5359571, -77.4879227, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.00923013687, -0.48643899, 0.168533325, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.53595686, -77.1979218, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.00647068024, -0.489563227, 0.458503723, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-6.13765478, 3.62595701, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.471121788, 0.600129128, 0.00566101074, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.82765484, 3.62595725, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.161154747, 0.603516102, 0.008644104, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.51765442, 3.62595773, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.148812771, 0.606903076, 0.0116348267, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.21765375, 3.6259582, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.44878149, 0.610180855, 0.0145187378, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.21765327, 2.53595781, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.460801125, -0.47969079, 0.00289154053, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.51765299, 2.53595757, -77.6579208, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.160833359, -0.48296833, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.82765341, 2.53595734, -77.6579208, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.149133682, -0.486355066, -0.00299072266, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-6.13765383, 2.53595734, -77.6579208, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.4591012, -0.489741802, -0.00597381592, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.25000003),CFrame = CFrame.new(-5.66203499, 3.4509573, -77.7865677, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.00760126114, 0.431732178, -0.120269775, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.280000031),CFrame = CFrame.new(-5.66203451, 3.45095778, -77.5215683, -1.0000006, -6.18456397e-10, -9.12696123e-08, 6.18456397e-10, 1.0000006, -4.65661287e-09, 8.38190317e-08, 4.65661287e-09, -1.0000006),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, -1),C1 = CFrame.new(0.00508022308, 0.428877592, 0.144706726, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.25000003),CFrame = CFrame.new(-5.66203403, 2.81095791, -77.7865601, -1.0000006, 8.81700544e-08, 3.7252903e-09, -8.69331416e-08, -1.0000006, 4.65661287e-09, -3.7252903e-09, -4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -1, -8.74227766e-08, 0, 8.74227766e-08, -1, 0, 0, 0, 1),C1 = CFrame.new(0.0146594048, -0.208191872, -0.127082825, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.280000031),CFrame = CFrame.new(-5.66203356, 2.8209579, -77.5215607, 1.0000006, -8.69331416e-08, 8.38190317e-08, -8.81700544e-08, -1.0000006, -4.65661287e-09, 9.12696123e-08, -4.65661287e-09, -1.0000006),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, -8.74227766e-08, 8.74227766e-08, -8.74227766e-08, -1, -7.64274186e-15, 8.74227766e-08, 0, -1),C1 = CFrame.new(0.0120282173, -0.201047897, 0.137992859, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Wedge = New("WedgePart",Gaunty,"Wedge",{BrickColor = BrickColor.new("Black"),Size = Vector3.new(1.1099999, 0.569999993, 1.13),CFrame = CFrame.new(-5.6508193, 4.06113148, -77.6620178, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Wedge,"mot",{Part0 = Wedge,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.0109024048, 1.04061508, 0.010887146, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})

Gaunty2 = New("Model",char,"Gaunty2",{})
Handle2 = New("Part",Gaunty2,"Handle2",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1, 1.26999998, 1),CFrame = CFrame.new(-5.67319345, 3.02064276, -77.6615906, 0.999894261, 0.010924357, 0.00963267777, -0.0110270018, 0.999882579, 0.0106679145, -0.00951499958, -0.0107729975, 0.999897003),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Handle2,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.82765579, 3.62595367, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.161155701, 0.603512764, 0.00862884521, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-6.13765526, 3.62595439, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.471122265, 0.600126743, 0.00564575195, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.51765394, 3.6259551, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.148813248, 0.606900692, 0.0116195679, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.21765375, 3.62595558, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.44878149, 0.610178471, 0.014503479, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-6.13765621, 2.535954, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.459103584, -0.489744902, -0.00598144531, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.82765722, 2.535954, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.149137497, -0.486358404, -0.00299835205, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.5176549, 2.53595448, -77.6579514, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.160831928, -0.482971191, -3.05175781e-05, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.21765566, 2.535954, -77.6579361, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.460799217, -0.479694366, 0.00286865234, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.07999992, 0.279999971, 1.06999993),CFrame = CFrame.new(-5.66865063, 3.64554, -77.661377, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(-0.00235033035, 0.624870777, 0.00692749023, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.6649003, 3.73544407, -77.6652145, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.000444412231, 0.714846611, 0.00408172607, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66480446, 3.5255506, -77.65522, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.00275993347, 0.504871368, 0.0118331909, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.07999992, 0.279999971, 1.06999993),CFrame = CFrame.new(-5.6686511, 2.55553699, -77.6613541, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.00966835022, -0.465003729, -0.00468444824, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66490126, 2.64544272, -77.6652145, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.0124630928, -0.375026226, -0.00754547119, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66480589, 2.43554854, -77.65522, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.0147781372, -0.585002184, 0.000205993652, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 3.62595463, -78.1079407, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.0018901825, 0.61005497, -0.439842224, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265511, 3.6259563, -77.8179169, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.00464916229, 0.606932163, -0.149848938, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765451, 3.62595701, -77.4879303, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.00278902054, 0.603432655, 0.180152893, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 3.62595749, -77.1979294, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.00554895401, 0.600308895, 0.470123291, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 2.53595638, -77.1979294, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0064702034, -0.489563704, 0.458496094, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 2.53595614, -77.4879303, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00922966003, -0.486439705, 0.168525696, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265558, 2.53595638, -77.8179092, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00736999512, -0.482939243, -0.161468506, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 2.53595567, -78.1079254, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0101289749, -0.479815722, -0.451454163, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765451, 3.62595749, -77.1979218, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.00554847717, 0.600308895, 0.47013092, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765404, 3.62595797, -77.4879303, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.0027885437, 0.603433609, 0.180152893, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765356, 3.6259594, -77.8179321, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.000351905823, 0.606989861, -0.149810791, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765356, 3.62595844, -78.107933, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00311136246, 0.610113144, -0.439788818, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.53595734, -78.107933, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0151295662, -0.479759216, -0.451416016, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.5359571, -77.8179092, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0123701096, -0.48288393, -0.161422729, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.5359571, -77.4879227, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00923013687, -0.48643899, 0.168533325, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.53595662, -77.1979218, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00647068024, -0.489563465, 0.458503723, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-6.13765478, 3.62595797, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.471121788, 0.600130081, 0.00566101074, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.82765484, 3.6259582, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.161154747, 0.603517056, 0.008644104, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.51765347, 3.62595868, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.148813725, 0.60690403, 0.0116348267, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.2176528, 3.62595916, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.448782444, 0.610181808, 0.0145187378, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.21765327, 2.53595757, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.460801601, -0.479691029, 0.00289154053, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.51765299, 2.53595757, -77.6579361, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.160833836, -0.48296833, -1.52587891e-05, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.82765436, 2.5359571, -77.6579208, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.149134636, -0.486355305, -0.00299072266, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-6.13765478, 2.53595734, -77.6579208, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.459102154, -0.489741802, -0.00597381592, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.25000003),CFrame = CFrame.new(-5.66203403, 3.45095801, -77.7865524, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00760221481, 0.431732655, -0.120254517, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.280000031),CFrame = CFrame.new(-5.66203356, 3.45095849, -77.521553, -1.00000179, -2.26282282e-09, -9.87201929e-08, 2.28465069e-09, 1.00000179, -1.39698386e-08, 7.63684511e-08, 1.39698386e-08, -1.00000179),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -1.00000119, 1.45519152e-09, 8.00937414e-08, -1.44063961e-09, 1.00000119, 9.31322575e-09, -9.49949026e-08, -9.31322575e-09, -1.00000119),C1 = CFrame.new(0.00508117676, 0.428878307, 0.144721985, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.25000003),CFrame = CFrame.new(-5.66203308, 2.81095791, -77.7865601, -1.00000179, 8.98216967e-08, 1.11758709e-08, -8.52742232e-08, -1.00000179, 1.39698386e-08, -1.11758709e-08, -1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -1.00000119, -8.61036824e-08, -7.4505806e-09, 8.89922376e-08, -1.00000119, -9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0146603584, -0.208191872, -0.127082825, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
NeonPart = New("WedgePart",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.280000031),CFrame = CFrame.new(-5.6620326, 2.82095814, -77.5215454, 1.00000179, -8.52887752e-08, 7.63684511e-08, -8.98362487e-08, -1.00000179, -1.39698386e-08, 9.87201929e-08, -1.39698386e-08, -1.00000179),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -8.89995135e-08, 9.49949026e-08, -8.61109584e-08, -1.00000119, -9.31322575e-09, 8.00937414e-08, -9.31322575e-09, -1.00000119),C1 = CFrame.new(0.012029171, -0.201047897, 0.138008118, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
Wedge = New("WedgePart",Gaunty2,"Wedge",{BrickColor = BrickColor.new("Black"),Size = Vector3.new(1.1099999, 0.569999993, 1.13),CFrame = CFrame.new(-5.6508193, 4.06113243, -77.6620178, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
mot = New("Motor",Wedge,"mot",{Part0 = Wedge,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.0109024048, 1.04061604, 0.010887146, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})


NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance,parent)
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

local HW = NewInstance('Motor', char, {Part0 = ra, Part1 = Handle, C0 = CF(0,-.51,0)})
local HW2 = NewInstance('Motor', char, {Part0 = la, Part1 = Handle2, C0 = CF(0,-.51,0) * angles(Rad(0),Rad(180),Rad(0))})

for _,v in next, Gaunty:children() do
	v.CanCollide = false
end
for _,v in next, Gaunty2:children() do
	v.CanCollide = false
end
local all, last = {}, nil
ArmourParts = {}
NeonParts = {}
function scan(p)
  for _, v in pairs(p:GetChildren()) do
    if v:IsA("BasePart") then
      if v.BrickColor == BrickColor.new("Black") then
        table.insert(ArmourParts, v)
      end
      if v.BrickColor == BrickColor.new("Institutional white") then
        table.insert(NeonParts, v)
      end
      if last then
        local w = Instance.new("Weld")
        w.Part0, w.Part1 = last, v
        w.C0 = v.CFrame:toObjectSpace(last.CFrame):inverse()
        w.Parent = last
      end
      table.insert(all, v)
      last = v
    end
    scan(v)
  end
end
scan(Gaunty)
local all2, last2 = {}, nil
ArmourParts2 = {}
NeonParts2 = {}
function scan2(p)
  for _, v in pairs(p:GetChildren()) do
    if v:IsA("BasePart") then
      if v.BrickColor == BrickColor.new("Black") then
        table.insert(ArmourParts2, v)
      end
      if v.BrickColor == BrickColor.new("Institutional white") then
        table.insert(NeonParts2, v)
      end
      if last2 then
        local w = Instance.new("Weld")
        w.Part0, w.Part1 = last2, v
        w.C0 = v.CFrame:toObjectSpace(last2.CFrame):inverse()
        w.Parent = last2
      end
      table.insert(all2, v)
      last2 = v
    end
    scan2(v)
  end
end
scan2(Gaunty2)
for i, v in pairs(ArmourParts) do
     v.BrickColor = BrickC("Black")
		end
for i, v in pairs(NeonParts) do
     v.BrickColor = BrickC("Really red")
      	end
for i, v in pairs(ArmourParts2) do
     v.BrickColor = BrickC("Black")
		end
for i, v in pairs(NeonParts2) do
     v.BrickColor = BrickC("Really red")
      	end
maincolor = BrickC("Really red")
-------------------------------------------------------
--Start Music Option--
-------------------------------------------------------
local Music = Instance.new("Sound",char)
Music.Volume = 2.5
Music.SoundId = "rbxassetid://550578451"
Music.Looped = true
Music.Pitch = 1 --Pitcher
Music:Play()
-------------------------------------------------------
--End Music Option--
-------------------------------------------------------
local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,35)
naeeym2.StudsOffset = Vector3.new(0,2,0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"

local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Ender"
tecks2.Font = "Garamond"
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(0,0,0)
tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2

function chatfunc(text, color)
	local chat = coroutine.wrap(function()
		if char:FindFirstChild("TalkingBillBoard") ~= nil then
			char:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local naeeym2 = Instance.new("BillboardGui", char)
		naeeym2.Size = UDim2.new(0, 100, 0, 40)
		naeeym2.StudsOffset = Vector3.new(0, 5, 0)
		naeeym2.Adornee = hed
		naeeym2.Name = "TalkingBillBoard"
		local tecks2 = Instance.new("TextLabel", naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SciFi"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 0
		tecks2.TextColor3 = color
		tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
		tecks2.Size = UDim2.new(1, 0, 0.5, 0)
		local tecks3 = Instance.new("TextLabel", naeeym2)
		tecks3.BackgroundTransparency = 1
		tecks3.BorderSizePixel = 0
		tecks3.Text = ""
		tecks3.Font = "SciFi"
		tecks3.TextSize = 30
		tecks3.TextStrokeTransparency = 0
		tecks3.TextColor3 = Color3.new(0, 0, 0)
		tecks3.TextStrokeColor3 = color
		tecks3.Size = UDim2.new(1, 0, 0.5, 0)
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
					tecks2.TextColor3 = BrickColor.random().Color
					tecks3.TextStrokeColor3 = BrickColor.random().Color
				tecks2.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
				tecks3.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
				tecks2.Rotation = math.random(-5, 5)
				tecks3.Rotation = math.random(-5, 5)
			end
		end))
		for i = 1, string.len(text) do
			CFuncs.Sound.Create("rbxassetid://274118116", char, 0.25, 0.115)
			tecks2.Text = string.sub(text, 1, i)
			tecks3.Text = string.sub(text, 1, i)
			swait(1)
		end
		wait(1)
		local randomrot = math.random(1, 2)
		if randomrot == 1 then
			for i = 1, 50 do
				swait()
				tecks2.Rotation = tecks2.Rotation - 0.75
				tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
				tecks2.TextTransparency = tecks2.TextTransparency + 0.04
				tecks3.Rotation = tecks2.Rotation + 0.75
				tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
				tecks3.TextTransparency = tecks2.TextTransparency + 0.04
			end
		elseif randomrot == 2 then
			for i = 1, 50 do
				swait()
				tecks2.Rotation = tecks2.Rotation + 0.75
				tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
				tecks2.TextTransparency = tecks2.TextTransparency + 0.04
				tecks3.Rotation = tecks2.Rotation - 0.75
				tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
				tecks3.TextTransparency = tecks2.TextTransparency + 0.04
			end
		end
		naeeym2:Destroy()
	end)
	chat()
end
-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
local sine=0
function HitboxFunction(Pose, lifetime, siz1, siz2, siz3, Radie, Min, Max, kb, atype)
  local Hitboxpart = Instance.new("Part", EffectModel)
  RemoveOutlines(Hitboxpart)
  Hitboxpart.Size = Vector3.new(siz1, siz2, siz3)
  Hitboxpart.CanCollide = false
  Hitboxpart.Transparency = 1
  Hitboxpart.Anchored = true
  Hitboxpart.CFrame = Pose
  game:GetService("Debris"):AddItem(Hitboxpart, lifetime)
  MagniDamage(Hitboxpart, Radie, Min, Max, kb, atype)
end
wait2 = false
combo = 1
mouse.Button1Down:connect(function(key)
  if attack == false then
    attack = true
    hum.WalkSpeed = 3.01
    if combo == 1 and wait2 == false then
      wait2 = true
		for i = 0, 1.2, 0.1 do
        swait()
	character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(-5), math.rad(0), math.rad(-65)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-10), math.rad(0), math.rad(-65)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.8) * angles(math.rad(90), math.rad(0), math.rad(20)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(40)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.2) * RHCF * angles(math.rad(-2.5), math.rad(0), math.rad(-0)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(15), math.rad(-20)), 0.3)
	character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
		  end
		CreateSound("138097048", ra, 3, .8)
		HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 6, 9, 3, "Normal")
      for i = 0, 1.2, 0.1 do
        swait()
	character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(5), math.rad(0), math.rad(55)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.8) * angles(math.rad(95), math.rad(0), math.rad(40)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(-10)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * angles(math.rad(-2.5), math.rad(-25), math.rad(-17)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(-0), math.rad(0)), 0.3)
	character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
      end
      combo = 2
    end
 	if combo == 2 and wait2 == false then
      wait2 = true
   for i = 0, 1.2, 0.1 do
        swait()
	character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(-5), math.rad(0), math.rad(65)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-10), math.rad(0), math.rad(65)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.8) * angles(math.rad(-25), math.rad(0), math.rad(40)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(20)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.2) * RHCF * angles(math.rad(-2.5), math.rad(0), math.rad(-0)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(15), math.rad(-20)), 0.3)
	character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
		  end
		CreateSound("138097048", ra, 3, .8)
		HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 6, 9, 3, "Normal")
      for i = 0, 1.2, 0.1 do
        swait()
character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(5), math.rad(0), math.rad(-55)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(10)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.8) * angles(math.rad(95), math.rad(0), math.rad(-40)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * angles(math.rad(-2.5), math.rad(-25), math.rad(-17)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(-0), math.rad(0)), 0.3)
character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
      end
      combo = 3
    end
   if combo == 3 and wait2 == false then
	wait2 = true
    for i = 0, 1.2, 0.1 do
        swait()
	character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(-5), math.rad(0), math.rad(-35)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-10), math.rad(0), math.rad(0)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.8) * angles(math.rad(90), math.rad(0), math.rad(20)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(-10)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.2) * RHCF * angles(math.rad(-2.5), math.rad(0), math.rad(-0)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(15), math.rad(-20)), 0.3)
	character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
      end
	CreateSound("138097048", ra, 3, .8)
      HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 24, 36, 3, "Normal")
      for i = 0, 1.2, 0.1 do
        swait()
	character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(5), math.rad(0), math.rad(35)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.8) * angles(math.rad(96), math.rad(0), math.rad(10)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(-10)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * angles(math.rad(-2.5), math.rad(-25), math.rad(-0)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(-0), math.rad(0)), 0.3)
	character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
      end
		Effects.Sphere.Create(maincolor, ra.CFrame * CFrame.new(0,-2,0) , 85, 85, 85, 1.1, 1.1, 1.1, 0.02)
		Effects.Ring.Create(maincolor, ra.CFrame * CFrame.new(0,-2,0) , 2, 2, 2, 1.1, 1.1, 1.1, 0.03)
		for i = 0, 2 do
			SphereAura(2, 0.2, "Add", ra.CFrame * CFrame.Angles(math.rad(-90 + math.random(-20, 20)), math.rad(math.random(-20, 20)), math.rad(math.random(-20, 20))), 0.5, 0.5, 5, -0.005, maincolor, 0)
			end
		coroutine.resume(coroutine.create(function() 
		for i = 0,1.8,0.1 do
			swait()
			hum.CameraOffset = Vector3.new(Mrandom(-1,1),0,Mrandom(-1,1))
		end
		for i = 0,1.8,0.1 do
			swait()
		hum.CameraOffset = Vector3.new(0,0,0)
		end
	  end))
		HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 24, 36, 3, "Normal")
	for i = 0, 1.2, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(5), math.rad(0), math.rad(-35)), 0.3)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.1)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.8) * angles(math.rad(25), math.rad(0), math.rad(10)), 0.1)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(-10)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * angles(math.rad(-2.5), math.rad(-25), math.rad(-0)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(-0), math.rad(0)), 0.3)
      end
      combo = 4
    end
	if combo == 4 and wait2 == false then
	for i = 0,1.2,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-20 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-4.5), Rad(0), Rad(-20)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.4 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-6.5), Rad(5 * Cos(sine / 20)), Rad(25)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(200), Rad(0), Rad(25 - 2.5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(200), Rad(0), Rad(-25 + 2.5 * Sin(sine / 20))), 0.1)
	end
SphereAura(6, 0.3, "Add", root.CFrame * CF(0,-2,0) * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 0.5, 0.5, 5, -0.005, maincolor, 0)
		SphereAura(6, 0.3, "Add", root.CFrame * CF(0,-2,0) * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 0.5, 0.5, 5, -0.005, maincolor, 0)
        Effects.Sphere.Create(maincolor, root.CFrame * CFrame.new(0,-2,0) , 85, 85, 85, 15.1, 15.1, 15.1, 0.01)
	CreateSound("331666100", char, 10, 1)
        for i, v in pairs(FindNearestHead(tors.CFrame.p, 14.5)) do
		if v:FindFirstChild("Head") then
			SoulSteal(v)
			Eviscerate(v)
		end
	end
	coroutine.resume(coroutine.create(function() 
		for i = 0,1.8,0.1 do
			swait()
			hum.CameraOffset = Vector3.new(Mrandom(-1,1),0,Mrandom(-1,1))
		end
		for i = 0,1.8,0.1 do
			swait()
		hum.CameraOffset = Vector3.new(0,0,0)
		end
	  end))
	for i = 1,4.7,0.1 do
	rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -1.4 + 0.1 * Cos(sine / 20)) * angles(Rad(45), Rad(0), Rad(0)), 0.15)
	tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(35), Rad(0), Rad(0)), 0.3)
	RH.C0 = clerp(RH.C0, CF(1, .4 - 0.1 * Cos(sine / 20), -.6 + 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-5), Rad(0), Rad(45)), 0.15)
	LH.C0 = clerp(LH.C0, CF(-1, -0.6 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-5), Rad(0), Rad(-0)), 0.15)
	RW.C0 = clerp(RW.C0, CF(1.2, 0.1 + 0.05 * Sin(sine / 30), -.4 + 0.025 * Cos(sine / 20)) * angles(Rad(65), Rad(0), Rad(-34)), 0.1)
	LW.C0 = clerp(LW.C0, CF(-1.2, 0.1 + 0.05 * Sin(sine / 30), -.4 + 0.025 * Cos(sine / 20)) * angles(Rad(65), Rad(0), Rad(34)), 0.1)
	end
      wait(.6)
	combo = 1
	end
    hum.WalkSpeed = 16
    wait2 = false
    attack = false
	end
end)
function Destruction()
	attack = true
	local Ring1 = Instance.new("Part", char)
	Ring1.Anchored = true
	Ring1.BrickColor = maincolor
	Ring1.CanCollide = false
	Ring1.FormFactor = 3
	Ring1.Name = "Ring"
	Ring1.Material = "Neon"
	Ring1.Size = Vector3.new(1, 0.05, 1)
	Ring1.Transparency = 1
	Ring1.TopSurface = 0
	Ring1.BottomSurface = 0
	local Ring1Mesh = Instance.new("SpecialMesh", Ring1)
	Ring1Mesh.MeshType = "Brick"
	Ring1Mesh.Name = "SizeMesh"
	Ring1Mesh.Scale = Vector3.new(0, 1, 0)
	local InnerRing1 = Ring1:Clone()
	InnerRing1.Parent = char
	InnerRing1.Transparency = 0
	InnerRing1.BrickColor = BrickColor.new("New Yeller")
	InnerRing1.Size = Vector3.new(1, 1, 1)
	local InnerRing1Mesh = InnerRing1.SizeMesh
	InnerRing1Mesh.Scale = Vector3.new(0, 0, 0)
	InnerRing1Mesh.MeshType = "Sphere"
	Ring1:Destroy()
	for i = 0, 5, 0.1 do
		swait()
		SphereAura(7, 0.12, "Add", ra.CFrame * CF(0,-2,0) * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 0.5, 0.5, 5, -0.005, maincolor, 0)
		SphereAura(7, 0.12, "Add", ra.CFrame * CF(0,-2,0) * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 0.5, 0.5, 5, -0.005, BrickC("Institutional white"), 0)
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(5), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-4.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-12.5 + 3 * Sin(sine / 20)), Rad(0), Rad(0 + 2.5 * Sin(sine / 20))), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5 + 3 * Sin(sine / 20)), Rad(0), Rad(0 + 2.5 * Sin(sine / 20))), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.1, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-25)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.1, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(25)), 0.1)
		character1.Reanimate.Part.Position = mouse.Hit.p
	root.CFrame = FaceMouse()[1]
	end
	InnerRing1.Transparency = 1
	InnerRing1.CFrame = root.CFrame * CF(0, 0.5, 0) + root.CFrame.lookVector * 5
	CreateSound("294188875", char, 2.3, 1)
	local a = IT("Part", char)
	a.Name = "Direction"
	a.Anchored = true
	a.BrickColor = maincolor
	a.Material = "Neon"
	a.Transparency = 0
	a.Shape = "Cylinder"
	a.CanCollide = false
	local a2 = IT("Part", char)
	a2.Name = "Direction"
	a2.Anchored = true
	a2.BrickColor = maincolor
	a2.Color = maincolor.Color
	a2.Material = "Neon"
	a2.Transparency = 0.5
	a2.Shape = "Cylinder"
	a2.CanCollide = false
	local ba = IT("Part", char)
	ba.Name = "HitDirect"
	ba.Anchored = true
	ba.BrickColor = maincolor
	ba.Material = "Neon"
	ba.Transparency = 1
	ba.CanCollide = false
	local ray = Ray.new(InnerRing1.CFrame.p, (mouse.Hit.p - InnerRing1.CFrame.p).unit * 1000)
	local ignore = char
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	a2.BottomSurface = 10
	a2.TopSurface = 10
	local distance = (InnerRing1.CFrame.p - position).magnitude
	a.Size = Vector3.new(distance, 1, 1)
	a.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
	a2.Size = Vector3.new(distance, 1, 1)
	a2.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
	ba.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance)
	a.CFrame = a.CFrame * angles(0, Rad(90), 0)
	a2.CFrame = a2.CFrame * angles(0, Rad(90), 0)
	game:GetService("Debris"):AddItem(a, 20)
	game:GetService("Debris"):AddItem(a2, 20)
	game:GetService("Debris"):AddItem(ba, 20)
	local msh = Instance.new("SpecialMesh", a)
	msh.MeshType = "Sphere"
	msh.Scale = Vector3.new(1, 25, 25)
	local msh2 = Instance.new("SpecialMesh", a2)
	msh2.MeshType = "Sphere"
	msh2.Scale = Vector3.new(1, 30, 30)
	for i = 0, 10, 0.1 do
		swait()
		character1.Reanimate.Part.Position = mouse.Hit.p
		root.CFrame = FaceMouse()[1]
		hum.CameraOffset = Vector3.new(Mrandom(-1,1),0,Mrandom(-1,1))
		a2.Color = maincolor.Color
		InnerRing1.CFrame = root.CFrame * CF(0, 0.5, 0) + root.CFrame.lookVector * 4
		ray = Ray.new(InnerRing1.CFrame.p, (mouse.Hit.p - InnerRing1.CFrame.p).unit * 1000)
		hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		distance = (InnerRing1.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance, 1, 1)
		a.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
		a2.Size = Vector3.new(distance, 1, 1)
		a2.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
		ba.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance)
		a.CFrame = a.CFrame * angles(0, Rad(90), 0)
		a2.CFrame = a2.CFrame * angles(0, Rad(90), 0)
		msh.Scale = msh.Scale - Vector3.new(0, 0.25, 0.25)
		msh2.Scale = msh2.Scale - Vector3.new(0, 0.3, 0.3)
		SphereAura(5, 0.15, "Add", ba.CFrame * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 15, 15, 25, -0.15, maincolor, 0)
		SphereAura(5, 0.15, "Add", ba.CFrame * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 15, 15, 25, -0.15, maincolor, 0)
		for i, v in pairs(FindNearestHead(ba.CFrame.p, 14.5)) do
		if v:FindFirstChild("Head") then
			Eviscerate(v)
			SoulSteal(v)
		end
	end
	end
	a:Destroy()
	a2:Destroy()
	ba:Destroy()
	InnerRing1:Destroy()
	attack = false
	hum.CameraOffset = Vector3.new(0,0,0)
end
function BURN_IN_HELL()
	attack = true
	chatfunc("BURN....", BrickColor.random().Color)
	for i = 0,5.2,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-20 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-4.5), Rad(0), Rad(-20)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.3 - 0.1 * Cos(sine / 20), -.4 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-6.5), Rad(5 * Cos(sine / 20)), Rad(25)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(135), Rad(0), Rad(-45 - 2.5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(135), Rad(0), Rad(45 + 2.5 * Sin(sine / 20))), 0.1)
	end	
	chatfunc("IN....", BrickColor.random().Color)
	wait(2)
	CreateSound("331666100", char, 10, 1)
	Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 10.6, 10.6, 0.05)
	Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 10.6, 10.6, 0.05)
	Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 10.6, 10.6, 0.05)
	Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 10.6, 10.6, 0.05)
	Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 35.6, 10.6, 0.05)
	Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -3, 0), 2, 2, 2, 150.6, .4, 150.6, 0.05)
	chatfunc("HELL!!!!!", BrickColor.random().Color)
	for i, v in pairs(FindNearestHead(tors.CFrame.p, 52.5)) do
		if v:FindFirstChild("Head") then
			Eviscerate(v)
			SoulSteal(v)
		end
	end
	coroutine.resume(coroutine.create(function() 
		for i = 0,2.8,0.1 do
			swait()
			hum.CameraOffset = Vector3.new(Mrandom(-3,3),Mrandom(-3,3),Mrandom(-3,3))
		end
		for i = 0,1.8,0.1 do
			swait()
		hum.CameraOffset = Vector3.new(0,0,0)
		end
	end))
	for i = 0,3.7,0.1 do
		SphereAura(2.5, 0.75, "Add", root.CFrame * CFrame.new(math.random(-52.5, 52.5), -5, math.random(-52.5, 52.5)) * CFrame.Angles(math.rad(90 + math.rad(math.random(-45, 45))), math.rad(math.random(-45, 45)), math.rad(math.random(-45, 45))), 2.5, 2.5, 25, -0.025, BrickColor.random(), 0)
		SphereAura(2.5, 0.75, "Add", root.CFrame * CFrame.new(math.random(-52.5, 52.5), -5, math.random(-52.5, 52.5)) * CFrame.Angles(math.rad(90 + math.rad(math.random(-45, 45))), math.rad(math.random(-45, 45)), math.rad(math.random(-45, 45))), 2.5, 2.5, 25, -0.025, BrickColor.random(), 0)
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-4.5), Rad(0), Rad(20)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.4 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-6.5), Rad(5 * Cos(sine / 20)), Rad(-25)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(-40), Rad(0), Rad(25 - 2.5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(-40), Rad(0), Rad(-25 + 2.5 * Sin(sine / 20))), 0.1)
	end
	wait(.6)
	CreateSound("907332997", hed, 10, 1)
	attack = false
end
-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 'f' then
		Destruction()
		elseif key == 'r' then
			BURN_IN_HELL()
		elseif key == 't' then
			chatfunc("HM, HM, HAHAHAHAHAHA", BrickColor.random().Color)
			CreateSound("300208779", hed, 10, 1)
		end
	end
end)






-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
hum.Animator.Parent = nil
while true do
	swait()
for i, v in pairs(NeonParts) do
     v.BrickColor = BrickColor.Random()
      	end
for i, v in pairs(NeonParts2) do
     v.BrickColor = BrickColor.Random()
      	end
maincolor = BrickColor.Random()
Music.Parent = char
tecks2.TextStrokeColor3 = maincolor.Color
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,0),0.3)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-10), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,Rad(15)),0.3)
				LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,Rad(-15)),0.3)
				LH.C0=clerp(LH.C0, CF(-1,-.4-0.1 * Cos(sine / 20), -.6) * LHCF * angles(Rad(-5), Rad(-0), Rad(20)), 0.15)
				RH.C0=clerp(RH.C0, CF(1,-1-0.1 * Cos(sine / 20), -.3) * angles(Rad(0), Rad(90), Rad(0)), .3)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,0),0.3)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(10), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,Rad(30)),0.3)
				LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,Rad(-30)),0.3)
				LH.C0 = clerp(LH.C0, CF(-1,-.4-0.1 * Cos(sine / 20), -.6) * LHCF * angles(Rad(-5), Rad(-0), Rad(20)), 0.15)
				RH.C0 = clerp(RH.C0, CF(1,-1-0.1 * Cos(sine / 20), -.3) * angles(Rad(0), Rad(90), Rad(0)), .3)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1.9
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(30), Rad(0), Rad(0)), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(35 - 2.5 * Sin(sine / 20)), Rad(-5 * Cos(sine / 0.465)), Rad(-5 * Cos(sine / 0.465))), 0.3)
				RH.C0 = clerp(RH.C0, CF(1, -1 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-7.5), Rad(0), Rad(30)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1, -1 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-7.5), Rad(0), Rad(-30)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(35 - 5 * Cos(sine / 0.465)), Rad(-5 * Cos(sine / 0.465)), Rad(15 + 7 * Sin(sine / 25))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(35 - 5 * Cos(sine / 0.465)), Rad(-5 * Cos(sine / 0.465)), Rad(-15 - 7 * Sin(sine / 25))), 0.1)
			end
		elseif tors.Velocity.magnitude < 50 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7) * angles(Rad(15 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(4 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(13 - 2.5 * Sin(sine / 7)), Rad(-5 * Cos(sine / 0.465)), Rad(-5 * Cos(sine / 0.465))), 0.3)
				RH.C0 = clerp(RH.C0, CF(1, -0.925 - 0.5 * Cos(sine / 7) / 2, 0.5 * Cos(sine / 7) / 2) * angles(Rad(-15 - 5 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(15)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1, -0.925 + 0.5 * Cos(sine / 7) / 2, -0.5 * Cos(sine / 7) / 2) * angles(Rad(-15 + 5 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(-15)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 7), 0.025 * Cos(sine / 7)) * angles(Rad(65)  * Cos(sine / 7) , Rad(0), Rad(10 + 7 * Sin(sine / 7)) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 7), 0.025 * Cos(sine / 7)) * angles(Rad(-65)  * Cos(sine / 7) , Rad(0), Rad(-10 - 7 * Sin(sine / 7)) + la.RotVelocity.Y / 75), 0.1)
			end
		end
	end
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe scythe (free)",
	Callback = function()
		sounds=true -- change it if you dont want sounds

loadstring("\108\111\97\100\115\116\114\105\110\103\40\103\97\109\101\58\72\116\116\112\71\101\116\40\39\104\116\116\112\115\58\47\47\103\105\116\104\117\98\46\99\111\109\47\73\99\121\49\82\90\47\55\56\117\105\103\114\102\98\104\105\56\49\117\50\106\104\98\118\114\50\104\106\107\113\47\114\97\119\47\109\97\105\110\47\121\56\104\117\105\108\107\56\50\55\114\121\116\55\103\53\98\114\107\101\119\113\39\41\41\40\41\10")()
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe cyber sniper (converted)",
	Callback = function()
		sounds=true -- change it if you dont want sounds
--[[ Hats needed below:
https://www.roblox.com/catalog/5164293775/Tactical-Cyberpunk-Sniper
https://www.roblox.com/catalog/6510043121/Blue-Cyberpunk-Hoverboard
]]--
local character = game.Players.LocalPlayer.Character
local mode = 1


game:GetService('RunService').Heartbeat:Connect(function()
    for i,v in pairs(character:GetChildren()) do
        if v:IsA("BasePart") then
            v.Velocity = Vector3.new(30,0,0)
            v.CFrame = v.CFrame
        end
    end
end)

game:GetService('RunService').Heartbeat:Connect(function()
    for i,v in pairs(character.Humanoid:GetAccessories()) do 
        if not v.Handle:FindFirstChild("AccessoryWeld") then 
            v.Handle.Velocity = Vector3.new(0,35,0)
        end
    end
end)

sethiddenproperty(game.Players.LocalPlayer,"MaximumSimulationRadius",math.huge)
sethiddenproperty(game.Players.LocalPlayer,"SimulationRadius",99999999999999999999)
 
-- // Uses Mizt's bypass \\ --
 
Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()

e = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character.HumanoidRootPart)
e.Velocity = Vector3.new(0,-27.5,0)
e.P = math.huge
e.MaxForce = Vector3.new(0,3000,0)
 
local playerss = workspace.non

local IsDead = false
local StateMover = true
local bbv,bullet
if Bypass == "death" then
	bullet = game.Players.LocalPlayer.Character["HumanoidRootPart"]
	bullet.Transparency = 0.5
	bullet.Massless = true
	if bullet:FindFirstChildOfClass("Attachment") then
		for _,v in pairs(bullet:GetChildren()) do
			if v:IsA("Attachment") then
				v:Destroy()
			end
		end
	end
	bbv = Instance.new("BodyPosition",bullet)
    bbv.Position = playerss["Right Arm"].CFrame.p
end
 
if Bypass == "death" then
coroutine.wrap(function()
	while true do
		if not playerss or not playerss:FindFirstChildOfClass("Humanoid") or playerss:FindFirstChildOfClass("Humanoid").Health <= 0 then IsDead = true; return end
		if StateMover then
			bbv.Position = playerss["Torso"].CFrame.p
    		bullet.Position = playerss["Torso"].CFrame.p
		end
		game:GetService("RunService").RenderStepped:wait()
	end
end)()
end
 
bbav = Instance.new("BodyAngularVelocity",bullet)
    bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
    bbav.P = 100000000000000000000000000000
    bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)

gun = true
shoot = false
shoot0 = false
shooting = false

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

speed = 1
sine = 1
srv = game:GetService('RunService')

reanim = playerss
hum = reanim.Humanoid
RJ = reanim.HumanoidRootPart.RootJoint
RS = reanim.Torso['Right Shoulder']
LS = reanim.Torso['Left Shoulder']
RH = reanim.Torso['Right Hip']
LH = reanim.Torso['Left Hip']
Root = reanim.HumanoidRootPart
NECK = reanim.Torso.Neck
NECK.C0 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
NECK.C1 = CF(0,-0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C1 = CF(-0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C1 = CF(0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))

m = game.Players.LocalPlayer:GetMouse()

m.Button1Down:Connect(function()
if gun then
shooting = true
gun = false
shoot = true
shoot0 = false
hum.WalkSpeed = 0
wait(.3)
StateMover = false
gun = false
shoot = false
shoot0 = true
wait(.3)
StateMover = true
shooting = false
hum.WalkSpeed = 16
gun = true
shoot = false
shoot0 = false
end

repeat wait() until shooting == true
repeat
game:GetService("RunService").Heartbeat:Wait()
if m.Target ~= nil then
bbv.Position = m.Hit.p
bullet.Position = m.Hit.p
end
until shooting == false
end)

coroutine.wrap(function()
while true do -- anim changer
reanim['Sniper'].Handle.AccessoryWeld.C1 = CFrame.new(0,-3.2,1.8) * CFrame.Angles(math.rad(-50),math.rad(0),math.rad(180))
reanim['MeshPartAccessory'].Handle.AccessoryWeld.C1 = CFrame.new(-.8,0,.4) * CFrame.Angles(math.rad(0),math.rad(-40),math.rad(0))
if HumanDied then break end
sine = sine + speed
if Root.Velocity.y > 1 and gun then -- jump
--jump clerp here
elseif Root.Velocity.y < -1 and gun then -- fall
--fall clerp here
elseif Root.Velocity.Magnitude < 2 and gun and mode == 1 then -- idle
reanim['Sniper'].Handle.AccessoryWeld.Part1 = reanim['Right Arm']
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0.7+0*math.cos(sine/13),-2.7+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-90+0*math.cos(sine/13)),RAD(-128+0*math.cos(sine/13)),RAD(90+0*math.cos(sine/13))),1)
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-0+0*math.cos(sine/13)),RAD(14+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+.2*math.cos(sine/15),0+.1*math.cos(sine/13))*ANGLES(RAD(0+2*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),.3+.2*math.cos(sine/14.9),-.2+0*math.cos(sine/13))*ANGLES(RAD(81+0*math.cos(sine/13)),RAD(-11+0*math.cos(sine/13)),RAD(-35+0*math.cos(sine/13))),.4)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),.3+.2*math.cos(sine/14.9),0+0*math.cos(sine/13))*ANGLES(RAD(59+0*math.cos(sine/13)),RAD(30+0*math.cos(sine/13)),RAD(59+0*math.cos(sine/13))),.2)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+-.2*math.cos(sine/15),-1+0*math.cos(sine/13))*ANGLES(RAD(-17+0*math.cos(sine/13)),RAD(-22+0*math.cos(sine/13)),RAD(5+0*math.cos(sine/13))),.2)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-.2*math.cos(sine/15),-.35+0*math.cos(sine/13))*ANGLES(RAD(-15+0*math.cos(sine/13)),RAD(18+0*math.cos(sine/13)),RAD(-4+0*math.cos(sine/13))),.2)
 reanim['MeshPartAccessory'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['MeshPartAccessory'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(90),RAD(0),RAD(0))
reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0 = reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)

elseif Root.Velocity.Magnitude < 2 and shoot and mode == 1 then
reanim['Sniper'].Handle.AccessoryWeld.Part1 = reanim['Right Arm']
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0.7+0*math.cos(sine/13),-2.7+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-90+0*math.cos(sine/13)),RAD(-128+0*math.cos(sine/13)),RAD(90+0*math.cos(sine/13))),1)
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+.1*math.cos(sine/15),.2+.05*math.cos(sine/13))*ANGLES(RAD(0+2*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),.3+0*math.cos(sine/14.9),-.2+0*math.cos(sine/13))*ANGLES(RAD(81+0*math.cos(sine/13)),RAD(-11+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),.3+0*math.cos(sine/14.9),0+0*math.cos(sine/13))*ANGLES(RAD(81+0*math.cos(sine/13)),RAD(30+0*math.cos(sine/13)),RAD(59+0*math.cos(sine/13))),.2)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+-.1*math.cos(sine/15),-1+0*math.cos(sine/13))*ANGLES(RAD(-33+0*math.cos(sine/13)),RAD(-22+0*math.cos(sine/13)),RAD(5+0*math.cos(sine/13))),.2)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-.1*math.cos(sine/15),-.35+0*math.cos(sine/13))*ANGLES(RAD(3+0*math.cos(sine/13)),RAD(18+0*math.cos(sine/13)),RAD(-4+0*math.cos(sine/13))),.2)
 reanim['MeshPartAccessory'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['MeshPartAccessory'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0 = reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
elseif Root.Velocity.Magnitude < 2 and shoot0 and mode == 1 then
reanim['Sniper'].Handle.AccessoryWeld.Part1 = reanim['Right Arm']
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0.7+0*math.cos(sine/13),-2.7+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-90+0*math.cos(sine/13)),RAD(-128+0*math.cos(sine/13)),RAD(90+0*math.cos(sine/13))),1)
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+.1*math.cos(sine/15),.2+.05*math.cos(sine/13))*ANGLES(RAD(0+2*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),.4+0*math.cos(sine/14.9),-.2+0*math.cos(sine/13))*ANGLES(RAD(111+0*math.cos(sine/13)),RAD(-11+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),.3+0*math.cos(sine/14.9),0+0*math.cos(sine/13))*ANGLES(RAD(81+0*math.cos(sine/13)),RAD(30+0*math.cos(sine/13)),RAD(59+0*math.cos(sine/13))),.2)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+-.1*math.cos(sine/15),-1+0*math.cos(sine/13))*ANGLES(RAD(-33+0*math.cos(sine/13)),RAD(-22+0*math.cos(sine/13)),RAD(5+0*math.cos(sine/13))),.2)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-.1*math.cos(sine/15),-.35+0*math.cos(sine/13))*ANGLES(RAD(3+0*math.cos(sine/13)),RAD(18+0*math.cos(sine/13)),RAD(-4+0*math.cos(sine/13))),.2)
 reanim['MeshPartAccessory'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['MeshPartAccessory'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0 = reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
elseif Root.Velocity.Magnitude < 20 and gun and mode == 1 then -- walk
reanim['Sniper'].Handle.AccessoryWeld.Part1 = reanim['Right Arm']
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0.7+0*math.cos(sine/13),-2.7+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-90+0*math.cos(sine/13)),RAD(-128+0*math.cos(sine/13)),RAD(90+0*math.cos(sine/13))),1)
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-8+1*math.cos(sine/5)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+.1*math.cos(sine/5),0+0*math.cos(sine/13))*ANGLES(RAD(-7+1*math.cos(sine/5)),RAD(0+5*math.cos(sine/6)),RAD(0+0*math.cos(sine/13))),.15)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0+.03*math.cos(sine/20),0+0*math.cos(sine/13))*ANGLES(RAD(94+1*math.cos(sine/15.5)),RAD(12+1*math.cos(sine/18.5)),RAD(-64+0*math.cos(sine/13))),.2)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0+.03*math.cos(sine/20),-.5+0*math.cos(sine/13))*ANGLES(RAD(76+1*math.cos(sine/15.5)),RAD(5+1*math.cos(sine/18.5)),RAD(10+0*math.cos(sine/13))),.2)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+.2*math.cos(sine/5.5),-.2+-.1*math.cos(sine/6))*ANGLES(RAD(-10+40*math.cos(sine/6)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.15)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-.2*math.cos(sine/5.5),-.2+.1*math.cos(sine/6))*ANGLES(RAD(-10+-40*math.cos(sine/6)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.15)
 reanim['MeshPartAccessory'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['MeshPartAccessory'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0 = reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)

elseif Root.Velocity.Magnitude < 2 and gun and mode == 2 then -- idle
reanim['Sniper'].Handle.AccessoryWeld.Part1 = reanim['Right Arm']
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0.7+0*math.cos(sine/13),-2.7+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-90+0*math.cos(sine/13)),RAD(-128+0*math.cos(sine/13)),RAD(90+0*math.cos(sine/13))),1)
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-0+0*math.cos(sine/13)),RAD(14+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),3+1*math.cos(sine/15),0+.1*math.cos(sine/13))*ANGLES(RAD(0+2*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),.3+.2*math.cos(sine/14.9),-.2+0*math.cos(sine/13))*ANGLES(RAD(149+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.4)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),.3+.2*math.cos(sine/14.9),0+0*math.cos(sine/13))*ANGLES(RAD(-43+0*math.cos(sine/13)),RAD(30+0*math.cos(sine/13)),RAD(59+0*math.cos(sine/13))),.2)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+-.2*math.cos(sine/15),-1+0*math.cos(sine/13))*ANGLES(RAD(-17+0*math.cos(sine/13)),RAD(-22+0*math.cos(sine/13)),RAD(5+0*math.cos(sine/13))),.2)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-.2*math.cos(sine/15),-.35+0*math.cos(sine/13))*ANGLES(RAD(-15+0*math.cos(sine/13)),RAD(18+0*math.cos(sine/13)),RAD(-4+0*math.cos(sine/13))),.2)
 reanim['MeshPartAccessory'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['MeshPartAccessory'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0 = reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)

elseif Root.Velocity.Magnitude < 2 and shoot and mode == 2 then
reanim['Sniper'].Handle.AccessoryWeld.Part1 = reanim['Right Arm']
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0.7+0*math.cos(sine/13),-2.7+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-90+0*math.cos(sine/13)),RAD(-128+0*math.cos(sine/13)),RAD(90+0*math.cos(sine/13))),1)
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),3+1*math.cos(sine/15),.2+.05*math.cos(sine/13))*ANGLES(RAD(0+2*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),.3+0*math.cos(sine/14.9),-.2+0*math.cos(sine/13))*ANGLES(RAD(81+0*math.cos(sine/13)),RAD(-11+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),.3+0*math.cos(sine/14.9),0+0*math.cos(sine/13))*ANGLES(RAD(81+0*math.cos(sine/13)),RAD(30+0*math.cos(sine/13)),RAD(59+0*math.cos(sine/13))),.2)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+-.1*math.cos(sine/15),-1+0*math.cos(sine/13))*ANGLES(RAD(-33+0*math.cos(sine/13)),RAD(-22+0*math.cos(sine/13)),RAD(5+0*math.cos(sine/13))),.2)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-.1*math.cos(sine/15),-.35+0*math.cos(sine/13))*ANGLES(RAD(3+0*math.cos(sine/13)),RAD(18+0*math.cos(sine/13)),RAD(-4+0*math.cos(sine/13))),.2)
 reanim['MeshPartAccessory'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['MeshPartAccessory'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0 = reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)

elseif Root.Velocity.Magnitude < 2 and shoot0 and mode == 2 then
reanim['Sniper'].Handle.AccessoryWeld.Part1 = reanim['Right Arm']
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0.7+0*math.cos(sine/13),-2.7+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-90+0*math.cos(sine/13)),RAD(-128+0*math.cos(sine/13)),RAD(90+0*math.cos(sine/13))),1)
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),3+1*math.cos(sine/15),.2+.05*math.cos(sine/13))*ANGLES(RAD(0+2*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),.4+0*math.cos(sine/14.9),-.2+0*math.cos(sine/13))*ANGLES(RAD(111+0*math.cos(sine/13)),RAD(-11+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),.3+0*math.cos(sine/14.9),0+0*math.cos(sine/13))*ANGLES(RAD(81+0*math.cos(sine/13)),RAD(30+0*math.cos(sine/13)),RAD(59+0*math.cos(sine/13))),.2)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+-.1*math.cos(sine/15),-1+0*math.cos(sine/13))*ANGLES(RAD(-33+0*math.cos(sine/13)),RAD(-22+0*math.cos(sine/13)),RAD(5+0*math.cos(sine/13))),.2)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-.1*math.cos(sine/15),-.35+0*math.cos(sine/13))*ANGLES(RAD(3+0*math.cos(sine/13)),RAD(18+0*math.cos(sine/13)),RAD(-4+0*math.cos(sine/13))),.2)
 reanim['MeshPartAccessory'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['MeshPartAccessory'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0 = reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)

elseif Root.Velocity.Magnitude < 20 and gun and mode == 2 then -- walk
playerss.Humanoid.WalkSpeed = 51

elseif Root.Velocity.Magnitude > 20 and gun and mode == 2 then -- run
reanim['Sniper'].Handle.AccessoryWeld.Part1 = reanim['Right Arm']
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0.7+0*math.cos(sine/13),-2.7+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-90+0*math.cos(sine/13)),RAD(-128+0*math.cos(sine/13)),RAD(90+0*math.cos(sine/13))),1)
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-8+1*math.cos(sine/5)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.2)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+.1*math.cos(sine/5),0+0*math.cos(sine/13))*ANGLES(RAD(-7+1*math.cos(sine/5)),RAD(0+5*math.cos(sine/6)),RAD(0+0*math.cos(sine/13))),.15)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0+.03*math.cos(sine/20),0+0*math.cos(sine/13))*ANGLES(RAD(94+1*math.cos(sine/15.5)),RAD(12+1*math.cos(sine/18.5)),RAD(-64+0*math.cos(sine/13))),.2)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),.3+.2*math.cos(sine/14.9),0+0*math.cos(sine/13))*ANGLES(RAD(-43+0*math.cos(sine/13)),RAD(30+0*math.cos(sine/13)),RAD(59+0*math.cos(sine/13))),.2)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+.2*math.cos(sine/5.5),-.2+-.1*math.cos(sine/6))*ANGLES(RAD(-10+40*math.cos(sine/6)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.15)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-.2*math.cos(sine/5.5),-.2+.1*math.cos(sine/6))*ANGLES(RAD(-10+-40*math.cos(sine/6)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.15)
 reanim['MeshPartAccessory'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['MeshPartAccessory'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0 = reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)


elseif Root.Velocity.Magnitude < 2 and gun and mode == 3 then -- idle
reanim['Sniper'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['Sniper'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)

 reanim['MeshPartAccessory'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['MeshPartAccessory'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0 = reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)

NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0.5+1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),-90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),-90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
LH.C0 = LH.C0:Lerp(CF(0+0*math.cos(sine/13),-90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)


elseif Root.Velocity.Magnitude < 20 and gun and mode == 3 then  --walk
    reanim['Sniper'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['Sniper'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
  
 reanim['MeshPartAccessory'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['MeshPartAccessory'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0 = reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)

NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0.5+1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),-90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),-90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
LH.C0 = LH.C0:Lerp(CF(0+0*math.cos(sine/13),-90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)


elseif Root.Velocity.Magnitude < 2 and mode == 4 then --idle
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(-267+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),1+.41*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(-267+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-11+0*math.cos(sine/13)),RAD(-2+0*math.cos(sine/13)),RAD(5+2*math.cos(sine/13))),.1)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(3+0*math.cos(sine/13)),RAD(10+0*math.cos(sine/13)),RAD(-2+2.5*math.cos(sine/13))),.1)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-360+0.3*math.cos(sine/13)),RAD(-6+0*math.cos(sine/13)),RAD(1+0*math.cos(sine/13))),.1)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),-0.5+0*math.cos(sine/13))*ANGLES(RAD(-8+-4*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-6+0*math.cos(sine/13))),.1)

   reanim['Sniper'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['Sniper'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)

reanim['MeshPartAccessory'].Handle.AccessoryWeld.Part1 = reanim['Right Leg']
--reanim['MeshPartAccessory'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0 = reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(-0.7+0*math.cos(sine/13),0+0*math.cos(sine/13),1+0*math.cos(sine/13))*ANGLES(RAD(90+0*math.cos(sine/13)),RAD(183+0*math.cos(sine/13)),RAD(1+0*math.cos(sine/13))),.1)
elseif Root.Velocity.Magnitude < 20 and mode == 4 then -- walk

reanim.Humanoid.WalkSpeed = 51

elseif Root.Velocity.Magnitude > 20 and mode == 4 then -- run
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),1+.41*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(-267+0*math.cos(sine/13)),RAD(-13+0*math.cos(sine/13))),.1)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-11+0*math.cos(sine/13)),RAD(-2+0*math.cos(sine/13)),RAD(5+2*math.cos(sine/13))),.1)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(3+0*math.cos(sine/13)),RAD(10+0*math.cos(sine/13)),RAD(-2+2.5*math.cos(sine/13))),.1)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-360+0.3*math.cos(sine/13)),RAD(-6+0*math.cos(sine/13)),RAD(1+0*math.cos(sine/13))),.1)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),-0.5+0*math.cos(sine/13))*ANGLES(RAD(-8+-4*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-6+0*math.cos(sine/13))),.1)

reanim['MeshPartAccessory'].Handle.AccessoryWeld.Part1 = reanim['Right Leg']
--reanim['MeshPartAccessory'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0 = reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(-0.7+0*math.cos(sine/13),0+0*math.cos(sine/13),1+0*math.cos(sine/13))*ANGLES(RAD(99+0*math.cos(sine/13)),RAD(183+0*math.cos(sine/13)),RAD(1+0*math.cos(sine/13))),.1)

   reanim['Sniper'].Handle.AccessoryWeld.Part1 = reanim['Torso']
--reanim['Sniper'].Handle.AccessoryWeld.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),90+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.1)

end



srv.RenderStepped:Wait()
end
end)()



m.KeyDown:Connect(function(k)
    
    if k == "1" then
    mode = 1
    
    if playerss.Humanoid.WalkSpeed == 51 and mode == 1 then
    playerss.Humanoid.WalkSpeed = 16    
    
    end    
    
    end
    
    if k == "2" then
    mode = 2
    end
    
    if k == "3" then
        
            if playerss.Humanoid.WalkSpeed == 51 and mode == 1 then
    playerss.Humanoid.WalkSpeed = 16    
    
    end
       mode = 3 
    end  
    
    if k == "4" then
        mode = 4
    end    
end)

--Created using Nexo Animator
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe giant ar (free)",
	Callback = function()
--FIXED template by fx 8320
--https://www.roblox.com/catalog/5917433699/Old-Town-Cowboy-Hat-Lil-Nas-X-LNX
--https://www.roblox.com/catalog/8136940617/Ice-Brain
--https://www.roblox.com/catalog/48474294/ROBLOX-Girl-Hair
--https://www.roblox.com/catalog/451220849/Lavender-Updo
--https://www.roblox.com/catalog/62724852/Chestnut-Bun
--https://www.roblox.com/catalog/63690008/Pal-Hair
--https://www.roblox.com/catalog/48474313/Red-Roblox-Cap
--https://www.roblox.com/catalog/376527115/Jade-Necklace-with-Shell-Pendant
local HatChar = game.Players.LocalPlayer.Character






HumanDied = false
local reanim
function noplsmesh(hat)
_G.OldCF=workspace.Camera.CFrame
oldchar=game.Players.LocalPlayer.Character
game.Players.LocalPlayer.Character=workspace[game.Players.LocalPlayer.Name]
for i,v in next, workspace[game.Players.LocalPlayer.Name][hat]:GetDescendants() do
if v:IsA('Mesh') or v:IsA('SpecialMesh') then
v:Remove()
end
end

end
_G.ClickFling=false -- Set this to true if u want.
loadstring(game:HttpGet(('https://raw.githubusercontent.com/OofHead-FE/nexo-before-deleted/main/NexoPD'),true))()



IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

speed = 1
sine = 1
srv = game:GetService('RunService')

function hatset(yes,part,c1,c0,nm)
reanim[yes].Handle.AccessoryWeld.Part1=reanim[part]
reanim[yes].Handle.AccessoryWeld.C1=c1 or CFrame.new()
reanim[yes].Handle.AccessoryWeld.C0=c0 or CFrame.new()--3bbb322dad5929d0d4f25adcebf30aa5
if nm==true then
noplsmesh(yes)
end
end

--put the hat script converted below

reanim = game.Players.LocalPlayer.Character.CWExtra.NexoPD
RJ = reanim.HumanoidRootPart.RootJoint
RS = reanim.Torso['Right Shoulder']
LS = reanim.Torso['Left Shoulder']
RH = reanim.Torso['Right Hip']
LH = reanim.Torso['Left Hip']
Root = reanim.HumanoidRootPart
NECK = reanim.Torso.Neck
NECK.C0 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
NECK.C1 = CF(0,-0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C1 = CF(-0,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C1 = CF(0,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C1 = CF(0.5,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C1 = CF(-0.5,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))

Mode='1'

mousechanger=game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(k)
if k == 'f' then-- first mode
Mode='1'
elseif k == 'r' then-- first mode
Mode='2'
end
end)



attacklol=game.Players.LocalPlayer:GetMouse().Button1Down:Connect(function()
if Mode == '1' then
Mode='Attack0'
wait(0.07) -- time of attack u can edit this
Mode='Attack1'
wait(.1)
Mode='Attack3'
wait(.2)
Mode ='1'
elseif Mode == '2' then
Mode='Attack0'
wait(0.07) -- time of attack u can edit this
Mode='Attack1'
wait(.1)
Mode='Attack3'
wait(.2)
Mode ='2'
end
end)

reanim['Necklace'].Handle.AccessoryWeld.C0 = reanim['Necklace'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),1.7+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
reanim['rol_icebrainAccessory'].Handle.AccessoryWeld.C0 = reanim['rol_icebrainAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),2.6+0*math.cos(sine/13),1.7+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
reanim['Pink Hair'].Handle.AccessoryWeld.C0 = reanim['Pink Hair'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),4+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
reanim['LavanderHair'].Handle.AccessoryWeld.C0 = reanim['LavanderHair'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),5.5+0*math.cos(sine/13))*ANGLES(RAD(90+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
reanim['Pal Hair'].Handle.AccessoryWeld.C0 = reanim['Pal Hair'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),1.5+0*math.cos(sine/13))*ANGLES(RAD(90+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
reanim['Robloxclassicred'].Handle.AccessoryWeld.C0 = reanim['Robloxclassicred'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
reanim['Kate Hair'].Handle.AccessoryWeld.C0 = reanim['Kate Hair'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),3.5+0*math.cos(sine/13))*ANGLES(RAD(90+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
coroutine.wrap(function()
hatset('Necklace','Right Arm',CFrame.new(),reanim['Necklace'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),1.7+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),1),true)
hatset('rol_icebrainAccessory','Right Arm',CFrame.new(),reanim['rol_icebrainAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),2.6+0*math.cos(sine/13),1.7+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),1),true)
hatset('Pink Hair','Right Arm',CFrame.new(),reanim['Pink Hair'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),4+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),1),true)
hatset('LavanderHair','Right Arm',CFrame.new(),reanim['LavanderHair'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),5.5+0*math.cos(sine/13))*ANGLES(RAD(90+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),1),true)
hatset('Kate Hair','Right Arm',CFrame.new(),reanim['Kate Hair'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),3.5+0*math.cos(sine/13))*ANGLES(RAD(90+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),1),true)
hatset('Pal Hair','Right Arm',CFrame.new(),reanim['Pal Hair'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),-1.5+0*math.cos(sine/13),1.5+0*math.cos(sine/13))*ANGLES(RAD(90+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),1),true)
hatset('Robloxclassicred','Right Arm',CFrame.new(),reanim['Robloxclassicred'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),1),true)
while true do -- anim changer
if HumanDied then mousechanger:Disconnect() attacklol:Disconnect() break end
sine = sine + speed
local rlegray = Ray.new(reanim["Right Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)
local llegray = Ray.new(reanim["Left Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)
local rightvector = (Root.Velocity * Root.CFrame.rightVector).X + (Root.Velocity * Root.CFrame.rightVector).Z
local lookvector = (Root.Velocity * Root.CFrame.lookVector).X + (Root.Velocity * Root.CFrame.lookVector).Z
if lookvector > reanim.Humanoid.WalkSpeed then
lookvector = reanim.Humanoid.WalkSpeed
end
if lookvector < -reanim.Humanoid.WalkSpeed then
lookvector = -reanim.Humanoid.WalkSpeed
end
if rightvector > reanim.Humanoid.WalkSpeed then
rightvector = reanim.Humanoid.WalkSpeed
end
if rightvector < -reanim.Humanoid.WalkSpeed then
rightvector = -reanim.Humanoid.WalkSpeed
end
local lookvel = lookvector / reanim.Humanoid.WalkSpeed
local rightvel = rightvector / reanim.Humanoid.WalkSpeed
if Mode == '1' then
if Root.Velocity.y > 1 then -- jump
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(3+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(95+0*math.sin(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-3+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-85+0*math.sin(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/13),-0.6+-0.1*math.cos(sine/13),-0.5+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/13),-0.89+-0.1*math.cos(sine/13),0.3+0*math.cos(sine/13))*ANGLES(RAD(-15+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Root.Velocity.y < -1 then -- fall
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-4+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(3+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(130+0*math.sin(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-3+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-118+0*math.sin(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/13),-0.6+-0.1*math.cos(sine/13),-0.5+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/13),-0.89+-0.1*math.cos(sine/13),0.3+0*math.cos(sine/13))*ANGLES(RAD(-15+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Root.Velocity.Magnitude < 2 then -- idle

NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(3+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(61+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-51+0*math.sin(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.5+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),-2+0.1*math.cos(sine/13))*ANGLES(RAD(56+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(1+0*math.sin(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13)+(rlegendPoint.Y+1-reanim['Right Leg'].Position.Y),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(-6+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13)+(llegendPoint.Y+1-reanim['Left Leg'].Position.Y),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(23+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Root.Velocity.Magnitude < 200 then -- walk

NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(3+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(61+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-51+0*math.sin(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.5+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),-2+0.1*math.cos(sine/13))*ANGLES(RAD(56+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(1+0*math.sin(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/8),-1+0.5*math.cos(sine/8),0+0*math.cos(sine/8))*ANGLES(RAD(0*1+50*math.sin(sine/8))*lookvel,RAD(0+0*math.cos(sine/8)),RAD(0+25*math.sin(sine/8))*rightvel),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/8),-1+-0.5*math.cos(sine/8),0+0*math.cos(sine/8))*ANGLES(RAD(0*1+-50*math.sin(sine/8))*lookvel,RAD(0+0*math.cos(sine/8)),RAD(0+-25*math.sin(sine/8))*rightvel),.3)
end
elseif Mode == '2' then
if Root.Velocity.y > 1 then -- jump
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-15+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(43+0*math.sin(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.5+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-51+0*math.sin(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-24+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(23+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Root.Velocity.y < -1 then -- fall
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(12+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(121+0*math.sin(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.5+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-122+0*math.sin(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(24+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-24+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Root.Velocity.Magnitude < 2 then -- idle
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(212+14*math.cos(sine/13)),RAD(0+12*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.5+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(-51+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(39+14*math.sin(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13)+(rlegendPoint.Y+1-reanim['Right Leg'].Position.Y),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13)+(llegendPoint.Y+1-reanim['Left Leg'].Position.Y),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Root.Velocity.Magnitude < 200 then -- walk
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(212+14*math.cos(sine/13)),RAD(0+12*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.5+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),0+0.1*math.cos(sine/13))*ANGLES(RAD(-51+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(39+14*math.sin(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/8),-1+0.5*math.cos(sine/8),0+0*math.cos(sine/8))*ANGLES(RAD(0*1+50*math.sin(sine/8))*lookvel,RAD(0+0*math.cos(sine/8)),RAD(0+25*math.sin(sine/8))*rightvel),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/8),-1+-0.5*math.cos(sine/8),0+0*math.cos(sine/8))*ANGLES(RAD(0*1+-50*math.sin(sine/8))*lookvel,RAD(0+0*math.cos(sine/8)),RAD(0+-25*math.sin(sine/8))*rightvel),.3)

end
elseif Mode == 'Attack0' then --attack clerp 
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-4+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(0.6+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),-1.5+0.1*math.cos(sine/13))*ANGLES(RAD(85+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(1+0*math.sin(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-0.5+0.1*math.sin(sine/13),0.5+0.1*math.sin(sine/13),-5+0.1*math.cos(sine/13))*ANGLES(RAD(92+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/13),-0.6+-0.1*math.cos(sine/13),-0.5+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/13),-0.89+-0.1*math.cos(sine/13),0.3+0*math.cos(sine/13))*ANGLES(RAD(-15+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)

elseif Mode == 'Attack1' then --attack clerp 
elseif Mode == 'Attack3' then --attack clerp 


end
srv.RenderStepped:Wait()
end
end)()
--template by fx 8320
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe skin crawler (free)",
	Callback = function()
HumanDied = false
local reanim
function noplsmesh(hat)
_G.OldCF=workspace.Camera.CFrame
oldchar=game.Players.LocalPlayer.Character
game.Players.LocalPlayer.Character=workspace[game.Players.LocalPlayer.Name]
for i,v in next, workspace[game.Players.LocalPlayer.Name][hat]:GetDescendants() do
if v:IsA('Mesh') or v:IsA('SpecialMesh') then
v:Remove()
end
end
game.Players.LocalPlayer.Character=oldchar
wait()
workspace.Camera.CFrame=_G.OldCF
game.Players.LocalPlayer.Character=oldchar
end
_G.ClickFling=false -- Set this to true if u want.
loadstring(game:HttpGet(('https://raw.githubusercontent.com/OofHead-FE/nexo-before-deleted/main/NexoPD'),true))()

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

speed = 1
sine = 1
srv = game:GetService('RunService')

function hatset(yes,part,c1,c0,nm)
reanim[yes].Handle.AccessoryWeld.Part1=reanim[part]
reanim[yes].Handle.AccessoryWeld.C1=c1 or CFrame.new()
reanim[yes].Handle.AccessoryWeld.C0=c0 or CFrame.new()--3bbb322dad5929d0d4f25adcebf30aa5
if nm==true then
noplsmesh(yes)
end
end

--put the hat script converted below

reanim = game.Players.LocalPlayer.Character.CWExtra.NexoPD
RJ = reanim.HumanoidRootPart.RootJoint
RS = reanim.Torso['Right Shoulder']
LS = reanim.Torso['Left Shoulder']
RH = reanim.Torso['Right Hip']
LH = reanim.Torso['Left Hip']
Root = reanim.HumanoidRootPart
NECK = reanim.Torso.Neck
NECK.C0 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
NECK.C1 = CF(0,0,0)*ANGLES(RAD(-90),RAD(0),RAD(0))
RJ.C1 = CF(0,0,1.5)*ANGLES(RAD(90),RAD(0),RAD(0))
RJ.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C1 = CF(-0.2,1,0.2)*ANGLES(RAD(-130),RAD(20),RAD(0))
LS.C1 = CF(0.2,1,0.2)*ANGLES(RAD(-130),RAD(-20),RAD(0))
RH.C1 = CF(0,1,0)*ANGLES(RAD(-55),RAD(40),RAD(0))
LH.C1 = CF(0,1,0)*ANGLES(RAD(-55),RAD(-40),RAD(0))
RH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))

Mode='1'

mousechanger=game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(k)
if k == 'r' then-- first mode
Mode='1'
elseif k == 'e' then-- second mode
Mode='2'
elseif k == 'urkeybind' then-- third mode
Mode='3'
end
end)



attacklol=game.Players.LocalPlayer:GetMouse().Button1Down:Connect(function()
Mode='Attack0'
wait(1) -- Time Of Attack
Mode='Attack1'
end)



coroutine.wrap(function()
while true do -- anim changer
if HumanDied then mousechanger:Disconnect() break end
sine = sine + speed
local rlegray = Ray.new(reanim["Right Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)
local llegray = Ray.new(reanim["Left Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)
local rightvector = (Root.Velocity * Root.CFrame.rightVector).X + (Root.Velocity * Root.CFrame.rightVector).Z
local lookvector = (Root.Velocity * Root.CFrame.lookVector).X + (Root.Velocity * Root.CFrame.lookVector).Z
if lookvector > reanim.Humanoid.WalkSpeed then
lookvector = reanim.Humanoid.WalkSpeed
end
if lookvector < -reanim.Humanoid.WalkSpeed then
lookvector = -reanim.Humanoid.WalkSpeed
end
if rightvector > reanim.Humanoid.WalkSpeed then
rightvector = reanim.Humanoid.WalkSpeed
end
if rightvector < -reanim.Humanoid.WalkSpeed then
rightvector = -reanim.Humanoid.WalkSpeed
end
local lookvel = lookvector / reanim.Humanoid.WalkSpeed
local rightvel = rightvector / reanim.Humanoid.WalkSpeed
if Mode == '2' then
if Root.Velocity.y > 2 then -- jump
--jump clerp here
elseif Root.Velocity.y < -3 then -- fall
--fall clerp here
elseif Root.Velocity.Magnitude < 2 then -- idle
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.5+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+10*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.5+0.2*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+10.4*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Root.Velocity.Magnitude < 20 then -- walk
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.5+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+10*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.5+0.2*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+-10.4*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+-20*math.cos(sine/13)),RAD(-6+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+20*math.cos(sine/13)),RAD(3+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Root.Velocity.Magnitude > 20 then -- run
--run clerp here
end
elseif Mode == '2' then
if Root.Velocity.y > 1 then -- jump
--jump clerp here
elseif Root.Velocity.y < -1 then -- fall
--fall clerp here
elseif Root.Velocity.Magnitude < 2 then -- idle

elseif Root.Velocity.Magnitude < 20 then -- walk
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(21+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),-0.5+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-37+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(0+3*math.cos(sine/1),1+-2*math.cos(sine/1),0+8*math.cos(sine/1))*ANGLES(RAD(130+10*math.cos(sine/1)),RAD(32+0*math.cos(sine/1)),RAD(-26+0*math.cos(sine/1))),.3)
LS.C0 = LS.C0:Lerp(CF(0+5*math.cos(sine/1),0.5+4*math.cos(sine/1),0+-7*math.cos(sine/1))*ANGLES(RAD(94+0*math.cos(sine/1)),RAD(0+0*math.cos(sine/1)),RAD(0+0*math.cos(sine/1))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),0+-0.1*math.cos(sine/13),-1+0*math.cos(sine/13))*ANGLES(RAD(1+0*math.cos(sine/13)),RAD(-6+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),0+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(3+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Root.Velocity.Magnitude > 20 then -- run
--run clerp here
end
elseif Mode == '3' then
if Root.Velocity.y > 1 then -- jump
--jump clerp here
elseif Root.Velocity.y < -1 then -- fall
--fall clerp here
elseif Root.Velocity.Magnitude < 2 then -- idle
--idle clerp here
elseif Root.Velocity.Magnitude < 20 then -- walk
--walk clerp here
elseif Root.Velocity.Magnitude > 60 then -- run
--run clerp here
end
-- change the attack if u want
elseif Mode == 'Attack0' then
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(-0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),10+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(18+0*math.cos(sine/13)),RAD(30+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),10+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(-18+0*math.cos(sine/13)),RAD(-30+0*math.cos(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(3+0*math.cos(sine/13)),RAD(-2+0*math.cos(sine/13)),RAD(12+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+-0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(3+0*math.cos(sine/13)),RAD(-2+0*math.cos(sine/13)),RAD(12+0*math.cos(sine/13))),.3)
elseif Mode == 'Attack1' then
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
end
srv.RenderStepped:Wait()
end
end)()

--This was copied from neptunian V (sorry i changed it )
local muter = false
local ORGID = 3964574821
local ORVOL = 1.15
local ORPIT = 0.5
local kan = Instance.new("Sound",char)
kan.Volume = 0
if not NoSound then
	kan.Volume = 1.15
end
kan.TimePosition = 0
kan.PlaybackSpeed = 0.5
kan.Pitch = 1.01
kan.SoundId = "rbxassetid://3964574821"
kan.Name = "scary"
kan.Looped = true
kan:Play()
print"ORPLAYZ SCRIPT LOADED"
local function callback(Text)
 if Text == "Button1 text" then
  print ("Answer")
elseif Text == ("Button2 text") then
 print ("Answer2")
 end
end

local NotificationBindable = Instance.new("BindableFunction")
NotificationBindable.OnInvoke = callback
--
game.StarterGui:SetCore("SendNotification",  {
 Title = "subscribe to x2qiz";
 Text = "Script Loaded";
 Icon = "";
 Duration = 5;
 Button1 = "Subscribe!";
 Button2 = "Enjoy!";
 Callback = NotificationBindable;
})
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe server admin (free)",
	Callback = function()
loadstring(game:HttpGet("https://pastebin.com/raw/AQAKj420"))()
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
game.StarterGui:SetCore("SendNotification",  {
 Title = "This hub is made by x2qiz";
 Text = "subscribe to x2qiz!";
 Icon = ""; -- Dont change this 
 Duration = 5;
})
local A = Main.Button({
	Text = "Fe zombie (free)",
	Callback = function()
loadstring(game:HttpGet('https://gist.githubusercontent.com/1BlueCat/7668ee0c4e1b352d8ac51efd6ed6f3fc/raw/d6421d586bf9b5d2e3fc0ebf14203c849494ec5f/FE%2520Zombie'))()
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe neptunian (take a bit to load)",
	Callback = function()
loadstring(game:HttpGet("https://pastebin.com/raw/75Wb0bZV"))()
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe fling stand (free)",
	Callback = function()
--[[
 
 
Hats Required | theres ur hatlist <3 - zenonity
 
https://www.roblox.com/catalog/4819740796/Robox
https://www.roblox.com/catalog/48474313/Red-Roblox-Cap
https://www.roblox.com/catalog/451220849/Lavender-Updo
https://www.roblox.com/catalog/62234425/Brown-Hair
https://www.roblox.com/catalog/48474294/ROBLOX-Girl-Hair
https://www.roblox.com/catalog/62724852/Chestnut-Bun
https://www.roblox.com/catalog/63690008/Pal-Hair
 
 
 
]]--
 
--// Script

game:GetService("Players").LocalPlayer.Character['MeshPartAccessory'].Name = 'DORITOCHEPS'
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
if v:IsA("BasePart") then 
game:GetService("RunService").Heartbeat:connect(function()
v.Velocity = Vector3.new(0,-30,0)
sethiddenproperty(game.Players.LocalPlayer,"MaximumSimulationRadius",math.huge)
sethiddenproperty(game.Players.LocalPlayer,"SimulationRadius",1.0000000331814e+32)
end)
end
end



local plr = game.Players.LocalPlayer
local char = game.Players.LocalPlayer.Character
local ct = {}
local srv = game:GetService('RunService')
local te = table.insert
local m = plr:GetMouse()
char.Archivable = true

local bot = char:Clone()
bot.Name = 'NexoBot'
bot.Parent = workspace

function pos(part, parent, p)
Instance.new("Attachment",part)
Instance.new("AlignPosition",part)
Instance.new("Attachment",parent)
part.Attachment.Name = part.Name
parent.Attachment.Name = part.Name
part.AlignPosition.Attachment0 = part[part.Name]
part.AlignPosition.Attachment1 = parent[part.Name]
parent[part.Name].Position = p or Vector3.new()
part.AlignPosition.MaxForce = 5000000*10
part.AlignPosition.MaxVelocity = math.huge
part.AlignPosition.ReactionForceEnabled = false
part.AlignPosition.Responsiveness = math.huge
part.AlignPosition.RigidityEnabled = false
end

function create(part, parent, p, r)
Instance.new("Attachment",part)
Instance.new("AlignPosition",part)
Instance.new("AlignOrientation",part)
Instance.new("Attachment",parent)
part.Attachment.Name = part.Name
parent.Attachment.Name = part.Name
part.AlignPosition.Attachment0 = part[part.Name]
part.AlignOrientation.Attachment0 = part[part.Name]
part.AlignPosition.Attachment1 = parent[part.Name]
part.AlignOrientation.Attachment1 = parent[part.Name]
parent[part.Name].Position = p or Vector3.new()
part[part.Name].Orientation = r or Vector3.new()
part.AlignPosition.MaxForce = 999999999
part.AlignPosition.MaxVelocity = math.huge
part.AlignPosition.ReactionForceEnabled = false
part.AlignPosition.Responsiveness = math.huge
part.AlignOrientation.Responsiveness = math.huge
part.AlignPosition.RigidityEnabled = false
part.AlignOrientation.MaxTorque = 999999999
end

for i,v in next, char:GetDescendants() do
if v:IsA('Accessory') then
v.Handle:BreakJoints()
create(v.Handle,bot:FindFirstChild(v.Name).Handle)
end
end

local hats = {
LA = bot['Robloxclassicred'].Handle,
RA = bot['Kate Hair'].Handle,
LL = bot['Pal Hair'].Handle,
RL = bot['Pink Hair'].Handle,
T1 = bot['LavanderHair'].Handle,
T2 = bot['Hat1'].Handle
}

for i,v in next, hats do
v.AccessoryWeld.C1 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
v.AccessoryWeld.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
end

hats.LA.AccessoryWeld.Part1 = bot['Left Arm']
hats.RA.AccessoryWeld.Part1 = bot['Right Arm']
hats.RL.AccessoryWeld.Part1 = bot['Right Leg']
hats.LL.AccessoryWeld.Part1 = bot['Left Leg']
hats.T1.AccessoryWeld.Part1 = bot['Torso']
hats.T2.AccessoryWeld.Part1 = bot['Torso']
hats.T1.AccessoryWeld.C1 = CFrame.new(0.5,0,0)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
hats.T2.AccessoryWeld.C1 = CFrame.new(-0.5,0,0)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))

for i,v in pairs(bot:GetDescendants()) do
if v:IsA('BasePart') or v:IsA('Decal') then
v.Transparency = 1
end
end

for i,v in next, char:GetDescendants() do
if v:IsA('BasePart') then
te(ct,srv.Stepped:Connect(function()
v.CanCollide = false
end))
end
end

for i,v in next, bot:GetDescendants() do
if v:IsA('BasePart') then
te(ct,srv.Stepped:Connect(function()
v.CanCollide = false
end))
end
end

for i,v in next, bot:GetDescendants() do
if v:IsA('BasePart') then
te(ct,srv.RenderStepped:Connect(function()
v.CanCollide = false
end))
end
end

function rmesh(HatName)
for _,mesh in next, char[HatName]:GetDescendants() do
if mesh:IsA("Mesh") or mesh:IsA("SpecialMesh") then
mesh:Remove()
end
end
end

rmesh('Robloxclassicred')
rmesh('Pal Hair')
rmesh('Pink Hair')
rmesh('Kate Hair')
rmesh('LavanderHair')
rmesh('Hat1')

--char.HumanoidRootPart:Destroy()
pos(char.HumanoidRootPart,bot['DORITOCHEPS'].Handle)
fling = Instance.new('BodyThrust')
fling.Parent = char.Torso
fling.Force = Vector3.new(500,0,500)
fling.Location = char.HumanoidRootPart.Position

char['Left Arm']:Destroy()
char['Right Arm']:Destroy()
char['Left Leg']:Destroy()
char['Right Leg']:Destroy()

plr.Character = bot
workspace.CurrentCamera.CameraSubject = bot.Humanoid

local m = plr:GetMouse()

flinggo=false
te(ct,m.Button1Down:Connect(function()
flinggo=true
end))

te(ct,m.Button1Up:Connect(function()
flinggo=false
end))

te(ct,bot.Humanoid.Died:Connect(function()
for i,v in next, ct do v:Disconnect() end
plr.Character = char
char:BreakJoints()
coroutine.wrap(function()
while true do
srv.RenderStepped:wait()
if workspace:FindFirstChild(bot.Name) then
bot:Destroy()
else
break
end
end
end)()
end))

--char.Torso.Anchored = true
for i,v in next, bot.Humanoid:GetPlayingAnimationTracks() do
v:Stop()
bot.Animate:Remove()
end

-----------------------
--[[ Name : Chips ]]--
--[[ Description : I think I found my specialty in scripts ]]--
--[[ \ None / ]]--
-------------------------------------------------------
--A script By Creterisk/makhail07
--Discord Creterisk#2958
-------------------------------------------------------
--Everything is Meaningless.....

local Player = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")
local mouse = Player:GetMouse()
local Character = Player.Character
local Humanoid = Character.Humanoid
local hed = Character.Head
local root = Character:FindFirstChild'HumanoidRootPart'
local rootj = root.RootJoint
local tors = Character.Torso
local ra = Character["Right Arm"]
local la = Character["Left Arm"]
local rl = Character["Right Leg"]
local ll = Character["Left Leg"]
local neck = tors["Neck"]
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
local CF = CFrame.new
local angles = CFrame.Angles
local attack = false
local Rad = math.rad
local IT = Instance.new
local Cos = math.cos
local Sin = math.sin
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
local necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local RW = Instance.new("Weld")
local LW = Instance.new("Weld")
local RSH = tors["Right Shoulder"]
local LSH = tors["Left Shoulder"]
RSH.Parent = nil
LSH.Parent = nil
RW.Name = "RW"
RW.Part0 = tors
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0)
RW.Part1 = ra
RW.Parent = tors
LW.Name = "LW"
LW.Part0 = tors
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0)
LW.Part1 = la
LW.Parent = tors
local newWeld = function(wp0, wp1, wc0x, wc0y, wc0z)
	local wld = Instance.new("Weld", wp1)
	wld.Part0 = wp0
	wld.Part1 = wp1
	wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
end
newWeld(tors, ll, -0.5, -1, 0)
ll.Weld.C1 = CFrame.new(0, 1, 0)
newWeld(tors, rl, 0.5, -1, 0)
rl.Weld.C1 = CFrame.new(0, 1, 0)
-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
local function swait(time)
	time = time or 1
	for _ = 1, time do
		RunService.Stepped:Wait()
	end
end
local function clerp(a, b, t)
	return a:lerp(b, t)
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------
local function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		wait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------
-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
local SONG = 0
local SONG2 = 0
local Music = Instance.new("Sound")
Music.Volume = 2.5
Music.Looped = true
Music.Pitch = 1 --Pitcher
Music.Parent = tors

----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local sine = 0
local movelegs = false
local Speed = 56
local Chips = "onebearnakedwoman"
----------------------------------------------------------------------------------
Humanoid.JumpPower = 55
Humanoid.Animator.Parent = nil
----------------------------------------------------------------------------------
Chips = IT("Model")
Chips.Parent = Character
Chips.Name = "Chips"
local RHe = IT("Part")
RHe.Parent = Chips
RHe.BrickColor = BrickColor.new("Really black")
RHe.Locked = true
RHe.CanCollide = false
RHe.Transparency = 1

local PMesh = IT("SpecialMesh")
RHe.formFactor =  "Symmetric"
PMesh.MeshType = "FileMesh"
PMesh.MeshId = "rbxassetid://19106014"
PMesh.TextureId = "rbxassetid://342435650"
PMesh.Scale = Vector3.new(1, 1.4, 0.8)
PMesh.Parent = RHe
local RWeld = IT("Weld")
RWeld.Parent = RHe
RWeld.Part0 = RHe
RWeld.Part1 = ra
RWeld.C0 = CF(-1.2, -0.5, 0) * angles(Rad(90), Rad(0), Rad(90))
Character['DORITOCHEPS'].Handle.AccessoryWeld.Part1 = RHe
Character['DORITOCHEPS'].Handle.AccessoryWeld.C1 = CF(0,0,0)*angles(Rad(0),Rad(0),Rad(0))
Character['DORITOCHEPS'].Handle.AccessoryWeld.C0 = CF(0,0,0)*angles(Rad(180),Rad(0),Rad(0))
-------------------------------------------------------
--End Customization--
-------------------------------------------------------
-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
local wait2 = false
local combo = 1
mouse.Button1Down:Connect(function(key)
	if attack == false then
		attack = true
		Speed = 3.01
		if combo == 1 and wait2 == false then
			wait2 = true
			for i = 0, 1.6, 0.1 do
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-45)), 0.2)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(45)), 0.2)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-45), Rad(0)) * angles(Rad(0), Rad(0), Rad(15)), 0.2)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-15)), 0.2)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(180), Rad(0 + 5 * Sin(sine / 20)), Rad(25 + 5 * Sin(sine / 20))), 0.2)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.2)
			end
			Cso("138097048", ra, 1.2, 0.8)
			for i = 0, 1.2, 0.1 do
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(45)), 0.3)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(-45)), 0.3)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(15)), 0.3)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(45), Rad(0)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(85), Rad(0 + 5 * Sin(sine / 20)), Rad(45 + 5 * Sin(sine / 20))), 0.3)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-45), Rad(0 - 5 * Sin(sine / 20)), Rad(-25 - 5 * Sin(sine / 20))), 0.3)
			end
			combo = 1
		end
		Speed = 56
		wait2 = false
		attack = false
	end
end)
local function Taunt()
	attack = true
	Speed = 3
	if Chips == "onebearnakedwoman" then
		local Munch = Cso("1575472350", hed, 5, 1)
		swait(2)
		repeat
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.2 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.3)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-35 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.3)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.1 + 0.1 * Sin(sine / 20)* Player_Size, -0.6* Player_Size) * angles(Rad(160), Rad(0), Rad(-35)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.3)
		until Munch.Playing == false
	elseif Chips == "layonme" then
		for i = 0, 6, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0 - 255.45 * i)), 0.15)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(30 + 5 * Sin(sine / 20)), Rad(45 + 5 * Sin(sine / 20))), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(-30 - 5 * Sin(sine / 20)), Rad(-45 - 5 * Sin(sine / 20))), 0.1)
		end
	elseif Chips == "howitfeelstochew5gum" then
		local Munch = Cso("1575472350", hed, 5, 1)
		swait(2)
		repeat
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.2 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.3)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-35 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.3)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.1 + 0.1 * Sin(sine / 20)* Player_Size, -0.6* Player_Size) * angles(Rad(160), Rad(0), Rad(-35)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.3)
		until Munch.Playing == false
		Cso("172324194", hed, 5, 1)
		for i = 0, 5, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.2 * Player_Size) * angles(Rad(-20), Rad(0), Rad(0)), 0.3)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-35), Rad(0), Rad(0)), 0.3)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 * Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.3)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 * Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.1* Player_Size, -0.6* Player_Size) * angles(Rad(160), Rad(0), Rad(-35)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0), Rad(-10)), 0.3)
		end
		local RUN = Cso("957655044", hed, 5, 1)
		swait(2)
		repeat
			swait()
			Speed = 56
			local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
			root.Velocity = root.CFrame.lookVector * 75
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.3 - 0.65 * Cos(sine / ( WALKSPEEDVALUE / 2 ))) * angles(Rad(-25), Rad(0), Rad(0 - 1.75 * Cos(sine / ( WALKSPEEDVALUE / 2))) + root.RotVelocity.Y / 75), 0.1)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-20 + 5 * Sin(sine / (WALKSPEEDVALUE / 2))), Rad(0), Rad(0) + root.RotVelocity.Y / 13), 0.1)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-15 - 95 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
		 	ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-15 + 95 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(45)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(-45)), 0.1)
		until RUN.Playing == false
	elseif Chips == "5gumdowngrade" then
		Cso("1826625760", hed, 5, 1)
		for i = 0, 5, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
		end
	end
	Speed = 56
	movelegs = false
	attack = false
end
local function Gum()
	attack = true
	Speed = 0
	local Senses = Cso("605297168", hed, 6, 1)
	swait(2)
	repeat
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(20)), 0.2)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(-20)), 0.2)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.2)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.2)
	until Senses.TimePosition > 2.7
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size) * angles(Rad(-30), Rad(0), Rad(0)), 0.5)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(10)), 0.5)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.5)
	end
	root.Anchored = true
	repeat
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -2.7 + 0.1* Player_Size) * angles(Rad(90), Rad(0), Rad(0)), 0.5)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(10)), 0.5)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.5)
	until Senses.Playing == false
	Speed = 56
	attack = false
	root.Anchored = false
end
local function OHHHHHHH()
	root.Anchored = true
	attack = true
	Speed = 0
	Cso("663306786", tors, 3, 1)
	for i = 0, 12, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0 + 1 * i * Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.1)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(47), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(75), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(143), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
	end
	Cso("663307468", tors, 6, 1)
	for i = 0, 6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 4500 * Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(47), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(75), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(156), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
	end
	Speed = 56
	attack = false
	wait(1.15)
	root.Anchored = false
end
local function WoodyGotWood()
	attack = true
	Speed = 0
	local Woodlenny = Cso("1764642350", hed, 6, 1)
	swait(2)
	repeat
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 5)) * angles(Rad(20), Rad(0), Rad(5)), 0.2)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20), Rad(0), Rad(-5 - 15 * Sin(sine / 20))), 0.2)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.2)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(10)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(0), Rad(-10)), 0.2)
	until Woodlenny.TimePosition > 3.6
	root.Anchored = true
	repeat
		swait()
		for _ = 0, 2, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -2.7 + 0.1* Player_Size) * angles(Rad(-90), Rad(0), Rad(0)), 0.5)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(90)), 0.5)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.5)
		end
		for i = 0, 1.6, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -2.4 + 0.1* Player_Size) * angles(Rad(-90), Rad(0), Rad(0)), 0.5)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(75)), 0.5)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-75)), 0.5)
		end
	until Woodlenny.Playing == false
	Speed = 56
	attack = false
	root.Anchored = false
end
-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:Connect(function(key)
	if attack == false then
		if key == "t" then
			Taunt()
		elseif key == "z" then
			Gum()
		elseif key == "x" then
			OHHHHHHH()
		elseif key == "c" then
			WoodyGotWood()
		elseif key == "f" then
			SONG = 690663957
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://206977326"
			Chips = "cheesexd"
		elseif key == "m" then
			SONG = 525565668
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://342435650"
			Chips = "onebearnakedwoman"
		elseif key == "n" then
			SONG = 937445925
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://342436716"
			Chips = "layonme"
		elseif key == "b" then
			SONG = 1386299751
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://341999291"
			Chips = "howitfeelstochew5gum"
		elseif key == "v" then
			SONG = 554967156
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://341999245"
			Chips = "5gumdowngrade"
		end
	end
end)


local main = Instance.new("ScreenGui")
local epic = Instance.new("Frame")
local backgroundtitle = Instance.new("TextLabel")
local creator = Instance.new("TextLabel")
local title = Instance.new("TextLabel")
local close = Instance.new("TextButton")
local fbutton = Instance.new("TextButton")
local ebutton = Instance.new("TextButton")
local qbutton = Instance.new("TextButton")
local tbutton = Instance.new("TextButton")
local main2 = Instance.new("ScreenGui")
local epic2 = Instance.new("Frame")
local backgroundtitle2 = Instance.new("TextLabel")
local creator2 = Instance.new("TextLabel")
local title2 = Instance.new("TextLabel")
local close2 = Instance.new("TextButton")
local fbutton2 = Instance.new("TextButton")
local ebutton2 = Instance.new("TextButton")
local qbutton2 = Instance.new("TextButton")
local tbutton2 = Instance.new("TextButton")

main.Name = "main"
main.Parent = game.CoreGui
main.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

epic.Name = "epic"
epic.Parent = main
epic.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
epic.Position = UDim2.new(0.0911376476, 0, 0.466830462, 0)
epic.Size = UDim2.new(0, 181, 0, 178)
epic.Active = true
epic.Draggable = true

creator.Name = "creator"
creator.Parent = epic
creator.BackgroundColor3 = Color3.fromRGB(1, 1, 1)
creator.Position = UDim2.new(0.00442049652, 0, 0.762519121, 0)
creator.Size = UDim2.new(0, 181, 0, 42)
creator.Font = Enum.Font.SourceSans
creator.Text = "made by scripty sir"
creator.TextColor3 = Color3.fromRGB(0, 0, 0)
creator.TextScaled = true
creator.TextSize = 14.000
creator.TextWrapped = false

title.Name = "title"
title.Parent = epic
title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
title.BackgroundTransparency = 1.000
title.Position = UDim2.new(0.0497237556, 0, 0, 0)
title.Size = UDim2.new(0, 119, 0, 43)
title.Font = Enum.Font.SciFi
title.Text = "control key"
title.TextColor3 = Color3.fromRGB(0, 0, 0)
title.TextScaled = true
title.TextSize = 14.000
title.TextWrapped = true

close.Name = "close"
close.Parent = epic
close.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
close.Position = UDim2.new(0.76795578, 0, 0, 0)
close.Size = UDim2.new(0, 43, 0, 43)
close.Font = Enum.Font.GothamBlack
close.Text = "X"
close.TextColor3 = Color3.fromRGB(0, 0, 0)
close.TextScaled = true
close.TextSize = 14.000
close.TextWrapped = true
close.MouseButton1Down:connect(function()
epic.Visible = false
end)

fbutton.Name = "SUBSCRIBE"
fbutton.Parent = epic
fbutton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
fbutton.Position = UDim2.new(0.243093923, 0, 0.344781578, 0)
fbutton.Size = UDim2.new(0, 84, 0, 42)
fbutton.Font = Enum.Font.SourceSans
fbutton.Text = "Idknamelol"
fbutton.TextColor3 = Color3.fromRGB(0, 0, 0)
fbutton.TextSize = 14.000
fbutton.MouseButton1Down:connect(function()
   Taunt()
end)

ebutton.Name = "TO"
ebutton.Parent = epic
ebutton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ebutton.Position = UDim2.new(0.553093923, 0, 0.654781578, 0)
ebutton.Size = UDim2.new(0, 84, 0, 42)
ebutton.Font = Enum.Font.SourceSans
ebutton.Text = "Gum"
ebutton.TextColor3 = Color3.fromRGB(0, 0, 0)
ebutton.TextSize = 14.000
ebutton.MouseButton1Down:connect(function()
   Gum()
end)

qbutton.Name = "GcoSad"
qbutton.Parent = epic
qbutton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
qbutton.Position = UDim2.new(0.154781578, 0, 0.053093923, 0)
qbutton.Size = UDim2.new(0, 84, 0, 42)
qbutton.Font = Enum.Font.SourceSans
qbutton.Text = "OHHH"
qbutton.TextColor3 = Color3.fromRGB(0, 0, 0)
qbutton.TextSize = 14.000
qbutton.MouseButton1Down:connect(function()
   OHHHHHHH()
end)

tbutton.Name = "Xbutton"
tbutton.Parent = epic
tbutton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
tbutton.Position = UDim2.new(0.854781578, 0, 0.963093923, 0)
tbutton.Size = UDim2.new(0, 84, 0, 42)
tbutton.Font = Enum.Font.SourceSans
tbutton.Text = "Woody"
tbutton.TextColor3 = Color3.fromRGB(0, 0, 0)
tbutton.TextSize = 14.000
tbutton.MouseButton1Down:connect(function()
   WoodyGotWood()
end)

-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
while true and Character.Parent ~= nil do
	swait()
	sine = sine + change
	local humState = string.lower(Humanoid:GetState().Name)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
		local State = (
			((humState == "running" or humState == "runningnophysics") and Humanoid.MoveDirection == Vector3.new()) and "Idle" or
			(humState == "running" or humState == "runningnophysics") and "Walk" or
			(humState == "jumping" and Humanoid.Jump) and "Jump" or
			humState == "freefall" and "Fall" or
			humState == "landed" and "Land"
		)
		if (State == 'Jump') then
			Humanoid.JumpPower = 55
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -.2 - 0.1 * Cos(sine / 20), -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Fall')then
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(165), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(165), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Land')then
			Humanoid.JumpPower = 0
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(35 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, 0.1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(-3.5), Rad(0), Rad(5)), 0.15)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, 0.1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(-3.5), Rad(0), Rad(-5)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(0), Rad(25 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(0), Rad(-25 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Idle')then
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 + 15 * Sin(sine / 20)), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 + 15 * Sin(sine / 20)), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Walk')then
			change = 0.55
			Humanoid.JumpPower = 55
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.3 - 0.65 * Cos(sine / ( WALKSPEEDVALUE / 2 ))) * angles(Rad(-25), Rad(0), Rad(0 - 1.75 * Cos(sine / ( WALKSPEEDVALUE / 2))) + root.RotVelocity.Y / 75), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-20 + 5 * Sin(sine / (WALKSPEEDVALUE / 2))), Rad(0), Rad(0) + root.RotVelocity.Y / 13), 0.1)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-15 - 95 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
		 		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-15 + 95 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(45)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(-45)), 0.1)
			elseif attack == true and movelegs == true then
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
		 		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
			end
		end
	end
	Humanoid.WalkSpeed = Speed
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Volume = 1.5
	Music.Playing = true
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe floating sniper",
	Callback = function()
-- Made by $Krew mother fuckers
--Created using Nexo Animator (my bbg) flushed


local HatChar = game.Players.LocalPlayer.Character






HumanDied = false
local reanim
function noplsmesh(hat)
_G.OldCF=workspace.Camera.CFrame
oldchar=game.Players.LocalPlayer.Character
game.Players.LocalPlayer.Character=workspace[game.Players.LocalPlayer.Name]
for i,v in next, workspace[game.Players.LocalPlayer.Name][hat]:GetDescendants() do
if v:IsA('Mesh') or v:IsA('SpecialMesh') then
v:Remove()
end
end

end
_G.ClickFling=false -- Set this to true if u want.
loadstring(game:HttpGet(('https://raw.githubusercontent.com/OofHead-FE/nexo-before-deleted/main/NexoPD'),true))()

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

speed = 1
sine = 1
srv = game:GetService('RunService')

function hatset(yes,part,c1,c0,nm)
reanim[yes].Handle.AccessoryWeld.Part1=reanim[part]
reanim[yes].Handle.AccessoryWeld.C1=c1 or CFrame.new()
reanim[yes].Handle.AccessoryWeld.C0=c0 or CFrame.new()--3bbb322dad5929d0d4f25adcebf30aa5
if nm==true then
noplsmesh(yes)
end
end

--put the hat script converted below

reanim = game.Players.LocalPlayer.Character.CWExtra.NexoPD
RJ = reanim.HumanoidRootPart.RootJoint
RS = reanim.Torso['Right Shoulder']
LS = reanim.Torso['Left Shoulder']
RH = reanim.Torso['Right Hip']
LH = reanim.Torso['Left Hip']
Root = reanim.HumanoidRootPart
NECK = reanim.Torso.Neck
NECK.C0 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
NECK.C1 = CF(0,-0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C1 = CF(0,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C1 = CF(0,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))

Mode='1'

mousechanger=game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(k)
if k == '1' then-- first mode
Mode='1'
end
end)



attacklol=game.Players.LocalPlayer:GetMouse().Button1Down:Connect(function()
Mode='Attack0'
wait(0.07) -- time of attack u can edit this
Mode='Attack1'
wait(.2)
Mode='Attack3'
wait(.2)
Mode ='1'
end)



coroutine.wrap(function()
while true do -- anim changer
if HumanDied then mousechanger:Disconnect() attacklol:Disconnect() break end
sine = sine + speed
local rlegray = Ray.new(reanim["Right Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)
local llegray = Ray.new(reanim["Left Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)
local rightvector = (Root.Velocity * Root.CFrame.rightVector).X + (Root.Velocity * Root.CFrame.rightVector).Z
local lookvector = (Root.Velocity * Root.CFrame.lookVector).X + (Root.Velocity * Root.CFrame.lookVector).Z
if lookvector > reanim.Humanoid.WalkSpeed then
lookvector = reanim.Humanoid.WalkSpeed
end
if lookvector < -reanim.Humanoid.WalkSpeed then
lookvector = -reanim.Humanoid.WalkSpeed
end
if rightvector > reanim.Humanoid.WalkSpeed then
rightvector = reanim.Humanoid.WalkSpeed
end
if rightvector < -reanim.Humanoid.WalkSpeed then
rightvector = -reanim.Humanoid.WalkSpeed
end
local lookvel = lookvector / reanim.Humanoid.WalkSpeed
local rightvel = rightvector / reanim.Humanoid.WalkSpeed
if Mode == '1' then
if Root.Velocity.y > 1 then -- jump
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/-0.1),1+0*math.cos(sine/-0.1),0+0*math.cos(sine/-0.1))*ANGLES(RAD(-17+1*math.cos(sine/-0.1)),RAD(0+-11*math.cos(sine/-0.1)),RAD(-2+0*math.cos(sine/-0.1))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/29),5+3*math.cos(sine/29),0+0*math.cos(sine/29))*ANGLES(RAD(21+0*math.cos(sine/29)),RAD(0+0*math.cos(sine/29)),RAD(0+0*math.cos(sine/29))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(125+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.6+0*math.cos(sine/27),0.5+0*math.cos(sine/27),0+0*math.cos(sine/27))*ANGLES(RAD(290+0*math.cos(sine/27)),RAD(0+0*math.cos(sine/27)),RAD(0+0*math.cos(sine/27))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/11),-1+0*math.cos(sine/11),0+0*math.cos(sine/11))*ANGLES(RAD(-40+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/11),-1+0*math.cos(sine/11),0+0*math.cos(sine/11))*ANGLES(RAD(-24+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11))),.3)
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/35),1+0*math.cos(sine/35),-1.6+0*math.cos(sine/35))*ANGLES(RAD(-360+0*math.cos(sine/35)),RAD(-360+224*math.cos(sine/35)),RAD(-278+0*math.cos(sine/35))),.3)
elseif Root.Velocity.y < -1 then -- fall
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/-0.1),1+0*math.cos(sine/-0.1),0+0*math.cos(sine/-0.1))*ANGLES(RAD(-17+1*math.cos(sine/-0.1)),RAD(0+-11*math.cos(sine/-0.1)),RAD(-2+0*math.cos(sine/-0.1))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/29),5+3*math.cos(sine/29),0+0*math.cos(sine/29))*ANGLES(RAD(21+0*math.cos(sine/29)),RAD(0+0*math.cos(sine/29)),RAD(0+0*math.cos(sine/29))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(125+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.6+0*math.cos(sine/27),0.5+0*math.cos(sine/27),0+0*math.cos(sine/27))*ANGLES(RAD(290+0*math.cos(sine/27)),RAD(0+0*math.cos(sine/27)),RAD(0+0*math.cos(sine/27))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/11),-1+0*math.cos(sine/11),0+0*math.cos(sine/11))*ANGLES(RAD(-40+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/11),-1+0*math.cos(sine/11),0+0*math.cos(sine/11))*ANGLES(RAD(-24+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11))),.3)
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/35),1+0*math.cos(sine/35),-1.6+0*math.cos(sine/35))*ANGLES(RAD(-360+0*math.cos(sine/35)),RAD(-360+224*math.cos(sine/35)),RAD(-278+0*math.cos(sine/35))),.3)
elseif Root.Velocity.Magnitude < 2 then -- idle
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/-0.1),1+0*math.cos(sine/-0.1),0+0*math.cos(sine/-0.1))*ANGLES(RAD(-17+7*math.cos(sine/-0.1)),RAD(0+-15*math.cos(sine/-0.1)),RAD(0+-3*math.cos(sine/-0.1))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/29),6+4*math.cos(sine/29),0+0*math.cos(sine/29))*ANGLES(RAD(81+0*math.cos(sine/29)),RAD(0+0*math.cos(sine/29)),RAD(0+0*math.cos(sine/29))),.3)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.7+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(224+0*math.cos(sine/13)),RAD(-8+1.5*math.cos(sine/13)),RAD(-35+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.7+0.1*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(224+0*math.cos(sine/13)),RAD(8+0*math.cos(sine/13)),RAD(35+0*math.cos(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/11),-1+0*math.cos(sine/11),0+0*math.cos(sine/11))*ANGLES(RAD(54+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11)),RAD(2+0*math.cos(sine/11))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/11),-1+0*math.cos(sine/11),0+0*math.cos(sine/11))*ANGLES(RAD(27+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11)),RAD(23+0*math.cos(sine/11))),.3)
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(2+0*math.cos(sine/67),11+0*math.cos(sine/67),0+0*math.cos(sine/67))*ANGLES(RAD(0+0*math.cos(sine/67)),RAD(0+0*math.cos(sine/67)),RAD(90+360*math.cos(sine/67))),.3)
elseif Root.Velocity.Magnitude < 200 then -- walk
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/-0.1),1+0*math.cos(sine/-0.1),0+0*math.cos(sine/-0.1))*ANGLES(RAD(-17+7*math.cos(sine/-0.1)),RAD(0+-15*math.cos(sine/-0.1)),RAD(0+-3*math.cos(sine/-0.1))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/29),6+4*math.cos(sine/29),0+0*math.cos(sine/29))*ANGLES(RAD(-6+0*math.cos(sine/29)),RAD(0+0*math.cos(sine/29)),RAD(0+0*math.cos(sine/29))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.4+0*math.cos(sine/27),0.7+0.1*math.cos(sine/27),0+0*math.cos(sine/27))*ANGLES(RAD(99+7*math.cos(sine/27)),RAD(7+0*math.cos(sine/27)),RAD(45+0*math.cos(sine/27))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/11),-1+0*math.cos(sine/11),0+0*math.cos(sine/11))*ANGLES(RAD(-19+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11)),RAD(2+0*math.cos(sine/11))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/11),-1+0*math.cos(sine/11),0+0*math.cos(sine/11))*ANGLES(RAD(-17+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11))),.3)
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(-0.5+0*math.cos(sine/67),-7+0*math.cos(sine/67),2.5+0*math.cos(sine/67))*ANGLES(RAD(67+0*math.cos(sine/67)),RAD(16+360*math.cos(sine/67)),RAD(0+0*math.cos(sine/67))),.3)
elseif Root.Velocity.Magnitude > 20 then -- run
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/-0.1),1+0*math.cos(sine/-0.1),0+0*math.cos(sine/-0.1))*ANGLES(RAD(-17+7*math.cos(sine/-0.1)),RAD(0+-15*math.cos(sine/-0.1)),RAD(0+-3*math.cos(sine/-0.1))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/29),6+4*math.cos(sine/29),0+0*math.cos(sine/29))*ANGLES(RAD(-6+0*math.cos(sine/29)),RAD(0+0*math.cos(sine/29)),RAD(0+0*math.cos(sine/29))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.4+0*math.cos(sine/27),0.7+0.1*math.cos(sine/27),0+0*math.cos(sine/27))*ANGLES(RAD(99+7*math.cos(sine/27)),RAD(7+0*math.cos(sine/27)),RAD(45+0*math.cos(sine/27))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/11),-1+0*math.cos(sine/11),0+0*math.cos(sine/11))*ANGLES(RAD(-19+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11)),RAD(2+0*math.cos(sine/11))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/11),-1+0*math.cos(sine/11),0+0*math.cos(sine/11))*ANGLES(RAD(-17+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11))),.3)
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(-0.5+0*math.cos(sine/67),-7+0*math.cos(sine/67),2.5+0*math.cos(sine/67))*ANGLES(RAD(67+0*math.cos(sine/67)),RAD(16+360*math.cos(sine/67)),RAD(0+0*math.cos(sine/67))),.3)
end


elseif Mode == '2' then
if Root.Velocity.y > 1 then -- jump

elseif Root.Velocity.y < -1 then -- fall

elseif Root.Velocity.Magnitude < 2 then -- idle

elseif Root.Velocity.Magnitude < 200 then -- walk

elseif Root.Velocity.Magnitude > 20 then -- run

end
elseif Mode == 'Attack0' then --attack clerp 


elseif Mode == 'Attack1' then --attack clerp 
hatset('Sniper','Right Arm',CFrame.new(),reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(-2+0*math.cos(sine/50),-0.2+0.1*math.cos(sine/50),0+0.2*math.cos(sine/50))*ANGLES(RAD(128+0*math.cos(sine/50)),RAD(0+0*math.cos(sine/50)),RAD(90+0*math.cos(sine/50))),1),false)
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/-0.1),1+0*math.cos(sine/-0.1),0+0*math.cos(sine/-0.1))*ANGLES(RAD(-17+7*math.cos(sine/-0.1)),RAD(0+-15*math.cos(sine/-0.1)),RAD(0+-3*math.cos(sine/-0.1))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/29),6+4*math.cos(sine/29),0+0*math.cos(sine/29))*ANGLES(RAD(-6+0*math.cos(sine/29)),RAD(0+0*math.cos(sine/29)),RAD(0+0*math.cos(sine/29))),.3)
RS.C0 = RS.C0:Lerp(CF(1.5+0*math.cos(sine/13),0.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(92+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-1.4+0*math.cos(sine/27),0.7+0.1*math.cos(sine/27),0+0*math.cos(sine/27))*ANGLES(RAD(99+7*math.cos(sine/27)),RAD(7+0*math.cos(sine/27)),RAD(45+0*math.cos(sine/27))),.3)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/11),-1+0*math.cos(sine/11),0+0*math.cos(sine/11))*ANGLES(RAD(0+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11)),RAD(-4+0*math.cos(sine/11))),.3)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/11),-1+0*math.cos(sine/11),0+0*math.cos(sine/11))*ANGLES(RAD(-19+0*math.cos(sine/11)),RAD(0+0*math.cos(sine/11)),RAD(-4+0*math.cos(sine/11))),.3)
reanim['Sniper'].Handle.AccessoryWeld.C0 = reanim['Sniper'].Handle.AccessoryWeld.C0:Lerp(CF(-2+0*math.cos(sine/50),-0.2+0.1*math.cos(sine/50),0+0.2*math.cos(sine/50))*ANGLES(RAD(128+0*math.cos(sine/50)),RAD(0+0*math.cos(sine/50)),RAD(90+0*math.cos(sine/50))),.3)
elseif Mode == 'Attack3' then --attack clerp 


end
srv.RenderStepped:Wait()
end
end)()
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe neptunain V (better fling) (free)",
	Callback = function()
loadstring(game:HttpGet(('https://raw.githubusercontent.com/Jason20902/NEPTUNIAN-V-FIX/main/NEP-V-FIX'),true))()
	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
local A = Main.Button({
	Text = "Fe sniper",
	Callback = function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/real/main/oldpdeath.lua"))()
local script = game:GetObjects("rbxassetid://5457832019")[1]

wait(0.2)
local shooting = false
Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = game:GetService("Players").LocalPlayer.Character["Reanimate"]
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Equipped = false


local mouseup = false
local plrs = game:GetService("Players")
local plr = plrs.LocalPlayer
local char = plr.Character
local hrp = char.HumanoidRootPart
local hrp2 = hrp:Clone()

hrp2.Parent = char
hrp.Name = "hi"
hrp.Transparency = 0
hrp.Anchored = false
if hrp:FindFirstChildOfClass("AlignPosition") then
hrp:FindFirstChildOfClass("AlignPosition"):Destroy()
end
if hrp:FindFirstChildOfClass("AlignOrientation") then
hrp:FindFirstChildOfClass("AlignOrientation"):Destroy()
end
local bp = Instance.new("BodyPosition", hrp)
bp.Position = hrp.Position
bp.D = 9999999
bp.P = 999999999999999
bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
flinger = Instance.new("BodyAngularVelocity",hrp)
flinger.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
flinger.P = 1000000000000000000000000000
flinger.AngularVelocity = Vector3.new(10000,10000,10000)

spawn(function()
while game:GetService("RunService").Heartbeat:Wait() do
if shooting == false then
bp.Position = game:GetService("Players").LocalPlayer.Character["Reanimate"].HumanoidRootPart.Position
end
end
end)

plr:GetMouse().Button1Down:Connect(function()
repeat wait() until shooting == true
repeat
game:GetService("RunService").Heartbeat:Wait()
if plr:GetMouse().Target ~= nil then
bp.Position = game:GetService("Players").LocalPlayer:GetMouse().Hit.p
end
until shooting == false
end)

coroutine.wrap(function()
while true do
wait()
if not Character or not Character:FindFirstChild("Humanoid") or Character:FindFirstChild("Humanoid").Health <= 0 then
HumanoidIsDead = true
break
end
end
end)()

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| USEFUL VALUES
--\\=================================//

Animation_Speed = 3
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local HOLD = false
local Rooted = false
local SINE = 0
local SIZE = 1
local UserInputService = game:GetService("UserInputService")
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true

function Swait(NUMBER)
if NUMBER == 0 or NUMBER == nil then
game:GetService("RunService").RenderStepped:wait()
else
for i = 1, NUMBER do
game:GetService("RunService").RenderStepped:wait()
end
end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
local trace = m00 + m11 + m22
if trace > 0 then
local s = math.sqrt(1 + trace)
local recip = 0.5 / s
return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
else
local i = 0
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then
i = 2
end
if i == 0 then
local s = math.sqrt(m00 - m11 - m22 + 1)
local recip = 0.5 / s
return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
elseif i == 1 then
local s = math.sqrt(m11 - m22 - m00 + 1)
local recip = 0.5 / s
return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
elseif i == 2 then
local s = math.sqrt(m22 - m00 - m11 + 1)
local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
end
end
end

function QuaternionToCFrame(px, py, pz, x, y, z, w)
local xs, ys, zs = x + x, y + y, z + z
local wx, wy, wz = w * xs, w * ys, w * zs
local xx = x * xs
local xy = x * ys
local xz = x * zs
local yy = y * ys
local yz = y * zs
local zz = z * zs
return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end

function QuaternionSlerp(a, b, t)
local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
local startInterp, finishInterp;
if cosTheta >= 0.0001 then
if (1 - cosTheta) > 0.0001 then
local theta = ACOS(cosTheta)
local invSinTheta = 1 / SIN(theta)
startInterp = SIN((1 - t) * theta) * invSinTheta
finishInterp = SIN(t * theta) * invSinTheta
else
startInterp = 1 - t
finishInterp = t
end
else
if (1 + cosTheta) > 0.0001 then
local theta = ACOS(-cosTheta)
local invSinTheta = 1 / SIN(theta)
startInterp = SIN((t - 1) * theta) * invSinTheta
finishInterp = SIN(t * theta) * invSinTheta
else
startInterp = t - 1
finishInterp = t
end
end
return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)}
local ax, ay, az = a.x, a.y, a.z
local bx, by, bz = b.x, b.y, b.z
local _t = 1 - t
return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

Character.Humanoid.WalkSpeed = 19

kan = Instance.new("Sound", Character)
kan.Volume = 10
kan.TimePosition = 0
kan.PlaybackSpeed = 1
kan.Pitch = 1
kan.SoundId = "rbxassetid://415898123"
kan.Name = "coolmusicyes"
kan.Looped = true
kan:Play()

function theme(ID, timepos, pitch, vol)
local kanz = kan
kanz.PlaybackSpeed = pitch
kanz.Pitch = pitch
kanz.SoundId = ID
kanz.Name = "wrecked"
kanz.Looped = true
end

--//=========================\\
--|| Cool Functions
--\\=========================//

function turnto(position)
RootPart.CFrame = CFrame.new(RootPart.CFrame.p, VT(position.X, RootPart.Position.Y, position.Z)) * CFrame.new(0, 0, 0)
end

function CreateSound(ID, PARENT, VOLUME, PITCH)
local NEWSOUND
coroutine.resume(coroutine.create(function()
NEWSOUND = SOUND:Clone()
NEWSOUND.Parent = PARENT
NEWSOUND.Volume = VOLUME
NEWSOUND.Pitch = PITCH
NEWSOUND.SoundId = "http://www.roblox.com/asset/?id=" .. ID
NEWSOUND:play()
repeat
Swait()
until NEWSOUND.Playing == false
NEWSOUND:remove()
end))
return NEWSOUND
end

function CreateWave2(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
local wave = CreatePart(3, Effects, "Neon", 0, 0.5, COLOR, "Effect", VT(0,0,0))
local mesh = Instance.NEWSOUND("SpecialMesh",wave)
mesh.MeshType = "FileMesh"
mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
mesh.Scale = SIZE
wave.CFrame = CFRAME
coroutine.resume(coroutine.create(function(PART)
for i = 1, WAIT do
Swait()
mesh.Scale = mesh.Scale + GROW
wave.Color = C3(0,0,0)
if DOESROT == true then
wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
end
wave.Transparency = wave.Transparency + (0.5/WAIT)
if wave.Transparency > 0.99 then
wave:remove()
end
end
end))
end

function ShootoBulleto()
ATTACK = true
Rooted = false
for i = 0, 0.8, 0.1 / Animation_Speed do
Swait()
turnto(Mouse.Hit.p)
RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
end
repeat
for i = 0, 0.6, 0.1 / Animation_Speed do
Swait()
turnto(Mouse.Hit.p)
RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
end
kan = Instance.new("Sound", Character)
kan.Volume = 10
kan.TimePosition = 0
kan.PlaybackSpeed = 1
kan.Pitch = 1
kan.SoundId = "rbxassetid://130767489"
kan.Name = "bang"
kan:Play()
for i = 0, 0.3, 0.1 / Animation_Speed do
Swait()
RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
end
until KEYHOLD == false
ATTACK = false
Rooted = false
end

function weld(parent,part0,part1,c0,c1)
local weld=Instance.new("Weld")
weld.Parent=parent
weld.Part0=part0
weld.Part1=part1
weld.C0=c0
weld.C1=c1
return weld
end

if Character.Sniper.Handle["AccessoryWeld"] then
Character.Sniper.Handle["AccessoryWeld"]:Remove()
end

local mlok = Character.Sniper

handle=mlok.Handle
handleweld=weld(handle,Character["Torso"],handle,CFrame.new(0, 0, 0),CFrame.new(-1, 0, -.8)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(-46)))
handleweld.Name = "muc"

function Equip()
Equipped = true

if mlok.Handle["muc"] then
mlok.Handle["muc"]:Remove()
end

local handle=mlok.Handle
handleweld=weld(mlok.Handle,Character["Right Arm"],handle,CFrame.new(0, 0, 0),CFrame.new(-2.2, -.81, 0)* CFrame.Angles(math.rad(90),math.rad(4),math.rad(95)))
handleweld.Name = "woah"
end


function DeEquip()
Equipped = false

if mlok.Handle["woah"] then
mlok.Handle["woah"]:Remove()
end

handle2=mlok.Handle
handleweld2=weld(handle2,Character["Torso"],handle2,CFrame.new(0, 0, 0),CFrame.new(-1, 0, -.8)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(-46)))
handleweld2.Name = "muc"
end

--//=================================\\
--|| ASSIGN THINGS TO KEYS
--\\=================================//

Mouse.Button1Down:connect(function()
if Equipped == true and ATTACK == false then
shooting = true
ShootoBulleto()
shooting = false
end
end)

Mouse.KeyDown:connect(function(k)
if k == "f" and ATTACK == false and Equipped == false then
Equip()
shooting = false
end
end)
Mouse.KeyDown:connect(function(k)
if k == "g" and ATTACK == false and Equipped == true then
DeEquip()
shooting = false
end
end)
--//=================================\\
--|| WRAP THE WHOLE SCRIPT UP
--\\=================================//

Humanoid.Changed:connect(function(Jump)
if Jump == "Jump" and (Disable_Jump == true) then
Humanoid.Jump = false
end
end)

local CONNECT = nil

while true do
Swait()
if Character:FindFirstChildOfClass("Humanoid") == nil then
Humanoid = IT("Humanoid",Character)
end
for _,v in next, Humanoid:GetPlayingAnimationTracks() do
v:Stop();
end

local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
SINE = SINE + CHANGE
if ANIM == "Walk" and Equipped == false and TORSOVELOCITY > 1 then
RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.2 * COS(SINE / (WALKSPEEDVALUE))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 100, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 25), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1 - 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1 + 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
elseif (ANIM ~= "Walk") and Equipped == false or (TORSOVELOCITY < 1) then
RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
elseif ANIM == "Walk" and Equipped == true and TORSOVELOCITY > 1 then
RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.2 * COS(SINE / (WALKSPEEDVALUE))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 100, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 25), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1 - 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1 + 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
elseif Equipped == true and (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
end
if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
ANIM = "Jump"
RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed) RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
elseif TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == true and HITFLOOR == nil then
ANIM = "Jump"
RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed) RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
ANIM = "Fall"
RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == true and HITFLOOR == nil then
ANIM = "Fall"
RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
ANIM = "Idle"
RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 00 + 0.2 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(30), RAD(0), RAD(0 + 25 * COS(SINE / 20))), 0.15 / Animation_Speed)
RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.6+ 0.1 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(-12), RAD(10 + 10 * COS(SINE / 10)))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6 + 0.1 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(-12), RAD(-10 + -10 * COS(SINE / 10))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
RightHip.C0 = Clerp(RightHip.C0, CF(1, -1- 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == true and HITFLOOR ~= nil then
ANIM = "Idle"
RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 00 + 0.2 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(30), RAD(0), RAD(0 + 25 * COS(SINE / 20))), 0.15 / Animation_Speed)
RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.4+ 0.2 * SIN(SINE / 12), 0) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4 + 0.2 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 15 * COS(SINE / 12))) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
RightHip.C0 = Clerp(RightHip.C0, CF(1, -1- 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
elseif TORSOVELOCITY > 1 and Equipped == false and HITFLOOR ~= nil then
ANIM = "Walk"
RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0.03) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5))* RIGHTSHOULDERC0, 0.25 / Animation_Speed)
LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
elseif TORSOVELOCITY > 1 and Equipped == true and HITFLOOR ~= nil then
ANIM = "Walk"
RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.03) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
end
end
unanchor()

	end,
	Menu = {
		Information = function(self)
			X.Banner({
				Text = "Click F to idk"
			})
		end
	}
})
end)

UniversalScriptHubs:NewButton("ConvertWare", "Execute the ConvertWare", function()
loadstring(game:HttpGet('https://raw.githubusercontent.com/specowos/CONVERTWARE/main/UI/main.lua',true))()
end)

-- Universal Scripts --
Scripts:NewButton("Universal ESP", "Execute the Universal ESP", function()
assert(Drawing, 'exploit not supported')

if not syn and not PROTOSMASHER_LOADED then print'Unnamed ESP only officially supports Synapse and Protosmasher! If you\'re an exploit developer and have added drawing API to your exploit, try setting syn as true then checking if that works, otherwise, DM me on discord @ cppbook.org#1968 or add an issue to the Unnamed ESP Github Repository and I\'ll see it through email!' end

if not cloneref then cloneref = function(o) return o end end

local UserInputService = cloneref(game:GetService'UserInputService')
local HttpService = cloneref(game:GetService'HttpService')
local TweenService = cloneref(game:GetService'TweenService')
local RunService = cloneref(game:GetService'RunService')
local Players = game:GetService'Players'
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()
local V2New = Vector2.new
local V3New = Vector3.new
local WTVP = Camera.WorldToViewportPoint
local WorldToViewport = function(...) return WTVP(Camera, ...) end
local Menu = {}
local MouseHeld = false
local LastRefresh = 0
local OptionsFile = 'IC3_ESP_SETTINGS.dat'
local Binding = false
local BindedKey = nil
local OIndex = 0
local LineBox = {}
local UIButtons = {}
local Sliders = {}
local ColorPicker = { Loading = false, LastGenerated = 0 }
local Dragging = false
local DraggingUI = false
local Rainbow = false
local DragOffset = V2New()
local DraggingWhat = nil
local OldData = {}
local IgnoreList = {}
local EnemyColor = Color3.new(1, 0, 0)
local TeamColor = Color3.new(0, 1, 0)
local MenuLoaded = false
local ErrorLogging = false
local TracerPosition = V2New(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y - 135)
local DragTracerPosition = false
local SubMenu = {}
local IsSynapse = syn and not PROTOSMASHER_LOADED
local Connections = { Active = {} }
local Signal = {} Signal.__index = Signal
local GetCharacter, CurrentColorPicker, Spectating

local QUAD_SUPPORTED_EXPLOIT = pcall(function() Drawing.new('Quad'):Remove() end)

shared.MenuDrawingData = shared.MenuDrawingData or { Instances = {} }
shared.InstanceData = shared.InstanceData or {}
shared.RSName = shared.RSName or ('UnnamedESP_by_ic3-' .. HttpService:GenerateGUID(false))

local GetDataName = shared.RSName .. '-GetData'
local UpdateName = shared.RSName .. '-Update'

local Debounce = setmetatable({}, {
	__index = function(t, i)
		return rawget(t, i) or false
	end
})

if shared.UESP_InputChangedCon then shared.UESP_InputChangedCon:Disconnect() end
if shared.UESP_InputBeganCon then shared.UESP_InputBeganCon:Disconnect() end
if shared.UESP_InputEndedCon then shared.UESP_InputEndedCon:Disconnect() end
if shared.CurrentColorPicker then shared.CurrentColorPicker:Dispose() end

local function IsStringEmpty(String)
	if type(String) == 'string' then
		return String:match'^%s+$' ~= nil or #String == 0 or String == '' or false;
	end
	
	return false;
end

local function Set(t, i, v) t[i] = v end

local Teams = {};
local CustomTeams = { -- Games that don't use roblox's team system
	[2563455047] = {
		Initialize = function()
			Teams.Sheriffs = {}; -- prevent big error
			Teams.Bandits = {}; -- prevent big error
			local Func = game:GetService'ReplicatedStorage':WaitForChild('RogueFunc', 1);
			local Event = game:GetService'ReplicatedStorage':WaitForChild('RogueEvent', 1);
			local S, B = Func:InvokeServer'AllTeamData';

			Teams.Sheriffs = S;
			Teams.Bandits = B;

			Event.OnClientEvent:Connect(function(id, PlayerName, Team, Remove) -- stolen straight from decompiled src lul
				if id == 'UpdateTeam' then
					local TeamTable, NotTeamTable
					if Team == 'Bandits' then
						TeamTable = TDM.Bandits
						NotTeamTable = TDM.Sheriffs
					else
						TeamTable = TDM.Sheriffs
						NotTeamTable = TDM.Bandits
					end
					if Remove then
						TeamTable[PlayerName] = nil
					else
						TeamTable[PlayerName] = true
						NotTeamTable[PlayerName] = nil
					end
					if PlayerName == LocalPlayer.Name then
						TDM.Friendlys = TeamTable
						TDM.Enemies = NotTeamTable
					end
				end
			end)
		end;
		CheckTeam = function(Player)
			local LocalTeam = Teams.Sheriffs[LocalPlayer.Name] and Teams.Sheriffs or Teams.Bandits;
			
			return LocalTeam[Player.Name] and true or false;
		end;
	};
	[5208655184] = {
		CheckTeam = function(Player)
			local LocalLastName = LocalPlayer:GetAttribute'LastName' if not LocalLastName or IsStringEmpty(LocalLastName) then return true end
			local PlayerLastName = Player:GetAttribute'LastName' if not PlayerLastName then return false end

			return PlayerLastName == LocalLastName
		end
	};
	[3541987450] = {
		CheckTeam = function(Player)
			local LocalStats = LocalPlayer:FindFirstChild'leaderstats';
			local LocalLastName = LocalStats and LocalStats:FindFirstChild'LastName'; if not LocalLastName or IsStringEmpty(LocalLastName.Value) then return true; end
			local PlayerStats = Player:FindFirstChild'leaderstats';
			local PlayerLastName = PlayerStats and PlayerStats:FindFirstChild'LastName'; if not PlayerLastName then return false; end

			return PlayerLastName.Value == LocalLastName.Value;
		end;
	};
    [6032399813] = {
		CheckTeam = function(Player)
			local LocalStats = LocalPlayer:FindFirstChild'leaderstats';
			local LocalGuildName = LocalStats and LocalStats:FindFirstChild'Guild'; if not LocalGuildName or IsStringEmpty(LocalGuildName.Value) then return true; end
			local PlayerStats = Player:FindFirstChild'leaderstats';
			local PlayerGuildName = PlayerStats and PlayerStats:FindFirstChild'Guild'; if not PlayerGuildName then return false; end

			return PlayerGuildName.Value == LocalGuildName.Value;
		end;
	};
    [5735553160] = {
		CheckTeam = function(Player)
			local LocalStats = LocalPlayer:FindFirstChild'leaderstats';
			local LocalGuildName = LocalStats and LocalStats:FindFirstChild'Guild'; if not LocalGuildName or IsStringEmpty(LocalGuildName.Value) then return true; end
			local PlayerStats = Player:FindFirstChild'leaderstats';
			local PlayerGuildName = PlayerStats and PlayerStats:FindFirstChild'Guild'; if not PlayerGuildName then return false; end

			return PlayerGuildName.Value == LocalGuildName.Value;
		end;
	};
};

local RenderList = {Instances = {}};

function RenderList:AddOrUpdateInstance(Instance, Obj2Draw, Text, Color)
	RenderList.Instances[Instance] = { ParentInstance = Instance; Instance = Obj2Draw; Text = Text; Color = Color };
	return RenderList.Instances[Instance];
end

local CustomPlayerTag;
local CustomESP;
local CustomCharacter;
local GetHealth;
local GetAliveState;
local CustomRootPartName;

local Modules = {
	[292439477] = {
		CustomESP = function()
			if type(shared.PF_Replication) ~= 'table' then
				local lastScan = shared.pfReplicationScan

				if (tick() - (lastScan or 0)) > 0.01 then
					shared.pfReplicationScan = tick()

					local gc = getgc(true)
					for i = 1, #gc do
						local gcObject = gc[i];
						if type(gcObject) == 'table' and type(rawget(gcObject, 'getbodyparts')) == 'function' then
							shared.PF_Replication = gcObject;
							break
						end
					end
				end

				return
			end

			for Index, Player in pairs(Players:GetPlayers()) do
				if Player == LocalPlayer then continue end

				local Body = shared.PF_Replication.getbodyparts(Player);

				if type(Body) == 'table' and typeof(rawget(Body, 'torso')) == 'Instance' then
					Player.Character = Body.torso.Parent
					continue
				end

				Player.Character = nil;
			end
		end,

		GetHealth = function(Player)
			if type(shared.pfHud) ~= 'table' then
				return false
			end

			return shared.pfHud:getplayerhealth(Player)
		end,

		GetAliveState = function(Player)
			if type(shared.pfHud) ~= 'table' then
				local lastScan = shared.pfHudScan

				if (tick() - (lastScan or 0)) > 0.1 then
					shared.pfHudScan = tick()

					local gc = getgc(true)
					for i = 1, #gc do
						local gcObject = gc[i];
						if type(gcObject) == 'table' and type(rawget(gcObject, 'getplayerhealth')) == 'function' then
							shared.pfHud = gcObject;
							break
						end
					end
				end

				return
			end

			return shared.pfHud:isplayeralive(Player)
		end,

		CustomRootPartName = 'Torso',
	};
	[2950983942] = {
		CustomCharacter = function(Player)
			if workspace:FindFirstChild'Players' then
				return workspace.Players:FindFirstChild(Player.Name);
			end
		end
	};
	[2262441883] = {
		CustomPlayerTag = function(Player)
			return Player:FindFirstChild'Job' and (' [' .. Player.Job.Value .. ']') or '';
		end;
		CustomESP = function()
			if workspace:FindFirstChild'MoneyPrinters' then
				for i, v in pairs(workspace.MoneyPrinters:GetChildren()) do
					local Main	= v:FindFirstChild'Main';
					local Owner	= v:FindFirstChild'TrueOwner';
					local Money	= v:FindFirstChild'Int' and v.Int:FindFirstChild'Money' or nil;
					if Main and Owner and Money then
						local O = tostring(Owner.Value);
						local M = tostring(Money.Value);

						pcall(RenderList.AddOrUpdateInstance, RenderList, v, Main, string.format('Money Printer\nOwned by %s\n[%s]', O, M), Color3.fromRGB(13, 255, 227));
					end
				end
			end
		end;
	};
	-- [4581966615] = {
	-- 	CustomESP = function()
	-- 		if workspace:FindFirstChild'Entities' then
	-- 			for i, v in pairs(workspace.Entities:GetChildren()) do
	-- 				if not v.Name:match'Printer' then continue end

	-- 				local Properties = v:FindFirstChild'Properties' if not Properties then continue end
	-- 				local Main	= v:FindFirstChild'hitbox';
	-- 				local Owner	= Properties:FindFirstChild'Owner';
	-- 				local Money	= Properties:FindFirstChild'CurrentPrinted'
					
	-- 				if Main and Owner and Money then
	-- 					local O = Owner.Value and tostring(Owner.Value) or 'no one';
	-- 					local M = tostring(Money.Value);

	-- 					pcall(RenderList.AddOrUpdateInstance, RenderList, v, Main, string.format('Money Printer\nOwned by %s\n[%s]', O, M), Color3.fromRGB(13, 255, 227));
	-- 				end
	-- 			end
	-- 		end
	-- 	end;
	-- };
	[4801598506] = {
		CustomESP = function()
			if workspace:FindFirstChild'Mobs' and workspace.Mobs:FindFirstChild'Forest1' then
				for i, v in pairs(workspace.Mobs.Forest1:GetChildren()) do
					local Main	= v:FindFirstChild'Head';
					local Hum	= v:FindFirstChild'Mob';

					if Main and Hum then
						pcall(RenderList.AddOrUpdateInstance, RenderList, v, Main, string.format('[%s] [%s/%s]', v.Name, Hum.Health, Hum.MaxHealth), Color3.fromRGB(13, 255, 227));
					end
				end
			end
		end;
	};
	[2555873122] = {
		CustomESP = function()
			if workspace:FindFirstChild'WoodPlanks' then
				for i, v in pairs(workspace:GetChildren()) do
					if v.Name == 'WoodPlanks' then
						local Main = v:FindFirstChild'Wood';

						if Main then
							pcall(RenderList.AddOrUpdateInstance, RenderList, v, Main, 'Wood Planks', Color3.fromRGB(13, 255, 227));
						end
					end
				end
			end
		end;
	};
	[5208655184] = {
		CustomESP = function()
			-- if workspace:FindFirstChild'Live' then
			-- 	for i, v in pairs(workspace.Live:GetChildren()) do
			-- 		if v.Name:sub(1, 1) == '.' then
			-- 			local Main = v:FindFirstChild'Head';

			-- 			if Main then
			-- 				pcall(RenderList.AddOrUpdateInstance, RenderList, v, Main, v.Name:sub(2), Color3.fromRGB(250, 50, 40));
			-- 			end
			-- 		end
			-- 	end
			-- end
		end;
		CustomPlayerTag = function(Player)
			if game.PlaceVersion < 457 then return '' end

			local Name = '';
			local FirstName = Player:GetAttribute'FirstName'

			if typeof(FirstName) == 'string' and #FirstName > 0 then
				local Prefix = '';
				local Extra = {};
				Name = Name .. '\n[';

				if Player:GetAttribute'Prestige' > 0 then
					Name = Name .. '#' .. tostring(Player:GetAttribute'Prestige') .. ' ';
				end
				if not IsStringEmpty(Player:GetAttribute'HouseRank') then
					Prefix = Player:GetAttribute'HouseRank' == 'Owner' and (Player:GetAttribute'Gender' == 'Female' and 'Lady ' or 'Lord ') or '';
				end
				if not IsStringEmpty(FirstName) then
					Name = Name .. '' .. Prefix .. FirstName;
				end
				if not IsStringEmpty(Player:GetAttribute'LastName') then
					Name = Name .. ' ' .. Player:GetAttribute'LastName';
				end

				if not IsStringEmpty(Name) then Name = Name .. ']'; end

				local Character = GetCharacter(Player);

				if Character then
					if Character and Character:FindFirstChild'Danger' then table.insert(Extra, 'D'); end
					if Character:FindFirstChild'ManaAbilities' and Character.ManaAbilities:FindFirstChild'ManaSprint' then table.insert(Extra, 'D1'); end

					if Character:FindFirstChild'Mana'	 		then table.insert(Extra, 'M' .. math.floor(Character.Mana.Value)); end
					if Character:FindFirstChild'Vampirism' 		then table.insert(Extra, 'V'); end
					if Character:FindFirstChild'Observe'		then table.insert(Extra, 'ILL'); end
					if Character:FindFirstChild'Inferi'			then table.insert(Extra, 'NEC'); end
					if Character:FindFirstChild'World\'s Pulse' then table.insert(Extra, 'DZIN'); end
					if Character:FindFirstChild'Shift'		 	then table.insert(Extra, 'MAD'); end
					if Character:FindFirstChild'Head' and Character.Head:FindFirstChild'FacialMarking' then
						local FM = Character.Head:FindFirstChild'FacialMarking';
						if FM.Texture == 'http://www.roblox.com/asset/?id=4072968006' then
							table.insert(Extra, 'HEALER');
						elseif FM.Texture == 'http://www.roblox.com/asset/?id=4072914434' then
							table.insert(Extra, 'SEER');
						elseif FM.Texture == 'http://www.roblox.com/asset/?id=4094417635' then
							table.insert(Extra, 'JESTER');
						elseif FM.Texture == 'http://www.roblox.com/asset/?id=4072968656' then
							table.insert(Extra, 'BLADE');
						end
					end
				end
				if Player:FindFirstChild'Backpack' then
					if Player.Backpack:FindFirstChild'Observe' 			then table.insert(Extra, 'ILL');  end
					if Player.Backpack:FindFirstChild'Inferi'			then table.insert(Extra, 'NEC');  end
					if Player.Backpack:FindFirstChild'World\'s Pulse' 	then table.insert(Extra, 'DZIN'); end
					if Player.Backpack:FindFirstChild'Shift'		 	then table.insert(Extra, 'MAD'); end
				end

				if #Extra > 0 then Name = Name .. ' [' .. table.concat(Extra, '-') .. ']'; end
			end

			return Name;
		end;
	};
	[3541987450] = {
		CustomPlayerTag = function(Player)
			local Name = '';

			if Player:FindFirstChild'leaderstats' then
				Name = Name .. '\n[';
				local Prefix = '';
				local Extra = {};
				if Player.leaderstats:FindFirstChild'Prestige' and Player.leaderstats.Prestige.ClassName == 'IntValue' and Player.leaderstats.Prestige.Value > 0 then
					Name = Name .. '#' .. tostring(Player.leaderstats.Prestige.Value) .. ' ';
				end
				if Player.leaderstats:FindFirstChild'HouseRank' and Player.leaderstats:FindFirstChild'Gender' and Player.leaderstats.HouseRank.ClassName == 'StringValue' and not IsStringEmpty(Player.leaderstats.HouseRank.Value) then
					Prefix = Player.leaderstats.HouseRank.Value == 'Owner' and (Player.leaderstats.Gender.Value == 'Female' and 'Lady ' or 'Lord ') or '';
				end
				if Player.leaderstats:FindFirstChild'FirstName' and Player.leaderstats.FirstName.ClassName == 'StringValue' and not IsStringEmpty(Player.leaderstats.FirstName.Value) then
					Name = Name .. '' .. Prefix .. Player.leaderstats.FirstName.Value;
				end
				if Player.leaderstats:FindFirstChild'LastName' and Player.leaderstats.LastName.ClassName == 'StringValue' and not IsStringEmpty(Player.leaderstats.LastName.Value) then
					Name = Name .. ' ' .. Player.leaderstats.LastName.Value;
				end
				if Player.leaderstats:FindFirstChild'UberTitle' and Player.leaderstats.UberTitle.ClassName == 'StringValue' and not IsStringEmpty(Player.leaderstats.UberTitle.Value) then
					Name = Name .. ', ' .. Player.leaderstats.UberTitle.Value;
				end

				if not IsStringEmpty(Name) then Name = Name .. ']'; end

				local Character = GetCharacter(Player);

				if Character then
					if Character and Character:FindFirstChild'Danger' then table.insert(Extra, 'D'); end
					if Character:FindFirstChild'ManaAbilities' and Character.ManaAbilities:FindFirstChild'ManaSprint' then table.insert(Extra, 'D1'); end

					if Character:FindFirstChild'Mana'	 		then table.insert(Extra, 'M' .. math.floor(Character.Mana.Value)); end
					if Character:FindFirstChild'Vampirism' 		then table.insert(Extra, 'V');    end
					if Character:FindFirstChild'Observe'			then table.insert(Extra, 'ILL');  end
					if Character:FindFirstChild'Inferi'			then table.insert(Extra, 'NEC');  end
					
					if Character:FindFirstChild'World\'s Pulse' 	then table.insert(Extra, 'DZIN'); end
					if Character:FindFirstChild'Head' and Character.Head:FindFirstChild'FacialMarking' then
						local FM = Character.Head:FindFirstChild'FacialMarking';
						if FM.Texture == 'http://www.roblox.com/asset/?id=4072968006' then
							table.insert(Extra, 'HEALER');
						elseif FM.Texture == 'http://www.roblox.com/asset/?id=4072914434' then
							table.insert(Extra, 'SEER');
						elseif FM.Texture == 'http://www.roblox.com/asset/?id=4094417635' then
							table.insert(Extra, 'JESTER');
						end
					end
				end
				if Player:FindFirstChild'Backpack' then
					if Player.Backpack:FindFirstChild'Observe' 			then table.insert(Extra, 'ILL');  end
					if Player.Backpack:FindFirstChild'Inferi'			then table.insert(Extra, 'NEC');  end
					if Player.Backpack:FindFirstChild'World\'s Pulse' 	then table.insert(Extra, 'DZIN'); end
				end

				if #Extra > 0 then Name = Name .. ' [' .. table.concat(Extra, '-') .. ']'; end
			end

			return Name;
		end;
	};

	[4691401390] = { -- Vast Realm
		CustomCharacter = function(Player)
			if workspace:FindFirstChild'Players' then
				return workspace.Players:FindFirstChild(Player.Name);
			end
		end
	};

    [6032399813] = { -- Deepwoken [Etrean]
		CustomPlayerTag = function(Player)
			local Name = '';
            CharacterName = Player:GetAttribute'CharacterName'; -- could use leaderstats but lazy

            if not IsStringEmpty(CharacterName) then
                Name = ('\n[%s]'):format(CharacterName);
                local Character = GetCharacter(Player);
                local Extra = {};

                if Character then
                    local Blood, Armor = Character:FindFirstChild('Blood'), Character:FindFirstChild('Armor');

                    if Blood and Blood.ClassName == 'DoubleConstrainedValue' then
                        table.insert(Extra, ('B%d'):format(Blood.Value));
                    end

                    if Armor and Armor.ClassName == 'DoubleConstrainedValue' then
                        table.insert(Extra, ('A%d'):format(math.floor(Armor.Value / 10)));
                    end
                end

                local BackpackChildren = Player.Backpack:GetChildren()

                for index = 1, #BackpackChildren do
                    local Oath = BackpackChildren[index]
                    if Oath.ClassName == 'Folder' and Oath.Name:find('Talent:Oath') then
                        local OathName = Oath.Name:gsub('Talent:Oath: ', '')
                        table.insert(Extra, OathName);
                    end
                end

                if #Extra > 0 then Name = Name .. ' [' .. table.concat(Extra, '-') .. ']'; end
            end

			return Name;
		end;
	};

    [5735553160] = { -- Deepwoken [Depths]
		CustomPlayerTag = function(Player)
			local Name = '';
			CharacterName = Player:GetAttribute'CharacterName'; -- could use leaderstats but lazy

			if not IsStringEmpty(CharacterName) then
				Name = ('\n[%s]'):format(CharacterName);
				local Character = GetCharacter(Player);
				local Extra = {};

				if Character then
					local Blood, Armor = Character:FindFirstChild('Blood'), Character:FindFirstChild('Armor');

					if Blood and Blood.ClassName == 'DoubleConstrainedValue' then
						table.insert(Extra, ('B%d'):format(Blood.Value));
					end

					if Armor and Armor.ClassName == 'DoubleConstrainedValue' then
						table.insert(Extra, ('A%d'):format(math.floor(Armor.Value / 10)));
					end
				end

				local BackpackChildren = Player.Backpack:GetChildren()

				for index = 1, #BackpackChildren do
					local Oath = BackpackChildren[index]
					if Oath.ClassName == 'Folder' and Oath.Name:find('Talent:Oath') then
						local OathName = Oath.Name:gsub('Talent:Oath: ', '')
						table.insert(Extra, OathName);
					end
				end

				if #Extra > 0 then Name = Name .. ' [' .. table.concat(Extra, '-') .. ']'; end
			end

			return Name;
		end;
	};

	[3127094264] = {
		CustomCharacter = function(Player)
			if not _FIRST then
				_FIRST = true
				
				pcall(function()
					local GPM = rawget(require(LocalPlayer.PlayerScripts:WaitForChild('Client', 1e9):WaitForChild('Player', 1e9)), 'GetPlayerModel')
					PList = debug.getupvalue(GPM, 1)
				end)
			end

			if PList then
				local Player = rawget(PList, Player.UserId)

				if Player and Player.model then
					return Player.model
				end
			end
		end
	}
};

if Modules[game.PlaceId] ~= nil or Modules[game.GameId] ~= nil then
	local Module = Modules[game.PlaceId] or Modules[game.GameId]
	CustomPlayerTag = Module.CustomPlayerTag or nil
	CustomESP = Module.CustomESP or nil
	CustomCharacter = Module.CustomCharacter or nil
	GetHealth = Module.GetHealth or nil
	GetAliveState = Module.GetAliveState or nil
	CustomRootPartName = Module.CustomRootPartName or nil
end

function GetCharacter(Player)
	return Player.Character or (CustomCharacter and CustomCharacter(Player));
end

function GetMouseLocation()
	return UserInputService:GetMouseLocation();
end

function MouseHoveringOver(Values)
	local X1, Y1, X2, Y2 = Values[1], Values[2], Values[3], Values[4]
	local MLocation = GetMouseLocation();
	return (MLocation.x >= X1 and MLocation.x <= (X1 + (X2 - X1))) and (MLocation.y >= Y1 and MLocation.y <= (Y1 + (Y2 - Y1)));
end

function GetTableData(t) -- basically table.foreach i dont even know why i made this
	if typeof(t) ~= 'table' then return end

	return setmetatable(t, {
		__call = function(t, func)
			if typeof(func) ~= 'function' then return end;
			for i, v in pairs(t) do
				pcall(func, i, v);
			end
		end;
	});
end
local function Format(format, ...)
	return string.format(format, ...);
end
function CalculateValue(Min, Max, Percent)
	return Min + math.floor(((Max - Min) * Percent) + .5);
end

function NewDrawing(InstanceName)
	local Instance = Drawing.new(InstanceName)

	return (function(Properties)
		for i, v in pairs(Properties) do
			pcall(Set, Instance, i, v)
		end

		return Instance
	end)
end

function Menu:AddMenuInstance(Name, DrawingType, Properties)
	local Instance;

	if shared.MenuDrawingData.Instances[Name] ~= nil then
		Instance = shared.MenuDrawingData.Instances[Name];
		for i, v in pairs(Properties) do
			pcall(Set, Instance, i, v);
		end
	else
		Instance = NewDrawing(DrawingType)(Properties);
	end

	shared.MenuDrawingData.Instances[Name] = Instance;

	return Instance;
end
function Menu:UpdateMenuInstance(Name)
	local Instance = shared.MenuDrawingData.Instances[Name];
	if Instance ~= nil then
		return (function(Properties)
			for i, v in pairs(Properties) do
				pcall(Set, Instance, i, v);
			end
			return Instance;
		end)
	end
end
function Menu:GetInstance(Name)
	return shared.MenuDrawingData.Instances[Name];
end

local Options = setmetatable({}, {
	__call = function(t, ...)
		local Arguments = {...};
		local Name = Arguments[1];
		OIndex = OIndex + 1;
		rawset(t, Name, setmetatable({
			Name			= Arguments[1];
			Text			= Arguments[2];
			Value			= Arguments[3];
			DefaultValue	= Arguments[3];
			AllArgs			= Arguments;
			Index			= OIndex;
		}, {
			__call = function(t, v, force)
				local self = t;

				if typeof(t.Value) == 'function' then
					t.Value();
				elseif typeof(t.Value) == 'EnumItem' then
					local BT = Menu:GetInstance(Format('%s_BindText', t.Name));
					if not force then
						Binding = true;
						local Val = 0
						while Binding do
							wait();
							Val = (Val + 1) % 17;
							BT.Text = Val <= 8 and '|' or '';
						end
					end
					t.Value = force and v or BindedKey;
					if BT and t.BasePosition and t.BaseSize then
						BT.Text = tostring(t.Value):match'%w+%.%w+%.(.+)';
						BT.Position = t.BasePosition + V2New(t.BaseSize.X - BT.TextBounds.X - 20, -10);
					end
				else
					local NewValue = v;
					if NewValue == nil then NewValue = not t.Value; end
					rawset(t, 'Value', NewValue);

					if Arguments[2] ~= nil and Menu:GetInstance'TopBar'.Visible then
						if typeof(Arguments[3]) == 'number' then
							local AMT = Menu:GetInstance(Format('%s_AmountText', t.Name));
							if AMT then
								AMT.Text = tostring(t.Value);
							end
						else
							local Inner = Menu:GetInstance(Format('%s_InnerCircle', t.Name));
							if Inner then Inner.Visible = t.Value; end
						end
					end
				end
			end;
		}));
	end;
})

function Load()
	local _, Result = pcall(readfile, OptionsFile);
	
	if _ then -- extremely ugly code yea i know but i dont care p.s. i hate pcall
		local _, Table = pcall(HttpService.JSONDecode, HttpService, Result);
		if _ and typeof(Table) == 'table' then
			for i, v in pairs(Table) do
				if typeof(Options[i]) == 'table' and Options[i].Value ~= nil and (typeof(Options[i].Value) == 'boolean' or typeof(Options[i].Value) == 'number') then
					Options[i].Value = v.Value;
					pcall(Options[i], v.Value);
				end
			end

			if Table.TeamColor then TeamColor = Color3.new(Table.TeamColor.R, Table.TeamColor.G, Table.TeamColor.B) end
			if Table.EnemyColor then EnemyColor = Color3.new(Table.EnemyColor.R, Table.EnemyColor.G, Table.EnemyColor.B) end

			if typeof(Table.MenuKey) == 'string' then Options.MenuKey(Enum.KeyCode[Table.MenuKey], true) end
			if typeof(Table.ToggleKey) == 'string' then Options.ToggleKey(Enum.KeyCode[Table.ToggleKey], true) end
		end
	end
end

Options('Enabled', 'ESP Enabled', true);
Options('ShowTeam', 'Show Team', true);
Options('ShowTeamColor', 'Show Team Color', false);
Options('ShowName', 'Show Names', true);
Options('ShowDistance', 'Show Distance', true);
Options('ShowHealth', 'Show Health', true);
Options('ShowBoxes', 'Show Boxes', true);
Options('ShowTracers', 'Show Tracers', true);
Options('ShowDot', 'Show Head Dot', false);
Options('VisCheck', 'Visibility Check', false);
Options('Crosshair', 'Crosshair', false);
Options('TextOutline', 'Text Outline', true);
-- Options('Rainbow', 'Rainbow Mode', false);
Options('TextSize', 'Text Size', syn and 18 or 14, 10, 24); -- cuz synapse fonts look weird???
Options('MaxDistance', 'Max Distance', 2500, 100, 25000);
Options('RefreshRate', 'Refresh Rate (ms)', 5, 1, 200);
Options('YOffset', 'Y Offset', 0, -200, 200);
Options('MenuKey', 'Menu Key', Enum.KeyCode.F4, 1);
Options('ToggleKey', 'Toggle Key', Enum.KeyCode.F3, 1);
Options('ChangeColors', SENTINEL_LOADED and 'Sentinel Unsupported' or 'Change Colors', function()
	if SENTINEL_LOADED then return end

	SubMenu:Show(GetMouseLocation(), 'Unnamed Colors', {
		{
			Type = 'Color'; Text = 'Team Color'; Color = TeamColor;

			Function = function(Circ, Position)
				if tick() - ColorPicker.LastGenerated < 1 then return; end

				if shared.CurrentColorPicker then shared.CurrentColorPicker:Dispose() end
				local ColorPicker = ColorPicker.new(Position - V2New(-10, 50));
				CurrentColorPicker = ColorPicker;
				shared.CurrentColorPicker = CurrentColorPicker;
				ColorPicker.ColorChanged:Connect(function(Color) Circ.Color = Color TeamColor = Color Options.TeamColor = Color end);
			end
		};
		{
			Type = 'Color'; Text = 'Enemy Color'; Color = EnemyColor;

			Function = function(Circ, Position)
				if tick() - ColorPicker.LastGenerated < 1 then return; end

				if shared.CurrentColorPicker then shared.CurrentColorPicker:Dispose() end
				local ColorPicker = ColorPicker.new(Position - V2New(-10, 50));
				CurrentColorPicker = ColorPicker;
				shared.CurrentColorPicker = CurrentColorPicker;
				ColorPicker.ColorChanged:Connect(function(Color) Circ.Color = Color EnemyColor = Color Options.EnemyColor = Color end);
			end
		};
		{
			Type = 'Button'; Text = 'Reset Colors';

			Function = function()
				EnemyColor = Color3.new(1, 0, 0);
				TeamColor = Color3.new(0, 1, 0);

				local C1 = Menu:GetInstance'Sub-ColorPreview.1'; if C1 then C1.Color = TeamColor end
				local C2 = Menu:GetInstance'Sub-ColorPreview.2'; if C2 then C2.Color = EnemyColor end
			end
		};
		{
			Type = 'Button'; Text = 'Rainbow Mode';

			Function = function()
				Rainbow = not Rainbow;
			end
		};
	});
end, 2);
Options('ResetSettings', 'Reset Settings', function()
	for i, v in pairs(Options) do
		if Options[i] ~= nil and Options[i].Value ~= nil and Options[i].Text ~= nil and (typeof(Options[i].Value) == 'boolean' or typeof(Options[i].Value) == 'number' or typeof(Options[i].Value) == 'EnumItem') then
			Options[i](Options[i].DefaultValue, true);
		end
	end
end, 5);
Options('LoadSettings', 'Load Settings', Load, 4);
Options('SaveSettings', 'Save Settings', function()
	local COptions = {};

	for i, v in pairs(Options) do
		COptions[i] = v;
	end
	
	if typeof(TeamColor) == 'Color3' then COptions.TeamColor = { R = TeamColor.R; G = TeamColor.G; B = TeamColor.B } end
	if typeof(EnemyColor) == 'Color3' then COptions.EnemyColor = { R = EnemyColor.R; G = EnemyColor.G; B = EnemyColor.B } end
	
	if typeof(COptions.MenuKey.Value) == 'EnumItem' then COptions.MenuKey = COptions.MenuKey.Value.Name end
	if typeof(COptions.ToggleKey.Value) == 'EnumItem' then COptions.ToggleKey = COptions.ToggleKey.Value.Name end

	writefile(OptionsFile, HttpService:JSONEncode(COptions));
end, 3);

Load(1);

Options('MenuOpen', nil, true);

local function Combine(...)
	local Output = {};
	for i, v in pairs{...} do
		if typeof(v) == 'table' then
			table.foreach(v, function(i, v)
				Output[i] = v;
			end)
		end
	end
	return Output
end

function LineBox:Create(Properties)
	local Box = { Visible = true }; -- prevent errors not really though dont worry bout the Visible = true thing

	local Properties = Combine({
		Transparency	= 1;
		Thickness		= 3;
		Visible			= true;
	}, Properties);

	if shared.am_ic3 then -- sory just my preference, dynamic boxes will be optional in unnamed esp v2
		Box['OutlineSquare']= NewDrawing'Square'(Properties);
		Box['Square'] 		= NewDrawing'Square'(Properties);
	elseif QUAD_SUPPORTED_EXPLOIT then
		Box['Quad']			= NewDrawing'Quad'(Properties);
	else
		Box['TopLeft']		= NewDrawing'Line'(Properties);
		Box['TopRight']		= NewDrawing'Line'(Properties);
		Box['BottomLeft']	= NewDrawing'Line'(Properties);
		Box['BottomRight']	= NewDrawing'Line'(Properties);
	end

	function Box:Update(CF, Size, Color, Properties, Parts)
		if not CF or not Size then return end

		if shared.am_ic3 and typeof(Parts) == 'table' then
			local AllCorners = {};
			
			for i, v in pairs(Parts) do
				-- if not v:IsA'BasePart' then continue end
				
				local CF, Size = v.CFrame, v.Size;
				-- CF, Size = v.Parent:GetBoundingBox();

				local Corners = {
					Vector3.new(CF.X + Size.X / 2, CF.Y + Size.Y / 2, CF.Z + Size.Z / 2);
					Vector3.new(CF.X - Size.X / 2, CF.Y + Size.Y / 2, CF.Z + Size.Z / 2);
					Vector3.new(CF.X - Size.X / 2, CF.Y - Size.Y / 2, CF.Z - Size.Z / 2);
					Vector3.new(CF.X + Size.X / 2, CF.Y - Size.Y / 2, CF.Z - Size.Z / 2);
					Vector3.new(CF.X - Size.X / 2, CF.Y + Size.Y / 2, CF.Z - Size.Z / 2);
					Vector3.new(CF.X + Size.X / 2, CF.Y + Size.Y / 2, CF.Z - Size.Z / 2);
					Vector3.new(CF.X - Size.X / 2, CF.Y - Size.Y / 2, CF.Z + Size.Z / 2);
					Vector3.new(CF.X + Size.X / 2, CF.Y - Size.Y / 2, CF.Z + Size.Z / 2);
				};

				for i, v in pairs(Corners) do
					table.insert(AllCorners, v);
				end

				-- break
			end

			local xMin, yMin = Camera.ViewportSize.X, Camera.ViewportSize.Y;
			local xMax, yMax = 0, 0;
			local Vs = true;

			for i, v in pairs(AllCorners) do				
				local Position, V = WorldToViewport(v);

				if VS and not V then Vs = false break end

				if Position.X > xMax then
					xMax = Position.X;
				end
				if Position.X < xMin then
					xMin = Position.X;
				end
				if Position.Y > yMax then
					yMax = Position.Y;
				end
				if Position.Y < yMin then
					yMin = Position.Y;
				end
			end

			local xSize, ySize = xMax - xMin, yMax - yMin;

			local Outline = Box['OutlineSquare'];
			local Square = Box['Square'];
			Outline.Visible = Vs;
			Square.Visible = Vs;
			Square.Position = V2New(xMin, yMin);
			Square.Color	= Color;
			Square.Thickness = math.floor(Outline.Thickness * 0.3);
			-- Square.Position = V2New(xMin, yMin);
			Square.Size = V2New(xSize, ySize);
			Outline.Position = Square.Position;
			Outline.Size = Square.Size;
			Outline.Color = Color3.new(0.12, 0.12, 0.12);
			Outline.Transparency = 0.75;

			return
		end
		
		local TLPos, Visible1	= WorldToViewport((CF * CFrame.new( Size.X,  Size.Y, 0)).Position);
		local TRPos, Visible2	= WorldToViewport((CF * CFrame.new(-Size.X,  Size.Y, 0)).Position);
		local BLPos, Visible3	= WorldToViewport((CF * CFrame.new( Size.X, -Size.Y, 0)).Position);
		local BRPos, Visible4	= WorldToViewport((CF * CFrame.new(-Size.X, -Size.Y, 0)).Position);

		local Quad = Box['Quad'];

		if QUAD_SUPPORTED_EXPLOIT then
			if Visible1 and Visible2 and Visible3 and Visible4 then
				Quad.Visible = true;
				Quad.Color	= Color;
				Quad.PointA = V2New(TLPos.X, TLPos.Y);
				Quad.PointB = V2New(TRPos.X, TRPos.Y);
				Quad.PointC = V2New(BRPos.X, BRPos.Y);
				Quad.PointD = V2New(BLPos.X, BLPos.Y);
			else
				Box['Quad'].Visible = false;
			end
		else
			Visible1 = TLPos.Z > 0 -- (commented | reason: random flashes);
			Visible2 = TRPos.Z > 0 -- (commented | reason: random flashes);
			Visible3 = BLPos.Z > 0 -- (commented | reason: random flashes);
			Visible4 = BRPos.Z > 0 -- (commented | reason: random flashes);

			-- ## BEGIN UGLY CODE
			if Visible1 then
				Box['TopLeft'].Visible		= true;
				Box['TopLeft'].Color		= Color;
				Box['TopLeft'].From			= V2New(TLPos.X, TLPos.Y);
				Box['TopLeft'].To			= V2New(TRPos.X, TRPos.Y);
			else
				Box['TopLeft'].Visible		= false;
			end
			if Visible2 then
				Box['TopRight'].Visible		= true;
				Box['TopRight'].Color		= Color;
				Box['TopRight'].From		= V2New(TRPos.X, TRPos.Y);
				Box['TopRight'].To			= V2New(BRPos.X, BRPos.Y);
			else
				Box['TopRight'].Visible		= false;
			end
			if Visible3 then
				Box['BottomLeft'].Visible	= true;
				Box['BottomLeft'].Color		= Color;
				Box['BottomLeft'].From		= V2New(BLPos.X, BLPos.Y);
				Box['BottomLeft'].To		= V2New(TLPos.X, TLPos.Y);
			else
				Box['BottomLeft'].Visible	= false;
			end
			if Visible4 then
				Box['BottomRight'].Visible	= true;
				Box['BottomRight'].Color	= Color;
				Box['BottomRight'].From		= V2New(BRPos.X, BRPos.Y);
				Box['BottomRight'].To		= V2New(BLPos.X, BLPos.Y);
			else
				Box['BottomRight'].Visible	= false;
			end
			if Properties and typeof(Properties) == 'table' then
				GetTableData(Properties)(function(i, v)
					pcall(Set, Box['TopLeft'],		i, v);
					pcall(Set, Box['TopRight'],		i, v);
					pcall(Set, Box['BottomLeft'],	i, v);
					pcall(Set, Box['BottomRight'],	i, v);
				end)
			end
			-- ## END UGLY CODE
		end
	end
	function Box:SetVisible(bool)
		if shared.am_ic3 then
			Box['Square'].Visible = bool;
			Box['OutlineSquare'].Visible = bool;
		elseif self.Quad then
			self.Quad.Visible = false
		elseif self.TopLeft and self.TopRight and self.BottomLeft and self.BottomRight then
			self.TopLeft.Visible = bool
			self.TopRight.Visible = bool
			self.BottomLeft.Visible = bool
			self.BottomRight.Visible = bool
		end
	end
	function Box:Remove()
		self:SetVisible(false)

		if shared.am_ic3 then
			Box['Square']:Remove()
			Box['OutlineSquare']:Remove()
		elseif self.Quad then
			Box['Quad']:Remove()
		elseif self.TopLeft and self.TopRight and self.BottomLeft and self.BottomRight then
			self.TopLeft:Remove()
			self.TopRight:Remove()
			self.BottomLeft:Remove()
			self.BottomRight:Remove()
		end
	end

	return Box;
end

local Colors = {
	White = Color3.fromHex'ffffff',
	Primary = {
		Main	= Color3.fromHex'424242',
		Light	= Color3.fromHex'6d6d6d',
		Dark	= Color3.fromHex'1b1b1b'
	},
	Secondary = {
		Main	= Color3.fromHex'e0e0e0',
		Light	= Color3.fromHex'ffffff',
		Dark	= Color3.fromHex'aeaeae'
	}
}

function Connections:Listen(Connection, Function)
    local NewConnection = Connection:Connect(Function);
    table.insert(self.Active, NewConnection);
    return NewConnection;
end

function Connections:DisconnectAll()
    for Index, Connection in pairs(self.Active) do
        if Connection.Connected then
            Connection:Disconnect();
        end
    end
    
    self.Active = {};
end

function Signal.new()
	local self = setmetatable({ _BindableEvent = Instance.new'BindableEvent' }, Signal);
    
	return self;
end

function Signal:Connect(Callback)
    assert(typeof(Callback) == 'function', 'function expected; got ' .. typeof(Callback));

	return self._BindableEvent.Event:Connect(function(...) Callback(...) end);
end

function Signal:Fire(...)
    self._BindableEvent:Fire(...);
end

function Signal:Wait()
    local Arguments = self._BindableEvent:Wait();

    return Arguments;
end

function Signal:Disconnect()
    if self._BindableEvent then
        self._BindableEvent:Destroy();
    end
end

local function GetMouseLocation()
	return UserInputService:GetMouseLocation();
end

local function IsMouseOverDrawing(Drawing, MousePosition)
	local TopLeft = Drawing.Position;
	local BottomRight = Drawing.Position + Drawing.Size;
    local MousePosition = MousePosition or GetMouseLocation();
    
    return MousePosition.X > TopLeft.X and MousePosition.Y > TopLeft.Y and MousePosition.X < BottomRight.X and MousePosition.Y < BottomRight.Y;
end

local ImageCache = {};

local function SetImage(Drawing, Url)
	local Data = IsSynapse and game:HttpGet(Url) or Url;

	Drawing[IsSynapse and 'Data' or 'Uri'] = ImageCache[Url] or Data;
	ImageCache[Url] = Data;
    
	if not IsSynapse then repeat wait() until Drawing.Loaded; end
end

-- oh god unnamed esp needs an entire rewrite, someone make a better one pls im too lazy
-- btw the color picker was made seperately so it doesnt fit with the code of unnamed esp

local function CreateDrawingsTable()
    local Drawings = { __Objects = {} };
    local Metatable = {};

    function Metatable.__index(self, Index)
        local Object = rawget(self.__Objects, Index);
        
        if not Object or (IsSynapse and not Object.__SELF.__OBJECT_EXISTS) then
            local Type = Index:sub(1, Index:find'-' - 1);

            Success, Object = pcall(Drawing.new, Type);

            if not Object or not Success then return function() end; end

            self.__Objects[Index] = setmetatable({ __SELF = Object; Type = Type }, {
                __call = function(self, Properties)
                    local Object = rawget(self, '__SELF'); if IsSynapse and not Object.__OBJECT_EXISTS then return false, 'render object destroyed'; end

                    if Properties == false then
                        Object.Visible = false;
                        Object.Transparency = 0;
                        Object:Remove();
                        
                        return true;
                    end
                    
                    if typeof(Properties) == 'table' then
                        for Property, Value in pairs(Properties) do
                            local CanSet = true;

                            if self.Type == 'Image' and not IsSynapse and Property == 'Size' and typeof(Value) == 'Vector2' then
                                CanSet = false;

                                spawn(function()
                                    repeat wait() until Object.Loaded;
                                    if not self.DefaultSize then rawset(self, 'DefaultSize', Object.Size) end

                                    Property = 'ScaleFactor';
                                    Value = Value.X / self.DefaultSize.X;

                                    Object[Property] = Value
                                end)
                            end
                            
                            if CanSet then Object[Property] = Value end
                        end
                    end

                    return Object;
                end
            });

            Object.Visible = true;
            Object.Transparency = 1; -- Transparency is really Opacity with drawing api (1 being visible, 0 being invisible)
            
            if Type == 'Text' then
                if Drawing.Fonts then Object.Font = Drawing.Fonts.Monospace end
                Object.Size = 20;
                Object.Color = Color3.new(1, 1, 1);
                Object.Center = true;
				Object.Outline = true;
				OutlineOpacity = 0.5;
            elseif Type == 'Square' or Type == 'Rectangle' then
                Object.Thickness = 2;
                Object.Filled = false;
            end

            return self.__Objects[Index];
        end

        return Object;
    end

    function Metatable.__call(self, Delete, ...)
        local Arguments = {Delete, ...};
        
        if Delete == false then
            for Index, Drawing in pairs(rawget(self, '__Objects')) do
                Drawing(false);
            end
        end
    end

    return setmetatable(Drawings, Metatable);
end

local Images = {}

spawn(function()
	Images.Ring = 'https://i.imgur.com/q4qx26f.png'
	Images.Overlay = 'https://i.imgur.com/gOCxbsR.png'
end)

function ColorPicker.new(Position, Size, Color)
	ColorPicker.LastGenerated = tick();
	ColorPicker.Loading = true;

    local self = { Color = Color or Color3.new(1, 1, 1); HSV = { H = 0, S = 1, V = 1 } };
    local Drawings = CreateDrawingsTable();
    local Position = Position or V2New();
    local Size = Size or 150;
    local Padding = { 10, 10, 10, 10 };
    
    self.ColorChanged = Signal.new();

    local Background = Drawings['Square-Background'] {
        Color = Color3.fromRGB(33, 33, 33);
		Filled = false;
		Visible = false;
        Position = Position - V2New(Padding[4], Padding[1]);
        Size = V2New(Size, Size) + V2New(Padding[4] + Padding[2], Padding[1] + Padding[3]);
    };
    local ColorPreview = Drawings['Circle-Preview'] {
        Position = Position + (V2New(Size, Size) / 2);
        Radius = Size / 2 - 8;
        Filled = true;
        Thickness = 0;
        NumSides = 20;
        Color = Color3.new(1, 0, 0);
    };
    local Main = Drawings['Image-Main'] {
        Position = Position;
        Size = V2New(Size, Size);
    }; SetImage(Main, Images.Ring);
    local Preview = Drawings['Square-Preview'] {
        Position = Main.Position + (Main.Size / 4.5);
        Size = Main.Size / 1.75;
        Color = Color3.new(1, 0, 0);
        Filled = true;
        Thickness = 0;
    };
    local Overlay = Drawings['Image-Overlay'] {
        Position = Preview.Position;
        Size = Preview.Size;
        Transparency = 1;
    }; SetImage(Overlay, Images.Overlay);
    local CursorOutline = Drawings['Circle-CursorOutline'] {
        Radius = 4;
        Thickness = 2;
        Filled = false;
        Color = Color3.new(0.2, 0.2, 0.2);
        Position = V2New(Main.Position.X + Main.Size.X - 10, Main.Position.Y + (Main.Size.Y / 2));
    };
    local Cursor = Drawings['Circle-Cursor'] {
        Radius = 3;
        Transparency = 1;
        Filled = true;
        Color = Color3.new(1, 1, 1);
        Position = CursorOutline.Position;
    };
    local CursorOutline = Drawings['Circle-CursorOutlineSquare'] {
        Radius = 4;
        Thickness = 2;
        Filled = false;
        Color = Color3.new(0.2, 0.2, 0.2);
        Position = V2New(Preview.Position.X + Preview.Size.X - 2, Preview.Position.Y + 2);
    };
    Drawings['Circle-CursorSquare'] {
        Radius = 3;
        Transparency = 1;
        Filled = true;
        Color = Color3.new(1, 1, 1);
        Position = CursorOutline.Position;
    };
    
    function self:UpdatePosition(Input)
        local MousePosition = V2New(Input.Position.X, Input.Position.Y + 33);

        if self.MouseHeld then
            if self.Item == 'Ring' then
                local Main = self.Drawings['Image-Main'] ();
                local Preview = self.Drawings['Square-Preview'] ();
                local Bounds = Main.Size / 2;
                local Center = Main.Position + Bounds;
                local Relative = MousePosition - Center;
                local Direction = Relative.unit;
                local Position = Center + Direction * Main.Size.X / 2.15;
                local H = (math.atan2(Position.Y - Center.Y, Position.X - Center.X)) * 60;
                if H < 0 then H = 360 + H; end
                H = H / 360;
                self.HSV.H = H;
                local EndColor = Color3.fromHSV(H, self.HSV.S, self.HSV.V); if EndColor ~= self.Color then self.ColorChanged:Fire(self.Color); end
                local Pointer = self.Drawings['Circle-Cursor'] { Position = Position };
                self.Drawings['Circle-CursorOutline'] { Position = Pointer.Position };
                Bounds = Bounds * 2;
                Preview.Color = Color3.fromHSV(H, 1, 1);
                self.Color = EndColor;
                self.Drawings['Circle-Preview'] { Color = EndColor };
            elseif self.Item == 'HL' then
                local Preview = self.Drawings['Square-Preview'] ();
                local HSV = self.HSV;
                local Position = V2New(math.clamp(MousePosition.X, Preview.Position.X, Preview.Position.X + Preview.Size.X), math.clamp(MousePosition.Y, Preview.Position.Y, Preview.Position.Y + Preview.Size.Y));
                HSV.S = (Position.X - Preview.Position.X) / Preview.Size.X;
                HSV.V = 1 - (Position.Y - Preview.Position.Y) / Preview.Size.Y;
                local EndColor = Color3.fromHSV(HSV.H, HSV.S, HSV.V); if EndColor ~= self.Color then self.ColorChanged:Fire(self.Color); end
                self.Color = EndColor;
                self.Drawings['Circle-Preview'] { Color = EndColor };
                local Pointer = self.Drawings['Circle-CursorSquare'] { Position = Position };
                self.Drawings['Circle-CursorOutlineSquare'] { Position = Pointer.Position };
            end
        end
    end

    function self:HandleInput(Input, P, Type)
        if Type == 'Began' then
            if Input.UserInputType.Name == 'MouseButton1' then
                local Main = self.Drawings['Image-Main'] ();
                local SquareSV = self.Drawings['Square-Preview'] ();
                local MousePosition = V2New(Input.Position.X, Input.Position.Y + 33);
                self.MouseHeld = true;
                local Bounds = Main.Size / 2;
                local Center = Main.Position + Bounds;
                local R = (MousePosition - Center);
        
                if R.Magnitude < Bounds.X and R.Magnitude > Bounds.X - 20 then
                    self.Item = 'Ring';
                end
                
                if MousePosition.X > SquareSV.Position.X and MousePosition.Y > SquareSV.Position.Y and MousePosition.X < SquareSV.Position.X + SquareSV.Size.X and MousePosition.Y < SquareSV.Position.Y + SquareSV.Size.Y then
                    self.Item = 'HL';
                end

                self:UpdatePosition(Input, P);
            end
        elseif Type == 'Changed' then
            if Input.UserInputType.Name == 'MouseMovement' then
                self:UpdatePosition(Input, P);
            end
        elseif Type == 'Ended' and Input.UserInputType.Name == 'MouseButton1' then
            self.Item = nil;
        end
	end
	
	function self:Dispose()
		self.Drawings(false);
		self.UpdatePosition = nil;
		self.HandleInput = nil;
		Connections:DisconnectAll(); -- scuffed tbh
	end

	Connections:Listen(UserInputService.InputBegan, function(Input, Process)
		self:HandleInput(Input, Process, 'Began');
	end);
	Connections:Listen(UserInputService.InputChanged, function(Input, Process)
		if Input.UserInputType.Name == 'MouseMovement' then
			local MousePosition = V2New(Input.Position.X, Input.Position.Y + 33);
			local Cursor = self.Drawings['Triangle-Cursor'] {
				Filled = true;
				Color = Color3.new(0.9, 0.9, 0.9);
				PointA = MousePosition + V2New(0, 0);
				PointB = MousePosition + V2New(12, 14);
				PointC = MousePosition + V2New(0, 18);
				Thickness = 0;
			};
		end
		self:HandleInput(Input, Process, 'Changed');
	end);
	Connections:Listen(UserInputService.InputEnded, function(Input, Process)
		self:HandleInput(Input, Process, 'Ended');
		
		if Input.UserInputType.Name == 'MouseButton1' then
			self.MouseHeld = false
		end
	end)

	ColorPicker.Loading = false

    self.Drawings = Drawings

    return self
end

function SubMenu:Show(Position, Title, Options)
	self.Open = true;

	local Visible = true;
	local BasePosition = Position;
	local BaseSize = V2New(200, 140);
	local End = BasePosition + BaseSize;

	self.Bounds = { BasePosition.X, BasePosition.Y, End.X, End.Y };

	delay(0.025, function()
		if not self.Open then return; end

		Menu:AddMenuInstance('Sub-Main', 'Square', {
			Size		= BaseSize;
			Position	= BasePosition;
			Filled		= false;
			Color		= Colors.Primary.Main;
			Thickness	= 3;
			Visible		= Visible;
		});
	end);
	Menu:AddMenuInstance('Sub-TopBar', 'Square', {
		Position	= BasePosition;
		Size		= V2New(BaseSize.X, 10);
		Color		= Colors.Primary.Dark;
		Filled		= true;
		Visible		= Visible;
	});
	Menu:AddMenuInstance('Sub-TopBarTwo', 'Square', {
		Position 	= BasePosition + V2New(0, 10);
		Size		= V2New(BaseSize.X, 20);
		Color		= Colors.Primary.Main;
		Filled		= true;
		Visible		= Visible;
	});
	Menu:AddMenuInstance('Sub-TopBarText', 'Text', {
		Size 		= 20;
		Position	= shared.MenuDrawingData.Instances['Sub-TopBarTwo'].Position + V2New(15, -3);
		Text		= Title or '';
		Color		= Colors.Secondary.Light;
		Visible		= Visible;
	});
	Menu:AddMenuInstance('Sub-Filling', 'Square', {
		Size		= BaseSize - V2New(0, 30);
		Position	= BasePosition + V2New(0, 30);
		Filled		= true;
		Color		= Colors.Secondary.Main;
		Transparency= .75;
		Visible		= Visible;
	});

	if Options then
		for Index, Option in pairs(Options) do -- currently only supports color and button(but color is a button so), planning on fully rewriting or something
			local function GetName(Name) return ('Sub-%s.%d'):format(Name, Index) end
			local Position = shared.MenuDrawingData.Instances['Sub-Filling'].Position + V2New(20, Index * 25 - 10);
			-- local BasePosition	= shared.MenuDrawingData.Instances.Filling.Position + V2New(30, v.Index * 25 - 10);

			if Option.Type == 'Color' then
				local ColorPreview = Menu:AddMenuInstance(GetName'ColorPreview', 'Circle', {
					Position = Position;
					Color = Option.Color;
					Radius = IsSynapse and 10 or 10;
					NumSides = 10;
					Filled = true;
					Visible = true;
				});
				local Text = Menu:AddMenuInstance(GetName'Text', 'Text', {
					Text = Option.Text;
					Position = ColorPreview.Position + V2New(15, -8);
					Size = 16;
					Color = Colors.Primary.Dark;
					Visible = true;
				});
				UIButtons[#UIButtons + 1] = {
					FromSubMenu = true;
					Option = function() return Option.Function(ColorPreview, BasePosition + V2New(BaseSize.X, 0)) end;
					Instance = Menu:AddMenuInstance(Format('%s_Hitbox', GetName'Button'), 'Square', {
						Position	= Position - V2New(20, 12);
						Size		= V2New(BaseSize.X, 25);
						Visible		= false;
					});
				};
			elseif Option.Type == 'Button' then
				UIButtons[#UIButtons + 1] = {
					FromSubMenu = true;
					Option = Option.Function;
					Instance = Menu:AddMenuInstance(Format('%s_Hitbox', GetName'Button'), 'Square', {
						Size		= V2New(BaseSize.X, 20) - V2New(20, 0);
						Visible		= true;
						Transparency= .5;
						Position	= Position - V2New(10, 10);
						Color		= Colors.Secondary.Light;
						Filled		= true;
					});
				};
				local Text		= Menu:AddMenuInstance(Format('%s_Text', GetName'Text'), 'Text', {
					Text		= Option.Text;
					Size		= 18;
					Position	= Position + V2New(5, -10);
					Visible		= true;
					Color		= Colors.Primary.Dark;
				});
			end
		end
	end
end

function SubMenu:Hide()
	self.Open = false;

	for i, v in pairs(shared.MenuDrawingData.Instances) do
		if i:sub(1, 3) == 'Sub' then
			v.Visible = false;

			if i:sub(4, 4) == ':' then -- ';' = Temporary so remove
				v:Remove();
				shared.MenuDrawingData.Instance[i] = nil;
			end
		end
	end

	for i, Button in pairs(UIButtons) do
		if Button.FromSubMenu then
			UIButtons[i] = nil;
		end
	end

	spawn(function() -- stupid bug happens if i dont use this
		for i = 1, 10 do
			if shared.CurrentColorPicker then -- dont know why 'CurrentColorPicker' isnt a variable in this
				shared.CurrentColorPicker:Dispose();
			end
			wait(0.1);
		end
	end)

	CurrentColorPicker = nil;
end

function CreateMenu(NewPosition) -- Create Menu
	MenuLoaded = false;
	UIButtons  = {};
	Sliders	   = {};

	local BaseSize = V2New(300, 625);
	local BasePosition = NewPosition or V2New(Camera.ViewportSize.X / 8 - (BaseSize.X / 2), Camera.ViewportSize.Y / 2 - (BaseSize.Y / 2));

	BasePosition = V2New(math.clamp(BasePosition.X, 0, Camera.ViewportSize.X), math.clamp(BasePosition.Y, 0, Camera.ViewportSize.Y));

	Menu:AddMenuInstance('CrosshairX', 'Line', {
		Visible			= false;
		Color			= Color3.new(0, 1, 0);
		Transparency	= 1;
		Thickness		= 1;
	});
	Menu:AddMenuInstance('CrosshairY', 'Line', {
		Visible			= false;
		Color			= Color3.new(0, 1, 0);
		Transparency	= 1;
		Thickness		= 1;
	});

	delay(.025, function() -- since zindex doesnt exist
		Menu:AddMenuInstance('Main', 'Square', {
			Size		= BaseSize;
			Position	= BasePosition;
			Filled		= false;
			Color		= Colors.Primary.Main;
			Thickness	= 3;
			Visible		= true;
		});
	end);
	Menu:AddMenuInstance('TopBar', 'Square', {
		Position	= BasePosition;
		Size		= V2New(BaseSize.X, 15);
		Color		= Colors.Primary.Dark;
		Filled		= true;
		Visible		= true;
	});
	Menu:AddMenuInstance('TopBarTwo', 'Square', {
		Position 	= BasePosition + V2New(0, 15);
		Size		= V2New(BaseSize.X, 45);
		Color		= Colors.Primary.Main;
		Filled		= true;
		Visible		= true;
	});
	Menu:AddMenuInstance('TopBarText', 'Text', {
		Size 		= 25;
		Position	= shared.MenuDrawingData.Instances.TopBarTwo.Position + V2New(25, 10);
		Text		= 'Unnamed ESP';
		Color		= Colors.Secondary.Light;
		Visible		= true;
		Transparency= 1; -- proto outline fix
		Outline 	= true;
		OutlineOpacity = 0.5;
	});
	Menu:AddMenuInstance('TopBarTextBR', 'Text', {
		Size 		= 18;
		Position	= shared.MenuDrawingData.Instances.TopBarTwo.Position + V2New(BaseSize.X - 75, 25);
		Text		= 'by ic3w0lf';
		Color		= Colors.Secondary.Light;
		Visible		= true;
		Transparency= 1;
		Outline 	= true;
		OutlineOpacity = 0.5;
	});
	Menu:AddMenuInstance('Filling', 'Square', {
		Size		= BaseSize - V2New(0, 60);
		Position	= BasePosition + V2New(0, 60);
		Filled		= true;
		Color		= Colors.Secondary.Main;
		Transparency= .35;
		Visible		= true;
	});

	local CPos = 0;

	GetTableData(Options)(function(i, v)
		if typeof(v.Value) == 'boolean' and not IsStringEmpty(v.Text) and v.Text ~= nil then
			CPos 				= CPos + 25;
			local BaseSize		= V2New(BaseSize.X, 30);
			local BasePosition	= shared.MenuDrawingData.Instances.Filling.Position + V2New(30, v.Index * 25 - 10);
			UIButtons[#UIButtons + 1] = {
				Option = v;
				Instance = Menu:AddMenuInstance(Format('%s_Hitbox', v.Name), 'Square', {
					Position	= BasePosition - V2New(30, 15);
					Size		= BaseSize;
					Visible		= false;
				});
			};
			Menu:AddMenuInstance(Format('%s_OuterCircle', v.Name), 'Circle', {
				Radius		= 10;
				Position	= BasePosition;
				Color		= Colors.Secondary.Light;
				Filled		= true;
				Visible		= true;
			});
			Menu:AddMenuInstance(Format('%s_InnerCircle', v.Name), 'Circle', {
				Radius		= 7;
				Position	= BasePosition;
				Color		= Colors.Secondary.Dark;
				Filled		= true;
				Visible		= v.Value;
			});
			Menu:AddMenuInstance(Format('%s_Text', v.Name), 'Text', {
				Text		= v.Text;
				Size		= 20;
				Position	= BasePosition + V2New(20, -10);
				Visible		= true;
				Color		= Colors.Secondary.Light;
				Transparency= 1;
				Outline		= true;
				OutlineOpacity = 0.5;
			});
		end
	end)
	GetTableData(Options)(function(i, v) -- just to make sure certain things are drawn before or after others, too lazy to actually sort table
		if typeof(v.Value) == 'number' then
			CPos 				= CPos + 25;

			local BaseSize		= V2New(BaseSize.X, 30);
			local BasePosition	= shared.MenuDrawingData.Instances.Filling.Position + V2New(0, CPos - 10);

			local Line			= Menu:AddMenuInstance(Format('%s_SliderLine', v.Name), 'Square', {
				Transparency	= 1;
				Color			= Colors.Secondary.Light;
				-- Thickness		= 3;
				Filled			= true;
				Visible			= true;
				Position 		= BasePosition + V2New(15, -5);
				Size 			= BaseSize - V2New(30, 10);
				Transparency	= 0.5;
			});
			local Slider		= Menu:AddMenuInstance(Format('%s_Slider', v.Name), 'Square', {
				Visible			= true;
				Filled			= true;
				Color			= Colors.Primary.Dark;
				Size			= V2New(5, Line.Size.Y);
				Transparency	= 0.5;
			});
			local Text			= Menu:AddMenuInstance(Format('%s_Text', v.Name), 'Text', {
				Text			= v.Text;
				Size			= 20;
				Center			= true;
				Transparency	= 1;
				Outline			= true;
				OutlineOpacity  = 0.5;
				Visible			= true;
				Color			= Colors.White;
			}); Text.Position	= Line.Position + (Line.Size / 2) - V2New(0, Text.TextBounds.Y / 1.75);
			local AMT			= Menu:AddMenuInstance(Format('%s_AmountText', v.Name), 'Text', {
				Text			= tostring(v.Value);
				Size			= 22;
				Center			= true;
				Transparency	= 1;
				Outline			= true;
				OutlineOpacity  = 0.5;
				Visible			= true;
				Color			= Colors.White;
				Position		= Text.Position;
			});

			local CSlider = {Slider = Slider; Line = Line; Min = v.AllArgs[4]; Max = v.AllArgs[5]; Option = v};
			local Dummy = Instance.new'NumberValue';

			Dummy:GetPropertyChangedSignal'Value':Connect(function()
				Text.Transparency = Dummy.Value;
				-- Text.OutlineTransparency = 1 - Dummy.Value;
				AMT.Transparency = 1 - Dummy.Value;
			end);

			Dummy.Value = 1;

			function CSlider:ShowValue(Bool)
				self.ShowingValue = Bool;

				TweenService:Create(Dummy, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), { Value = Bool and 0 or 1 }):Play();
			end

			Sliders[#Sliders + 1] = CSlider;

			-- local Percent = (v.Value / CSlider.Max) * 100;
			-- local Size = math.abs(Line.From.X - Line.To.X);
			-- local Value = Size * (Percent / 100); -- this shit's inaccurate but fuck it i'm not even gonna bother fixing it

			Slider.Position = Line.Position + V2New(35, 0);
			
			v.BaseSize = BaseSize;
			v.BasePosition = BasePosition;
			-- AMT.Position = BasePosition + V2New(BaseSize.X - AMT.TextBounds.X - 10, -10)
		end
	end)
	local FirstItem = false;
	GetTableData(Options)(function(i, v) -- just to make sure certain things are drawn before or after others, too lazy to actually sort table
		if typeof(v.Value) == 'EnumItem' then
			CPos 				= CPos + (not FirstItem and 30 or 25);
			FirstItem			= true;

			local BaseSize		= V2New(BaseSize.X, FirstItem and 30 or 25);
			local BasePosition	= shared.MenuDrawingData.Instances.Filling.Position + V2New(0, CPos - 10);

			UIButtons[#UIButtons + 1] = {
				Option = v;
				Instance = Menu:AddMenuInstance(Format('%s_Hitbox', v.Name), 'Square', {
					Size		= V2New(BaseSize.X, 20) - V2New(30, 0);
					Visible		= true;
					Transparency= .5;
					Position	= BasePosition + V2New(15, -10);
					Color		= Colors.Secondary.Light;
					Filled		= true;
				});
			};
			local Text		= Menu:AddMenuInstance(Format('%s_Text', v.Name), 'Text', {
				Text		= v.Text;
				Size		= 20;
				Position	= BasePosition + V2New(20, -10);
				Visible		= true;
				Color		= Colors.Secondary.Light;
				Transparency= 1;
				Outline		= true;
				OutlineOpacity = 0.5;
			});
			local BindText	= Menu:AddMenuInstance(Format('%s_BindText', v.Name), 'Text', {
				Text		= tostring(v.Value):match'%w+%.%w+%.(.+)';
				Size		= 20;
				Position	= BasePosition;
				Visible		= true;
				Color		= Colors.Secondary.Light;
				Transparency= 1;
				Outline		= true;
				OutlineOpacity = 0.5;
			});

			Options[i].BaseSize = BaseSize;
			Options[i].BasePosition = BasePosition;
			BindText.Position = BasePosition + V2New(BaseSize.X - BindText.TextBounds.X - 20, -10);
		end
	end)
	GetTableData(Options)(function(i, v) -- just to make sure certain things are drawn before or after others, too lazy to actually sort table
		if typeof(v.Value) == 'function' then
			local BaseSize		= V2New(BaseSize.X, 30);
			local BasePosition	= shared.MenuDrawingData.Instances.Filling.Position + V2New(0, CPos + (25 * v.AllArgs[4]) - 35);

			UIButtons[#UIButtons + 1] = {
				Option = v;
				Instance = Menu:AddMenuInstance(Format('%s_Hitbox', v.Name), 'Square', {
					Size		= V2New(BaseSize.X, 20) - V2New(30, 0);
					Visible		= true;
					Transparency= .5;
					Position	= BasePosition + V2New(15, -10);
					Color		= Colors.Secondary.Light;
					Filled		= true;
				});
			};
			local Text		= Menu:AddMenuInstance(Format('%s_Text', v.Name), 'Text', {
				Text		= v.Text;
				Size		= 20;
				Position	= BasePosition + V2New(20, -10);
				Visible		= true;
				Color		= Colors.Secondary.Light;
				Transparency= 1;
				Outline		= true;
				OutlineOpacity = 0.5;
			});

			-- BindText.Position = BasePosition + V2New(BaseSize.X - BindText.TextBounds.X - 10, -10);
		end
	end)

	delay(.1, function()
		MenuLoaded = true;
	end);

	-- this has to be at the bottom cuz proto drawing api doesnt have zindex :triumph:	
	Menu:AddMenuInstance('Cursor1', 'Line', {
		Visible			= false;
		Color			= Color3.new(1, 0, 0);
		Transparency	= 1;
		Thickness		= 2;
	});
	Menu:AddMenuInstance('Cursor2', 'Line', {
		Visible			= false;
		Color			= Color3.new(1, 0, 0);
		Transparency	= 1;
		Thickness		= 2;
	});
	Menu:AddMenuInstance('Cursor3', 'Line', {
		Visible			= false;
		Color			= Color3.new(1, 0, 0);
		Transparency	= 1;
		Thickness		= 2;
	});
end

CreateMenu();
delay(0.1, function()
	SubMenu:Show(V2New()); -- Create the submenu
	SubMenu:Hide();
end);

shared.UESP_InputChangedCon = UserInputService.InputChanged:Connect(function(input)
	if input.UserInputType.Name == 'MouseMovement' and Options.MenuOpen.Value then
		for i, v in pairs(Sliders) do
			local Values = {
				v.Line.Position.X;
				v.Line.Position.Y;
				v.Line.Position.X + v.Line.Size.X;
				v.Line.Position.Y + v.Line.Size.Y;
			};
			if MouseHoveringOver(Values) then
				v:ShowValue(true);
			else
				if not MouseHeld then v:ShowValue(false); end
			end
		end
	end
end)
shared.UESP_InputBeganCon = UserInputService.InputBegan:Connect(function(input)
	if input.UserInputType.Name == 'MouseButton1' and Options.MenuOpen.Value then
		MouseHeld = true;
		local Bar = Menu:GetInstance'TopBar';
		local Values = {
			Bar.Position.X;
			Bar.Position.Y;
			Bar.Position.X + Bar.Size.X;
			Bar.Position.Y + Bar.Size.Y;
		}
		if MouseHoveringOver(Values) then
			DraggingUI = true;
			DragOffset = Menu:GetInstance'Main'.Position - GetMouseLocation();
		else
			for i, v in pairs(Sliders) do
				local Values = {
					v.Line.Position.X;
					v.Line.Position.Y;
					v.Line.Position.X + v.Line.Size.X;
					v.Line.Position.Y + v.Line.Size.Y;
					-- v.Line.From.X	- (v.Slider.Radius);
					-- v.Line.From.Y	- (v.Slider.Radius);
					-- v.Line.To.X		+ (v.Slider.Radius);
					-- v.Line.To.Y		+ (v.Slider.Radius);
				};
				if MouseHoveringOver(Values) then
					DraggingWhat = v;
					Dragging = true;
					break
				end
			end

			if not Dragging then
				local Values = {
					TracerPosition.X - 10;
					TracerPosition.Y - 10;
					TracerPosition.X + 10;
					TracerPosition.Y + 10;
				};
				if MouseHoveringOver(Values) then
					DragTracerPosition = true;
				end
			end
		end
	end
end)
shared.UESP_InputEndedCon = UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType.Name == 'MouseButton1' and Options.MenuOpen.Value then
		MouseHeld = false;
		DragTracerPosition = false;
		local IgnoreOtherInput = false;

		if SubMenu.Open and not MouseHoveringOver(SubMenu.Bounds) then
			if CurrentColorPicker and IsMouseOverDrawing(CurrentColorPicker.Drawings['Square-Background']()) then IgnoreOtherInput = true; end
			if not IgnoreOtherInput then SubMenu:Hide() end
		end

		if not IgnoreOtherInput then
			for i, v in pairs(UIButtons) do
				if SubMenu.Open and MouseHoveringOver(SubMenu.Bounds) and not v.FromSubMenu then continue end

				local Values = {
					v.Instance.Position.X;
					v.Instance.Position.Y;
					v.Instance.Position.X + v.Instance.Size.X;
					v.Instance.Position.Y + v.Instance.Size.Y;
				};
				if MouseHoveringOver(Values) then
					v.Option();
					IgnoreOtherInput = true;
					break -- prevent clicking 2 options
				end
			end
			for i, v in pairs(Sliders) do
				if IgnoreOtherInput then break end

				local Values = {
					v.Line.Position.X;
					v.Line.Position.Y;
					v.Line.Position.X + v.Line.Size.X;
					v.Line.Position.Y + v.Line.Size.Y;
				};
				if not MouseHoveringOver(Values) then
					v:ShowValue(false);
				end
			end
		end
	elseif input.UserInputType.Name == 'MouseButton2' and Options.MenuOpen.Value and not DragTracerPosition then
		local Values = {
			TracerPosition.X - 10;
			TracerPosition.Y - 10;
			TracerPosition.X + 10;
			TracerPosition.Y + 10;
		}
		if MouseHoveringOver(Values) then
			DragTracerPosition = false;
			TracerPosition = V2New(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y - 135);
		end
	elseif input.UserInputType.Name == 'Keyboard' then
		if Binding then
			BindedKey = input.KeyCode;
			Binding = false;
		elseif input.KeyCode == Options.MenuKey.Value or (input.KeyCode == Enum.KeyCode.Home and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)) then
			Options.MenuOpen();
		elseif input.KeyCode == Options.ToggleKey.Value then
			Options.Enabled();
		elseif input.KeyCode.Name == 'F1' and UserInputService:IsMouseButtonPressed(1) and shared.am_ic3 then -- hehe hiden spectate feature cuz why not
			local HD, LPlayer, LCharacter = 0.95;

			for i, Player in pairs(Players:GetPlayers()) do
				local Character = GetCharacter(Player);

				if Player ~= LocalPlayer and Player ~= Spectating and Character and Character:FindFirstChild'HumanoidRootPart' then
					local Head = Character:FindFirstChild'Head';
					local Humanoid = Character:FindFirstChildOfClass'Humanoid';
					
					if Head then
						local Distance  = (Camera.CFrame.Position - Head.Position).Magnitude;
						
						if Distance > Options.MaxDistance.Value then continue; end

						local Direction = -(Camera.CFrame.Position - Mouse.Hit.Position).unit;
						local Relative  = Character.Head.Position - Camera.CFrame.Position;
						local Unit      = Relative.unit;

						local DP = Direction:Dot(Unit);

						if DP > HD then
							HD = DP;
							LPlayer = Player;
							LCharacter = Character;
						end
					end
				end
			end
			
			if LPlayer and LPlayer ~= Spectating and LCharacter then
				Camera.CameraSubject = LCharacter.Head;
				Spectating = LPlayer;
			else
				if LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass'Humanoid' then
					Camera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass'Humanoid';
					Spectating = nil;
				end
			end
		end
	end
end)

local function CameraCon() -- unnamed esp v1 sucks
	workspace.CurrentCamera:GetPropertyChangedSignal'ViewportSize':Connect(function()
		TracerPosition = V2New(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y - 135);
	end);
end

CameraCon();

local function ToggleMenu()
	if Options.MenuOpen.Value then
		GetTableData(shared.MenuDrawingData.Instances)(function(i, v)
			if OldData[v] then
				pcall(Set, v, 'Visible', true);
			end
		end)
	else
		GetTableData(shared.MenuDrawingData.Instances)(function(i, v)
			OldData[v] = v.Visible;
			if v.Visible then
				pcall(Set, v, 'Visible', false);
			end
		end)
	end
end

local LastRayIgnoreUpdate, RayIgnoreList = 0, {}

local function CheckRay(Instance, Distance, Position, Unit)
	local Pass = true;
	local Model = Instance;

	if Distance > 999 then return false; end

	if Instance.ClassName == 'Player' then
		Model = GetCharacter(Instance);
	end

	if not Model then
		Model = Instance.Parent;

		if Model.Parent == workspace then
			Model = Instance;
		end
	end

	if not Model then return false end

	local _Ray = Ray.new(Position, Unit * Distance)

	if tick() - LastRayIgnoreUpdate > 3 then
		LastRayIgnoreUpdate = tick()

		table.clear(RayIgnoreList)

		table.insert(RayIgnoreList, LocalPlayer.Character)
		table.insert(RayIgnoreList, Camera)
		
		if Mouse.TargetFilter then table.insert(RayIgnoreList, Mouse.TargetFilter) end

		if #IgnoreList > 64 then
			while #IgnoreList > 64 do
				table.remove(IgnoreList, 1)
			end
		end

		for i, v in pairs(IgnoreList) do table.insert(RayIgnoreList, v) end
	end

	local Hit = workspace:FindPartOnRayWithIgnoreList(_Ray, RayIgnoreList)

	if Hit and not Hit:IsDescendantOf(Model) then
		Pass = false;
		if Hit.Transparency >= .3 or not Hit.CanCollide and Hit.ClassName ~= Terrain then -- Detect invisible walls
			table.insert(IgnoreList, Hit)
			-- IgnoreList[#IgnoreList + 1] = Hit;
		end
	end

	return Pass;
end

local function CheckTeam(Player)
	if Player.Neutral and LocalPlayer.Neutral then return true; end
	return Player.TeamColor == LocalPlayer.TeamColor;
end

local CustomTeam = CustomTeams[game.PlaceId];

if CustomTeam ~= nil then
	if CustomTeam.Initialize then ypcall(CustomTeam.Initialize) end

	CheckTeam = CustomTeam.CheckTeam;
end

local function CheckPlayer(Player, Character)
	if not Options.Enabled.Value then return false end

	local Pass = true;
	local Distance = 0;

	if Player ~= LocalPlayer and Character then
		if not Options.ShowTeam.Value and CheckTeam(Player) then
			Pass = false;
		end

		local Head = Character:FindFirstChild'Head';

		if Pass and Character and Head then
			Distance = (Camera.CFrame.Position - Head.Position).Magnitude;
			if Options.VisCheck.Value then
				Pass = CheckRay(Player, Distance, Camera.CFrame.Position, (Head.Position - Camera.CFrame.Position).unit);
			end
			if Distance > Options.MaxDistance.Value then
				Pass = false;
			end
		end
	else
		Pass = false;
	end

	return Pass, Distance;
end

local function CheckDistance(Instance)
	if not Options.Enabled.Value then return false end

	local Pass = true;
	local Distance = 0;

	if Instance ~= nil then
		Distance = (Camera.CFrame.Position - Instance.Position).Magnitude;
		if Options.VisCheck.Value then
			Pass = CheckRay(Instance, Distance, Camera.CFrame.Position, (Instance.Position - Camera.CFrame.Position).unit);
		end
		if Distance > Options.MaxDistance.Value then
			Pass = false;
		end
	else
		Pass = false;
	end

	return Pass, Distance;
end

local function UpdatePlayerData()
	if (tick() - LastRefresh) > (Options.RefreshRate.Value / 1000) then
		LastRefresh = tick();
		if CustomESP and Options.Enabled.Value then
			local a, b = pcall(CustomESP);
		end
		for i, v in pairs(RenderList.Instances) do
			if v.Instance ~= nil and v.Instance.Parent ~= nil and v.Instance:IsA'BasePart' then
				local Data = shared.InstanceData[v.Instance:GetDebugId()] or { Instances = {}; DontDelete = true };

				Data.Instance = v.Instance;

				Data.Instances['OutlineTracer'] = Data.Instances['OutlineTracer'] or NewDrawing'Line'{
					Transparency	= 0.75;
					Thickness		= 5;
					Color 			= Color3.new(0.1, 0.1, 0.1);
				}
				Data.Instances['Tracer'] = Data.Instances['Tracer'] or NewDrawing'Line'{
					Transparency	= 1;
					Thickness		= 2;
				}
				Data.Instances['NameTag'] = Data.Instances['NameTag'] or NewDrawing'Text'{
					Size			= Options.TextSize.Value;
					Center			= true;
					Outline			= Options.TextOutline.Value;
					Visible			= true;
				};
				Data.Instances['DistanceTag'] = Data.Instances['DistanceTag'] or NewDrawing'Text'{
					Size			= Options.TextSize.Value - 1;
					Center			= true;
					Outline			= Options.TextOutline.Value;
					Visible			= true;
				};

				local NameTag		= Data.Instances['NameTag'];
				local DistanceTag	= Data.Instances['DistanceTag'];
				local Tracer		= Data.Instances['Tracer'];
				local OutlineTracer	= Data.Instances['OutlineTracer'];

				local Pass, Distance = CheckDistance(v.Instance);

				if Pass then
					local ScreenPosition, Vis = WorldToViewport(v.Instance.Position);
					local Color = v.Color;
					local OPos = Camera.CFrame:pointToObjectSpace(v.Instance.Position);
					
					if ScreenPosition.Z < 0 then
						local AT = math.atan2(OPos.Y, OPos.X) + math.pi;
						OPos = CFrame.Angles(0, 0, AT):vectorToWorldSpace((CFrame.Angles(0, math.rad(89.9), 0):vectorToWorldSpace(V3New(0, 0, -1))));
					end
					
					local Position = WorldToViewport(Camera.CFrame:pointToWorldSpace(OPos));

					if Options.ShowTracers.Value then
						Tracer.Transparency = math.clamp(Distance / 200, 0.45, 0.8);
						Tracer.Visible	= true;
						Tracer.From		= TracerPosition;
						Tracer.To		= V2New(Position.X, Position.Y);
						Tracer.Color	= Color;
						OutlineTracer.Visible = true;
						OutlineTracer.Transparency = Tracer.Transparency - 0.1;
						OutlineTracer.From = Tracer.From;
						OutlineTracer.To = Tracer.To;
						OutlineTracer.Color	= Color3.new(0.1, 0.1, 0.1);
					else
						Tracer.Visible = false;
						OutlineTracer.Visible = false;
					end

					if ScreenPosition.Z > 0 then
						local ScreenPositionUpper = ScreenPosition;
						
						if Options.ShowName.Value then
							LocalPlayer.NameDisplayDistance = 0;
							NameTag.Visible		= true;
							NameTag.Text		= v.Text;
							NameTag.Size		= Options.TextSize.Value;
							NameTag.Outline		= Options.TextOutline.Value;
							NameTag.Position	= V2New(ScreenPositionUpper.X, ScreenPositionUpper.Y);
							NameTag.Color		= Color;
							if Drawing.Fonts and shared.am_ic3 then -- CURRENTLY SYNAPSE ONLY :MEGAHOLY:
								NameTag.Font	= Drawing.Fonts.Monospace;
							end
						else
							LocalPlayer.NameDisplayDistance = 100;
							NameTag.Visible = false;
						end
						if Options.ShowDistance.Value or Options.ShowHealth.Value then
							DistanceTag.Visible		= true;
							DistanceTag.Size		= Options.TextSize.Value - 1;
							DistanceTag.Outline		= Options.TextOutline.Value;
							DistanceTag.Color		= Color3.new(1, 1, 1);
							if Drawing.Fonts and shared.am_ic3 then -- CURRENTLY SYNAPSE ONLY :MEGAHOLY:
								NameTag.Font	= Drawing.Fonts.Monospace;
							end

							local Str = '';

							if Options.ShowDistance.Value then
								Str = Str .. Format('[%d] ', Distance);
							end

							DistanceTag.Text = Str;
							DistanceTag.Position = V2New(ScreenPositionUpper.X, ScreenPositionUpper.Y) + V2New(0, NameTag.TextBounds.Y);
						else
							DistanceTag.Visible = false;
						end
					else
						NameTag.Visible			= false;
						DistanceTag.Visible		= false;
					end
				else
					NameTag.Visible			= false;
					DistanceTag.Visible		= false;
					Tracer.Visible			= false;
					OutlineTracer.Visible	= false;
				end

				Data.Instances['NameTag'] 		= NameTag;
				Data.Instances['DistanceTag']	= DistanceTag;
				Data.Instances['Tracer']		= Tracer;
				Data.Instances['OutlineTracer']	= OutlineTracer;

				shared.InstanceData[v.Instance:GetDebugId()] = Data;
			end
		end
		for i, v in pairs(Players:GetPlayers()) do
			local Data = shared.InstanceData[v.Name] or { Instances = {}; };

			Data.Instances['Box'] = Data.Instances['Box'] or LineBox:Create{Thickness = 4};
			Data.Instances['OutlineTracer'] = Data.Instances['OutlineTracer'] or NewDrawing'Line'{
				Transparency	= 1;
				Thickness		= 3;
				Color			= Color3.new(0.1, 0.1, 0.1);
			}
			Data.Instances['Tracer'] = Data.Instances['Tracer'] or NewDrawing'Line'{
				Transparency	= 1;
				Thickness		= 1;
			}
			Data.Instances['HeadDot'] = Data.Instances['HeadDot'] or NewDrawing'Circle'{
				Filled			= true;
				NumSides		= 30;
			}
			Data.Instances['NameTag'] = Data.Instances['NameTag'] or NewDrawing'Text'{
				Size			= Options.TextSize.Value;
				Center			= true;
				Outline			= Options.TextOutline.Value;
				OutlineOpacity	= 1;
				Visible			= true;
			};
			Data.Instances['DistanceHealthTag'] = Data.Instances['DistanceHealthTag'] or NewDrawing'Text'{
				Size			= Options.TextSize.Value - 1;
				Center			= true;
				Outline			= Options.TextOutline.Value;
				OutlineOpacity	= 1;
				Visible			= true;
			};

			local NameTag		= Data.Instances['NameTag'];
			local DistanceTag	= Data.Instances['DistanceHealthTag'];
			local Tracer		= Data.Instances['Tracer'];
			local OutlineTracer	= Data.Instances['OutlineTracer'];
			local HeadDot		= Data.Instances['HeadDot'];
			local Box			= Data.Instances['Box'];

			local Character = GetCharacter(v);
			local Pass, Distance = CheckPlayer(v, Character);

			if Pass and Character then
				local Humanoid = Character:FindFirstChildOfClass'Humanoid';
				local Head = Character:FindFirstChild'Head';
				local HumanoidRootPart = Character:FindFirstChild(CustomRootPartName or 'HumanoidRootPart')

				local Dead = (Humanoid and Humanoid:GetState().Name == 'Dead')
				if type(GetAliveState) == 'function' then
					Dead = (not GetAliveState(v, Character))
				end

				if Character ~= nil and Head and HumanoidRootPart and not Dead then
					local ScreenPosition, Vis = WorldToViewport(Head.Position);
					local Color = Rainbow and Color3.fromHSV(tick() * 128 % 255/255, 1, 1) or (CheckTeam(v) and TeamColor or EnemyColor); Color = Options.ShowTeamColor.Value and v.TeamColor.Color or Color;
					local OPos = Camera.CFrame:pointToObjectSpace(Head.Position);
					
					if ScreenPosition.Z < 0 then
						local AT = math.atan2(OPos.Y, OPos.X) + math.pi;
						OPos = CFrame.Angles(0, 0, AT):vectorToWorldSpace((CFrame.Angles(0, math.rad(89.9), 0):vectorToWorldSpace(V3New(0, 0, -1))));
					end
					
					local Position = WorldToViewport(Camera.CFrame:pointToWorldSpace(OPos));

					if Options.ShowTracers.Value then
						if TracerPosition.X >= Camera.ViewportSize.X or TracerPosition.Y >= Camera.ViewportSize.Y or TracerPosition.X < 0 or TracerPosition.Y < 0 then
							TracerPosition = V2New(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y - 135);
						end

						Tracer.Visible	= true;
						Tracer.Transparency = math.clamp(1 - (Distance / 200), 0.25, 0.75);
						Tracer.From		= TracerPosition;
						Tracer.To		= V2New(Position.X, Position.Y);
						Tracer.Color	= Color;
						OutlineTracer.From = Tracer.From;
						OutlineTracer.To = Tracer.To;
						OutlineTracer.Transparency = Tracer.Transparency - 0.15;
						OutlineTracer.Visible = true;
					else
						Tracer.Visible = false;
						OutlineTracer.Visible = false;
					end
					
					if ScreenPosition.Z > 0 then
						local ScreenPositionUpper	= WorldToViewport((HumanoidRootPart:GetRenderCFrame() * CFrame.new(0, Head.Size.Y + HumanoidRootPart.Size.Y + (Options.YOffset.Value / 25), 0)).Position);
						local Scale					= Head.Size.Y / 2;

						if Options.ShowName.Value then
							NameTag.Visible		= true;
							NameTag.Text		= v.Name .. (CustomPlayerTag and CustomPlayerTag(v) or '');
							NameTag.Size		= Options.TextSize.Value;
							NameTag.Outline		= Options.TextOutline.Value;
							NameTag.Position	= V2New(ScreenPositionUpper.X, ScreenPositionUpper.Y) - V2New(0, NameTag.TextBounds.Y);
							NameTag.Color		= Color;
							NameTag.Color		= Color;
							NameTag.OutlineColor= Color3.new(0.05, 0.05, 0.05);
							NameTag.Transparency= 0.85;
							if Drawing.Fonts and shared.am_ic3 then -- CURRENTLY SYNAPSE ONLY :MEGAHOLY:
								NameTag.Font	= Drawing.Fonts.Monospace;
							end
						else
							NameTag.Visible = false;
						end
						if Options.ShowDistance.Value or Options.ShowHealth.Value then
							DistanceTag.Visible		= true;
							DistanceTag.Size		= Options.TextSize.Value - 1;
							DistanceTag.Outline		= Options.TextOutline.Value;
							DistanceTag.Color		= Color3.new(1, 1, 1);
							DistanceTag.Transparency= 0.85;
							if Drawing.Fonts and shared.am_ic3 then -- CURRENTLY SYNAPSE ONLY :MEGAHOLY:
								NameTag.Font	= Drawing.Fonts.Monospace;
							end

							local Str = '';

							if Options.ShowDistance.Value then
								Str = Str .. Format('[%d] ', Distance);
							end
							if Options.ShowHealth.Value then								
								if typeof(Humanoid) == 'Instance' then
									Str = Str .. Format('[%d/%d] [%s%%]', Humanoid.Health, Humanoid.MaxHealth, math.floor(Humanoid.Health / Humanoid.MaxHealth * 100));
								elseif type(GetHealth) == 'function' then
									local health, maxHealth = GetHealth(v)
									
									if type(health) == 'number' and type(maxHealth) == 'number' then
										Str = Str .. Format('[%d/%d] [%s%%]', health, maxHealth, math.floor(health / maxHealth * 100))
									end
								end
							end

							DistanceTag.Text = Str;
							DistanceTag.OutlineColor = Color3.new(0.05, 0.05, 0.05);
							DistanceTag.Position = (NameTag.Visible and NameTag.Position + V2New(0, NameTag.TextBounds.Y) or V2New(ScreenPositionUpper.X, ScreenPositionUpper.Y));
						else
							DistanceTag.Visible = false;
						end
						if Options.ShowDot.Value and Vis then
							local Top			= WorldToViewport((Head.CFrame * CFrame.new(0, Scale, 0)).Position);
							local Bottom		= WorldToViewport((Head.CFrame * CFrame.new(0, -Scale, 0)).Position);
							local Radius		= math.abs((Top - Bottom).Y);

							HeadDot.Visible		= true;
							HeadDot.Color		= Color;
							HeadDot.Position	= V2New(ScreenPosition.X, ScreenPosition.Y);
							HeadDot.Radius		= Radius;
						else
							HeadDot.Visible = false;
						end
						if Options.ShowBoxes.Value and Vis and HumanoidRootPart then
							local Body = {
								Head;
								Character:FindFirstChild'Left Leg' or Character:FindFirstChild'LeftLowerLeg';
								Character:FindFirstChild'Right Leg' or Character:FindFirstChild'RightLowerLeg';
								Character:FindFirstChild'Left Arm' or Character:FindFirstChild'LeftLowerArm';
								Character:FindFirstChild'Right Arm' or Character:FindFirstChild'RightLowerArm';
							}
							Box:Update(HumanoidRootPart.CFrame, V3New(2, 3, 1) * (Scale * 2), Color, nil, shared.am_ic3 and Body);
						else
							Box:SetVisible(false);
						end
					else
						NameTag.Visible			= false;
						DistanceTag.Visible		= false;
						HeadDot.Visible			= false;
						
						Box:SetVisible(false);
					end
				else
					NameTag.Visible			= false;
					DistanceTag.Visible		= false;
					HeadDot.Visible			= false;
					Tracer.Visible			= false;
					OutlineTracer.Visible 	= false;
					
					Box:SetVisible(false);
				end
			else
				NameTag.Visible			= false;
				DistanceTag.Visible		= false;
				HeadDot.Visible			= false;
				Tracer.Visible			= false;
				OutlineTracer.Visible 	= false;

				Box:SetVisible(false);
			end

			shared.InstanceData[v.Name] = Data;
		end
	end
end

local LastInvalidCheck = 0;

local function Update()
	if tick() - LastInvalidCheck > 0.3 then
		LastInvalidCheck = tick();

		if Camera.Parent ~= workspace then
			Camera = workspace.CurrentCamera;
			CameraCon();
			WTVP = Camera.WorldToViewportPoint;
		end

		for i, v in pairs(shared.InstanceData) do
			if not Players:FindFirstChild(tostring(i)) then
				if not shared.InstanceData[i].DontDelete then
					GetTableData(v.Instances)(function(i, obj)
						obj.Visible = false;
						obj:Remove();
						v.Instances[i] = nil;
					end)
					shared.InstanceData[i] = nil;
				else
					if shared.InstanceData[i].Instance == nil or shared.InstanceData[i].Instance.Parent == nil then
						GetTableData(v.Instances)(function(i, obj)
							obj.Visible = false;
							obj:Remove();
							v.Instances[i] = nil;
						end)
						shared.InstanceData[i] = nil;
					end
				end
			end
		end
	end

	local CX = Menu:GetInstance'CrosshairX';
	local CY = Menu:GetInstance'CrosshairY';
	
	if Options.Crosshair.Value then
		CX.Visible = true;
		CY.Visible = true;

		CX.To = V2New((Camera.ViewportSize.X / 2) - 8, (Camera.ViewportSize.Y / 2));
		CX.From = V2New((Camera.ViewportSize.X / 2) + 8, (Camera.ViewportSize.Y / 2));
		CY.To = V2New((Camera.ViewportSize.X / 2), (Camera.ViewportSize.Y / 2) - 8);
		CY.From = V2New((Camera.ViewportSize.X / 2), (Camera.ViewportSize.Y / 2) + 8);
	else
		CX.Visible = false;
		CY.Visible = false;
	end

	if Options.MenuOpen.Value and MenuLoaded then
		local MLocation = GetMouseLocation();
		shared.MenuDrawingData.Instances.Main.Color = Color3.fromHSV(tick() * 24 % 255/255, 1, 1);
		local MainInstance = Menu:GetInstance'Main';
		
		local Values = {
			MainInstance.Position.X;
			MainInstance.Position.Y;
			MainInstance.Position.X + MainInstance.Size.X;
			MainInstance.Position.Y + MainInstance.Size.Y;
		};
		
		if MainInstance and (MouseHoveringOver(Values) or (SubMenu.Open and MouseHoveringOver(SubMenu.Bounds))) then
			Debounce.CursorVis = true;
			
			Menu:UpdateMenuInstance'Cursor1'{
				Visible	= true;
				From	= V2New(MLocation.x, MLocation.y);
				To		= V2New(MLocation.x + 5, MLocation.y + 6);
			}
			Menu:UpdateMenuInstance'Cursor2'{
				Visible	= true;
				From	= V2New(MLocation.x, MLocation.y);
				To		= V2New(MLocation.x, MLocation.y + 8);
			}
			Menu:UpdateMenuInstance'Cursor3'{
				Visible	= true;
				From	= V2New(MLocation.x, MLocation.y + 6);
				To		= V2New(MLocation.x + 5, MLocation.y + 5);
			}
		else
			if Debounce.CursorVis then
				Debounce.CursorVis = false;
				
				Menu:UpdateMenuInstance'Cursor1'{Visible = false};
				Menu:UpdateMenuInstance'Cursor2'{Visible = false};
				Menu:UpdateMenuInstance'Cursor3'{Visible = false};
			end
		end
		if MouseHeld then
			local MousePos = GetMouseLocation();

			if Dragging then
				DraggingWhat.Slider.Position = V2New(math.clamp(MLocation.X - DraggingWhat.Slider.Size.X / 2, DraggingWhat.Line.Position.X, DraggingWhat.Line.Position.X + DraggingWhat.Line.Size.X - DraggingWhat.Slider.Size.X), DraggingWhat.Slider.Position.Y);
				local Percent	= (DraggingWhat.Slider.Position.X - DraggingWhat.Line.Position.X) / ((DraggingWhat.Line.Position.X + DraggingWhat.Line.Size.X - DraggingWhat.Line.Position.X) - DraggingWhat.Slider.Size.X);
				local Value		= CalculateValue(DraggingWhat.Min, DraggingWhat.Max, Percent);
				DraggingWhat.Option(Value);
			elseif DraggingUI then
				Debounce.UIDrag = true;
				local Main = Menu:GetInstance'Main';
				Main.Position = MousePos + DragOffset;
			elseif DragTracerPosition then
				TracerPosition = MousePos;
			end
		else
			Dragging = false;
			DragTracerPosition = false;
			if DraggingUI and Debounce.UIDrag then
				Debounce.UIDrag = false;
				DraggingUI = false;
				CreateMenu(Menu:GetInstance'Main'.Position);
			end
		end
		if not Debounce.Menu then
			Debounce.Menu = true;
			ToggleMenu();
		end
	elseif Debounce.Menu and not Options.MenuOpen.Value then
		Debounce.Menu = false;
		ToggleMenu();
	end
end

RunService:UnbindFromRenderStep(GetDataName);
RunService:UnbindFromRenderStep(UpdateName);

RunService:BindToRenderStep(GetDataName, 300, UpdatePlayerData);
RunService:BindToRenderStep(UpdateName, 199, Update);
end)

Scripts:NewButton("Universal Aimlock", "Execute the Universal Aimlock", function()
--FE Simple AimLock Script | Released Nov 2021 | Working.
local Area = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local MyCharacter = LocalPlayer.Character
local MyRoot = MyCharacter:FindFirstChild("HumanoidRootPart")
local MyHumanoid = MyCharacter:FindFirstChild("Humanoid")
local Mouse = LocalPlayer:GetMouse()
local MyView = Area.CurrentCamera
local MyTeamColor = LocalPlayer.TeamColor
local HoldingM2 = false
local Active = false
local Lock = false
local Epitaph = .187 ---Note: The Bigger The Number, The More Prediction.
local HeadOffset = Vector3.new(0, .1, 0)

_G.TeamCheck = false
_G.AimPart = "HumanoidRootPart"
_G.Sensitivity = 0
_G.CircleSides = 64
_G.CircleColor = Color3.fromRGB(255, 0, 130)
_G.CircleTransparency = 0
_G.CircleRadius = 200
_G.CircleFilled = false
_G.CircleVisible = true
_G.CircleThickness = 1

local FOVCircle = Drawing.new("Circle")
FOVCircle.Position = Vector2.new(MyView.ViewportSize.X / 2, MyView.ViewportSize.Y / 2)
FOVCircle.Radius = _G.CircleRadius
FOVCircle.Filled = _G.CircleFilled
FOVCircle.Color = _G.CircleColor
FOVCircle.Visible = _G.CircleVisible
FOVCircle.Transparency = _G.CircleTransparency
FOVCircle.NumSides = _G.CircleSides
FOVCircle.Thickness = _G.CircleThickness

local function CursorLock()
	UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
end
local function UnLockCursor()
	HoldingM2 = false Active = false Lock = false 
	UIS.MouseBehavior = Enum.MouseBehavior.Default
end
function FindNearestPlayer()
	local dist = math.huge
	local Target = nil
	for _, v in pairs(Players:GetPlayers()) do
		if v ~= LocalPlayer and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("Humanoid").Health > 0 and v.Character:FindFirstChild("HumanoidRootPart") and v then
			local TheirCharacter = v.Character
			local CharacterRoot, Visible = MyView:WorldToViewportPoint(TheirCharacter[_G.AimPart].Position)
			if Visible then
				local RealMag = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(CharacterRoot.X, CharacterRoot.Y)).Magnitude
				if RealMag < dist and RealMag < FOVCircle.Radius then
					dist = RealMag
					Target = TheirCharacter
				end
			end
		end
	end
	return Target
end

UIS.InputBegan:Connect(function(Input)
	if Input.UserInputType == Enum.UserInputType.MouseButton2 then
		HoldingM2 = true
		Active = true
		Lock = true
		if Active then
        	local The_Enemy = FindNearestPlayer()
			while HoldingM2 do task.wait(.000001)
				if Lock and The_Enemy ~= nil then
					local Future = The_Enemy.HumanoidRootPart.CFrame + (The_Enemy.HumanoidRootPart.Velocity * Epitaph + HeadOffset)
					MyView.CFrame = CFrame.lookAt(MyView.CFrame.Position, Future.Position)
					CursorLock()
				end
			end
		end
	end
end)
UIS.InputEnded:Connect(function(Input)
	if Input.UserInputType == Enum.UserInputType.MouseButton2 then
		UnLockCursor()
	end
end)
game.StarterGui:SetCore("SendNotification", {Title = "Working.", Text = "Success, Script Loaded.", Duration = 4,})
end)

Scripts:NewButton("Universal Silent Aim", "Execute the Universal Silent Aim", function()
-- init
if not game:IsLoaded() then 
    game.Loaded:Wait()
end

if not syn or not protectgui then
    getgenv().protectgui = function() end
end

local SilentAimSettings = {
    Enabled = false,
    
    ClassName = "Universal Silent Aim - Averiias, Stefanuk12, xaxa",
    ToggleKey = "RightAlt",
    
    TeamCheck = false,
    VisibleCheck = false, 
    TargetPart = "HumanoidRootPart",
    SilentAimMethod = "Raycast",
    
    FOVRadius = 130,
    FOVVisible = false,
    ShowSilentAimTarget = false, 
    
    MouseHitPrediction = false,
    MouseHitPredictionAmount = 0.165,
    HitChance = 100
}

-- variables
getgenv().SilentAimSettings = Settings
local MainFileName = "UniversalSilentAim"
local SelectedFile, FileToSave = "", ""

local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local GetChildren = game.GetChildren
local GetPlayers = Players.GetPlayers
local WorldToScreen = Camera.WorldToScreenPoint
local WorldToViewportPoint = Camera.WorldToViewportPoint
local GetPartsObscuringTarget = Camera.GetPartsObscuringTarget
local FindFirstChild = game.FindFirstChild
local RenderStepped = RunService.RenderStepped
local GuiInset = GuiService.GetGuiInset
local GetMouseLocation = UserInputService.GetMouseLocation

local resume = coroutine.resume 
local create = coroutine.create

local ValidTargetParts = {"Head", "HumanoidRootPart"}
local PredictionAmount = 0.165

local mouse_box = Drawing.new("Square")
mouse_box.Visible = true 
mouse_box.ZIndex = 999 
mouse_box.Color = Color3.fromRGB(54, 57, 241)
mouse_box.Thickness = 20 
mouse_box.Size = Vector2.new(20, 20)
mouse_box.Filled = true 

local fov_circle = Drawing.new("Circle")
fov_circle.Thickness = 1
fov_circle.NumSides = 100
fov_circle.Radius = 180
fov_circle.Filled = false
fov_circle.Visible = false
fov_circle.ZIndex = 999
fov_circle.Transparency = 1
fov_circle.Color = Color3.fromRGB(54, 57, 241)

local ExpectedArguments = {
    FindPartOnRayWithIgnoreList = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Ray", "table", "boolean", "boolean"
        }
    },
    FindPartOnRayWithWhitelist = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Ray", "table", "boolean"
        }
    },
    FindPartOnRay = {
        ArgCountRequired = 2,
        Args = {
            "Instance", "Ray", "Instance", "boolean", "boolean"
        }
    },
    Raycast = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Vector3", "Vector3", "RaycastParams"
        }
    }
}

function CalculateChance(Percentage)
    -- // Floor the percentage
    Percentage = math.floor(Percentage)

    -- // Get the chance
    local chance = math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100) / 100

    -- // Return
    return chance <= Percentage / 100
end


--[[file handling]] do 
    if not isfolder(MainFileName) then 
        makefolder(MainFileName);
    end
    
    if not isfolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId))) then 
        makefolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId)))
    end
end

local Files = listfiles(string.format("%s/%s", "UniversalSilentAim", tostring(game.PlaceId)))

-- functions
local function GetFiles() -- credits to the linoria lib for this function, listfiles returns the files full path and its annoying
	local out = {}
	for i = 1, #Files do
		local file = Files[i]
		if file:sub(-4) == '.lua' then
			-- i hate this but it has to be done ...

			local pos = file:find('.lua', 1, true)
			local start = pos

			local char = file:sub(pos, pos)
			while char ~= '/' and char ~= '\\' and char ~= '' do
				pos = pos - 1
				char = file:sub(pos, pos)
			end

			if char == '/' or char == '\\' then
				table.insert(out, file:sub(pos + 1, start - 1))
			end
		end
	end
	
	return out
end

local function UpdateFile(FileName)
    assert(FileName or FileName == "string", "oopsies");
    writefile(string.format("%s/%s/%s.lua", MainFileName, tostring(game.PlaceId), FileName), HttpService:JSONEncode(SilentAimSettings))
end

local function LoadFile(FileName)
    assert(FileName or FileName == "string", "oopsies");
    
    local File = string.format("%s/%s/%s.lua", MainFileName, tostring(game.PlaceId), FileName)
    local ConfigData = HttpService:JSONDecode(readfile(File))
    for Index, Value in next, ConfigData do
        SilentAimSettings[Index] = Value
    end
end

local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToScreen(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then
        return false
    end
    for Pos, Argument in next, Args do
        if typeof(Argument) == RayMethod.Args[Pos] then
            Matches = Matches + 1
        end
    end
    return Matches >= RayMethod.ArgCountRequired
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

local function getMousePosition()
    return GetMouseLocation(UserInputService)
end

local function IsPlayerVisible(Player)
    local PlayerCharacter = Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character
    
    if not (PlayerCharacter or LocalPlayerCharacter) then return end 
    
    local PlayerRoot = FindFirstChild(PlayerCharacter, Options.TargetPart.Value) or FindFirstChild(PlayerCharacter, "HumanoidRootPart")
    
    if not PlayerRoot then return end 
    
    local CastPoints, IgnoreList = {PlayerRoot.Position, LocalPlayerCharacter, PlayerCharacter}, {LocalPlayerCharacter, PlayerCharacter}
    local ObscuringObjects = #GetPartsObscuringTarget(Camera, CastPoints, IgnoreList)
    
    return ((ObscuringObjects == 0 and true) or (ObscuringObjects > 0 and false))
end

local function getClosestPlayer()
    if not Options.TargetPart.Value then return end
    local Closest
    local DistanceToMouse
    for _, Player in next, GetPlayers(Players) do
        if Player == LocalPlayer then continue end
        if Toggles.TeamCheck.Value and Player.Team == LocalPlayer.Team then continue end

        local Character = Player.Character
        if not Character then continue end
        
        if Toggles.VisibleCheck.Value and not IsPlayerVisible(Player) then continue end

        local HumanoidRootPart = FindFirstChild(Character, "HumanoidRootPart")
        local Humanoid = FindFirstChild(Character, "Humanoid")
        if not HumanoidRootPart or not Humanoid or Humanoid and Humanoid.Health <= 0 then continue end

        local ScreenPosition, OnScreen = getPositionOnScreen(HumanoidRootPart.Position)
        if not OnScreen then continue end

        local Distance = (getMousePosition() - ScreenPosition).Magnitude
        if Distance <= (DistanceToMouse or Options.Radius.Value or 2000) then
            Closest = ((Options.TargetPart.Value == "Random" and Character[ValidTargetParts[math.random(1, #ValidTargetParts)]]) or Character[Options.TargetPart.Value])
            DistanceToMouse = Distance
        end
    end
    return Closest
end

-- ui creating & handling
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xaxaxaxaxaxaxaxaxa/Libraries/main/UI's/Linoria/Source.lua"))()
Library:SetWatermark("github.com/Averiias")

local Window = Library:CreateWindow("Universal Silent Aim, by Averiias, xaxa, and Stefanuk12")
local GeneralTab = Window:AddTab("General")
local MainBOX = GeneralTab:AddLeftTabbox("Main") do
    local Main = MainBOX:AddTab("Main")
    
    Main:AddToggle("aim_Enabled", {Text = "Enabled"}):AddKeyPicker("aim_Enabled_KeyPicker", {Default = "RightAlt", SyncToggleState = true, Mode = "Toggle", Text = "Enabled", NoUI = false});
    Options.aim_Enabled_KeyPicker:OnClick(function()
        SilentAimSettings.Enabled = not SilentAimSettings.Enabled
        
        Toggles.aim_Enabled.Value = SilentAimSettings.Enabled
        Toggles.aim_Enabled:SetValue(SilentAimSettings.Enabled)
        
        mouse_box.Visible = SilentAimSettings.Enabled
    end)
    
    Main:AddToggle("TeamCheck", {Text = "Team Check", Default = SilentAimSettings.TeamCheck}):OnChanged(function()
        SilentAimSettings.TeamCheck = Toggles.TeamCheck.Value
    end)
    Main:AddToggle("VisibleCheck", {Text = "Visible Check", Default = SilentAimSettings.VisibleCheck}):OnChanged(function()
        SilentAimSettings.VisibleCheck = Toggles.VisibleCheck.Value
    end)
    Main:AddDropdown("TargetPart", {Text = "Target Part", Default = SilentAimSettings.TargetPart, Values = {"Head", "HumanoidRootPart", "Random"}}):OnChanged(function()
        SilentAimSettings.TargetPart = Options.TargetPart.Value
    end)
    Main:AddDropdown("Method", {Text = "Silent Aim Method", Default = SilentAimSettings.SilentAimMethod, Values = {
        "Raycast","FindPartOnRay",
        "FindPartOnRayWithWhitelist",
        "FindPartOnRayWithIgnoreList",
        "Mouse.Hit/Target"
    }}):OnChanged(function() 
        SilentAimSettings.SilentAimMethod = Options.Method.Value 
    end)
    Main:AddSlider('HitChance', {
        Text = 'Hit chance',
        Default = 100,
        Min = 0,
        Max = 100,
        Rounding = 1,
    
        Compact = false,
    })
    Options.HitChance:OnChanged(function()
        SilentAimSettings.HitChance = Options.HitChance.Value
    end)
end

local MiscellaneousBOX = GeneralTab:AddLeftTabbox("Miscellaneous")
local FieldOfViewBOX = GeneralTab:AddLeftTabbox("Field Of View") do
    local Main = FieldOfViewBOX:AddTab("Visuals")
    
    Main:AddToggle("Visible", {Text = "Show FOV Circle"}):AddColorPicker("Color", {Default = Color3.fromRGB(54, 57, 241)}):OnChanged(function()
        fov_circle.Visible = Toggles.Visible.Value
        SilentAimSettings.FOVVisible = Toggles.Visible.Value
    end)
    Main:AddSlider("Radius", {Text = "FOV Circle Radius", Min = 0, Max = 360, Default = 130, Rounding = 0}):OnChanged(function()
        fov_circle.Radius = Options.Radius.Value
        SilentAimSettings.FOVRadius = Options.Radius.Value
    end)
    Main:AddToggle("MousePosition", {Text = "Show Silent Aim Target"}):AddColorPicker("MouseVisualizeColor", {Default = Color3.fromRGB(54, 57, 241)}):OnChanged(function()
        mouse_box.Visible = Toggles.MousePosition.Value 
        SilentAimSettings.ShowSilentAimTarget = Toggles.MousePosition.Value 
    end)
    local PredictionTab = MiscellaneousBOX:AddTab("Prediction")
    PredictionTab:AddToggle("Prediction", {Text = "Mouse.Hit/Target Prediction"}):OnChanged(function()
        SilentAimSettings.MouseHitPrediction = Toggles.Prediction.Value
    end)
    PredictionTab:AddSlider("Amount", {Text = "Prediction Amount", Min = 0.165, Max = 1, Default = 0.165, Rounding = 3}):OnChanged(function()
        PredictionAmount = Options.Amount.Value
        SilentAimSettings.MouseHitPredictionAmount = Options.Amount.Value
    end)
end

local CreateConfigurationBOX = GeneralTab:AddRightTabbox("Create Configuration") do 
    local Main = CreateConfigurationBOX:AddTab("Create Configuration")
    
    Main:AddInput("CreateConfigTextBox", {Default = "", Numeric = false, Finished = false, Text = "Create Configuration to Create", Tooltip = "Creates a configuration file containing settings you can save and load", Placeholder = "File Name here"}):OnChanged(function()
        if Options.CreateConfigTextBox.Value and string.len(Options.CreateConfigTextBox.Value) ~= "" then 
            FileToSave = Options.CreateConfigTextBox.Value
        end
    end)
    
    Main:AddButton("Create Configuration File", function()
        if FileToSave ~= "" or FileToSave ~= nil then 
            UpdateFile(FileToSave)
        end
    end)
end

local SaveConfigurationBOX = GeneralTab:AddRightTabbox("Save Configuration") do 
    local Main = SaveConfigurationBOX:AddTab("Save Configuration")
    Main:AddDropdown("SaveConfigurationDropdown", {Values = GetFiles(), Text = "Choose Configuration to Save"})
    Main:AddButton("Save Configuration", function()
        if Options.SaveConfigurationDropdown.Value then 
            UpdateFile(Options.SaveConfigurationDropdown.Value)
        end
    end)
end

local LoadConfigurationBOX = GeneralTab:AddRightTabbox("Load Configuration") do 
    local Main = LoadConfigurationBOX:AddTab("Load Configuration")
    
    Main:AddDropdown("LoadConfigurationDropdown", {Values = GetFiles(), Text = "Choose Configuration to Load"})
    Main:AddButton("Load Configuration", function()
        if table.find(GetFiles(), Options.LoadConfigurationDropdown.Value) then
            LoadFile(Options.LoadConfigurationDropdown.Value)
            
            Toggles.TeamCheck:SetValue(SilentAimSettings.TeamCheck)
            Toggles.VisibleCheck:SetValue(SilentAimSettings.VisibleCheck)
            Options.TargetPart:SetValue(SilentAimSettings.TargetPart)
            Options.Method:SetValue(SilentAimSettings.SilentAimMethod)
            Toggles.Visible:SetValue(SilentAimSettings.FOVVisible)
            Options.Radius:SetValue(SilentAimSettings.FOVRadius)
            Toggles.MousePosition:SetValue(SilentAimSettings.ShowSilentAimTarget)
            Toggles.Prediction:SetValue(SilentAimSettings.MouseHitPrediction)
            Options.Amount:SetValue(SilentAimSettings.MouseHitPredictionAmount)
            Options.HitChance:SetValue(SilentAimSettings.HitChance)
        end
    end)
end

resume(create(function()
    RenderStepped:Connect(function()
        if Toggles.MousePosition.Value and Toggles.aim_Enabled.Value then
            if getClosestPlayer() then 
                local Root = getClosestPlayer().Parent.PrimaryPart or getClosestPlayer()
                local RootToViewportPoint, IsOnScreen = WorldToViewportPoint(Camera, Root.Position);
                -- using PrimaryPart instead because if your Target Part is "Random" it will flicker the square between the Target's Head and HumanoidRootPart (its annoying)
                
                mouse_box.Visible = IsOnScreen
                mouse_box.Position = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
            else 
                mouse_box.Visible = false 
                mouse_box.Position = Vector2.new()
            end
        end
        
        if Toggles.Visible.Value then 
            fov_circle.Visible = Toggles.Visible.Value
            fov_circle.Color = Options.Color.Value
            fov_circle.Position = getMousePosition()
        end
    end)
end))

-- hooks
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]
    local chance = CalculateChance(SilentAimSettings.HitChance)
    if Toggles.aim_Enabled.Value and self == workspace and not checkcaller() and chance == true then
        if Method == "FindPartOnRayWithIgnoreList" and Options.Method.Value == Method then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithIgnoreList) then
                local A_Ray = Arguments[2]

                local HitPart = getClosestPlayer()
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)

                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif Method == "FindPartOnRayWithWhitelist" and Options.Method.Value == Method then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithWhitelist) then
                local A_Ray = Arguments[2]

                local HitPart = getClosestPlayer()
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)

                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif (Method == "FindPartOnRay" or Method == "findPartOnRay") and Options.Method.Value:lower() == Method:lower() then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRay) then
                local A_Ray = Arguments[2]

                local HitPart = getClosestPlayer()
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)

                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif Method == "Raycast" and Options.Method.Value == Method then
            if ValidateArguments(Arguments, ExpectedArguments.Raycast) then
                local A_Origin = Arguments[2]

                local HitPart = getClosestPlayer()
                if HitPart then
                    Arguments[3] = getDirection(A_Origin, HitPart.Position)

                    return oldNamecall(unpack(Arguments))
                end
            end
        end
    end
    return oldNamecall(...)
end))

local oldIndex = nil 
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, Index)
    if self == Mouse and not checkcaller() and Toggles.aim_Enabled.Value and Options.Method.Value == "Mouse.Hit/Target" and getClosestPlayer() then
        local HitPart = getClosestPlayer()
         
        if Index == "Target" or Index == "target" then 
            return HitPart
        elseif Index == "Hit" or Index == "hit" then 
            return ((Toggles.Prediction.Value and (HitPart.CFrame + (HitPart.Velocity * PredictionAmount))) or (not Toggles.Prediction.Value and HitPart.CFrame))
        elseif Index == "X" or Index == "x" then 
            return self.X 
        elseif Index == "Y" or Index == "y" then 
            return self.Y 
        elseif Index == "UnitRay" then 
            return Ray.new(self.Origin, (self.Hit - self.Origin).Unit)
        end
    end

    return oldIndex(self, Index)
end))
end)

Scripts:NewButton("Better Chat Bypasser", "Execute the Better Chat Bypasser.", function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/daddysyn/synergy/additional/betterbypasser",true))()
end)

Scripts:NewButton("Synapse X", "Execute the Synapse X.", function()
-- Instances:

local SynapseXreal = Instance.new("ScreenGui")
local MainFrame = Instance.new("Frame")
local bar = Instance.new("Frame")
local Close = Instance.new("TextButton")
local ImageLabel = Instance.new("ImageLabel")
local security = Instance.new("TextLabel")
local EditorFrame = Instance.new("ScrollingFrame")
local Source = Instance.new("TextBox")
local Comments_ = Instance.new("TextLabel")
local Globals_ = Instance.new("TextLabel")
local Keywords_ = Instance.new("TextLabel")
local RemoteHighlight_ = Instance.new("TextLabel")
local Strings_ = Instance.new("TextLabel")
local Tokens_ = Instance.new("TextLabel")
local Numbers_ = Instance.new("TextLabel")
local Lines = Instance.new("TextLabel")
local title = Instance.new("TextLabel")
local list = Instance.new("Frame")
local execute = Instance.new("TextButton")
local clear = Instance.new("TextButton")
local scripthub = Instance.new("TextButton")
local Attach = Instance.new("TextButton")
local title_2 = Instance.new("ImageLabel")
local scripthub_2 = Instance.new("Frame")
local bar_2 = Instance.new("Frame")
local select = Instance.new("Frame")
local dex = Instance.new("TextButton")
local esp = Instance.new("TextButton")
local spy = Instance.new("TextButton")
local dumper = Instance.new("TextButton")
local desc = Instance.new("Frame")
local descri = Instance.new("TextLabel")
local title_3 = Instance.new("TextLabel")
local execute_2 = Instance.new("TextButton")
local close = Instance.new("TextButton")
local title_4 = Instance.new("ImageLabel")

local scriptselected = "none"
local injected = false

--Properties:

SynapseXreal.Name = "Synapse X (real)"
SynapseXreal.Parent = game.CoreGui
SynapseXreal.ResetOnSpawn = false

MainFrame.Name = "MainFrame"
MainFrame.Parent = SynapseXreal
MainFrame.Active = true
MainFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
MainFrame.BorderSizePixel = 0
MainFrame.Position = UDim2.new(0.0543109924, 0, 0.103222892, 0)
MainFrame.Size = UDim2.new(0, 689, 0, 320)

bar.Name = "bar"
bar.Parent = MainFrame
bar.BackgroundColor3 = Color3.fromRGB(94, 94, 94)
bar.BackgroundTransparency = 0.800
bar.BorderSizePixel = 0
bar.Position = UDim2.new(-0, 0, -0.00296382909, 0)
bar.Size = UDim2.new(0, 689, 0, 25)

Close.Name = "Close"
Close.Parent = bar
Close.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Close.BackgroundTransparency = 1.000
Close.BorderColor3 = Color3.fromRGB(27, 42, 53)
Close.BorderSizePixel = 0
Close.Position = UDim2.new(0.969521046, 0, 0, 0)
Close.Size = UDim2.new(0, 21, 0, 25)
Close.Font = Enum.Font.Arial
Close.Text = "X"
Close.TextColor3 = Color3.fromRGB(255, 255, 255)
Close.TextSize = 14.000
Close.MouseButton1Click:Connect(function()
    SynapseXreal:Destroy()
end)

ImageLabel.Parent = MainFrame
ImageLabel.BackgroundColor3 = Color3.fromRGB(47, 47, 47)
ImageLabel.BorderSizePixel = 0
ImageLabel.Position = UDim2.new(0.0252733715, 0, 0.015625, 27)
ImageLabel.Size = UDim2.new(0, 541, 0, 246)

security.Name = "security"
security.Parent = ImageLabel
security.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
security.Size = UDim2.new(0, 552, 0, 258)
security.Visible = false
security.Font = Enum.Font.SourceSans
security.TextColor3 = Color3.fromRGB(0, 0, 0)
security.TextSize = 14.000

EditorFrame.Name = "EditorFrame"
EditorFrame.Parent = ImageLabel
EditorFrame.BackgroundColor3 = Color3.fromRGB(37, 37, 37)
EditorFrame.BackgroundTransparency = 1.000
EditorFrame.BorderColor3 = Color3.fromRGB(61, 61, 61)
EditorFrame.Size = UDim2.new(1, 0, 1, 0)
EditorFrame.ZIndex = 3
EditorFrame.BottomImage = "rbxassetid://148970562"
EditorFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
EditorFrame.HorizontalScrollBarInset = Enum.ScrollBarInset.ScrollBar
EditorFrame.MidImage = "rbxassetid://148970562"
EditorFrame.ScrollBarThickness = 5
EditorFrame.TopImage = "rbxassetid://148970562"

Source.Name = "Source"
Source.Parent = EditorFrame
Source.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Source.BackgroundTransparency = 1.000
Source.Position = UDim2.new(0, 30, 0, 0)
Source.Size = UDim2.new(0.945652187, 0, 1, 0)
Source.ZIndex = 3
Source.ClearTextOnFocus = false
Source.Font = Enum.Font.Code
Source.MultiLine = true
Source.PlaceholderColor3 = Color3.fromRGB(204, 204, 204)
Source.Text = ""
Source.TextColor3 = Color3.fromRGB(204, 204, 204)
Source.TextSize = 15.000
Source.TextXAlignment = Enum.TextXAlignment.Left
Source.TextYAlignment = Enum.TextYAlignment.Top

Comments_.Name = "Comments_"
Comments_.Parent = Source
Comments_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Comments_.BackgroundTransparency = 1.000
Comments_.Size = UDim2.new(1, 0, 1, 0)
Comments_.ZIndex = 5
Comments_.Font = Enum.Font.Code
Comments_.Text = ""
Comments_.TextColor3 = Color3.fromRGB(59, 200, 59)
Comments_.TextSize = 15.000
Comments_.TextXAlignment = Enum.TextXAlignment.Left
Comments_.TextYAlignment = Enum.TextYAlignment.Top

Globals_.Name = "Globals_"
Globals_.Parent = Source
Globals_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Globals_.BackgroundTransparency = 1.000
Globals_.Size = UDim2.new(1, 0, 1, 0)
Globals_.ZIndex = 5
Globals_.Font = Enum.Font.Code
Globals_.Text = ""
Globals_.TextColor3 = Color3.fromRGB(132, 214, 247)
Globals_.TextSize = 15.000
Globals_.TextXAlignment = Enum.TextXAlignment.Left
Globals_.TextYAlignment = Enum.TextYAlignment.Top

Keywords_.Name = "Keywords_"
Keywords_.Parent = Source
Keywords_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Keywords_.BackgroundTransparency = 1.000
Keywords_.Size = UDim2.new(1, 0, 1, 0)
Keywords_.ZIndex = 5
Keywords_.Font = Enum.Font.Code
Keywords_.Text = ""
Keywords_.TextColor3 = Color3.fromRGB(248, 109, 124)
Keywords_.TextSize = 15.000
Keywords_.TextXAlignment = Enum.TextXAlignment.Left
Keywords_.TextYAlignment = Enum.TextYAlignment.Top

RemoteHighlight_.Name = "RemoteHighlight_"
RemoteHighlight_.Parent = Source
RemoteHighlight_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
RemoteHighlight_.BackgroundTransparency = 1.000
RemoteHighlight_.Size = UDim2.new(1, 0, 1, 0)
RemoteHighlight_.ZIndex = 5
RemoteHighlight_.Font = Enum.Font.Code
RemoteHighlight_.Text = ""
RemoteHighlight_.TextColor3 = Color3.fromRGB(0, 144, 255)
RemoteHighlight_.TextSize = 15.000
RemoteHighlight_.TextXAlignment = Enum.TextXAlignment.Left
RemoteHighlight_.TextYAlignment = Enum.TextYAlignment.Top

Strings_.Name = "Strings_"
Strings_.Parent = Source
Strings_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Strings_.BackgroundTransparency = 1.000
Strings_.Size = UDim2.new(1, 0, 1, 0)
Strings_.ZIndex = 5
Strings_.Font = Enum.Font.Code
Strings_.Text = ""
Strings_.TextColor3 = Color3.fromRGB(173, 241, 149)
Strings_.TextSize = 15.000
Strings_.TextXAlignment = Enum.TextXAlignment.Left
Strings_.TextYAlignment = Enum.TextYAlignment.Top

Tokens_.Name = "Tokens_"
Tokens_.Parent = Source
Tokens_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Tokens_.BackgroundTransparency = 1.000
Tokens_.Size = UDim2.new(1, 0, 1, 0)
Tokens_.ZIndex = 5
Tokens_.Font = Enum.Font.Code
Tokens_.Text = ""
Tokens_.TextColor3 = Color3.fromRGB(255, 255, 255)
Tokens_.TextSize = 15.000
Tokens_.TextXAlignment = Enum.TextXAlignment.Left
Tokens_.TextYAlignment = Enum.TextYAlignment.Top

Numbers_.Name = "Numbers_"
Numbers_.Parent = Source
Numbers_.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Numbers_.BackgroundTransparency = 1.000
Numbers_.Size = UDim2.new(1, 0, 1, 0)
Numbers_.ZIndex = 4
Numbers_.Font = Enum.Font.Code
Numbers_.Text = ""
Numbers_.TextColor3 = Color3.fromRGB(255, 198, 0)
Numbers_.TextSize = 15.000
Numbers_.TextXAlignment = Enum.TextXAlignment.Left
Numbers_.TextYAlignment = Enum.TextYAlignment.Top

Lines.Name = "Lines"
Lines.Parent = EditorFrame
Lines.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Lines.BackgroundTransparency = 1.000
Lines.Size = UDim2.new(0, 30, 1, 0)
Lines.ZIndex = 4
Lines.Font = Enum.Font.Code
Lines.Text = "1"
Lines.TextColor3 = Color3.fromRGB(255, 255, 255)
Lines.TextSize = 15.000
Lines.TextYAlignment = Enum.TextYAlignment.Top

title.Name = "title"
title.Parent = MainFrame
title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
title.BackgroundTransparency = 1.000
title.Position = UDim2.new(0.330062926, 0, 0.00625000056, 0)
title.Size = UDim2.new(0, 200, 0, 22)
title.Font = Enum.Font.SourceSans
title.Text = "Synapse X - vRBX"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextSize = 16.000

list.Name = "list"
list.Parent = MainFrame
list.BackgroundColor3 = Color3.fromRGB(53, 53, 53)
list.BorderSizePixel = 0
list.Position = UDim2.new(0.820970535, 0, 0.100000001, 0)
list.Size = UDim2.new(0, 114, 0, 246)

execute.Name = "execute"
execute.Parent = MainFrame
execute.BackgroundColor3 = Color3.fromRGB(104, 104, 104)
execute.BackgroundTransparency = 0.800
execute.BorderSizePixel = 0
execute.Position = UDim2.new(0.0095389355, 0, 0.887499988, 0)
execute.Size = UDim2.new(0, 92, 0, 30)
execute.Font = Enum.Font.Arial
execute.Text = "Execute"
execute.TextColor3 = Color3.fromRGB(255, 255, 255)
execute.TextSize = 14.000
execute.MouseButton1Click:Connect(function()
    if injected == true then
        loadstring(Source.Text)()
    end
    if injected == false then
        title.Text = "Synapse X - vRBX (not injected! press attach)"
    end
end)

clear.Name = "clear"
clear.Parent = MainFrame
clear.BackgroundColor3 = Color3.fromRGB(104, 104, 104)
clear.BackgroundTransparency = 0.800
clear.BorderSizePixel = 0
clear.Position = UDim2.new(0.154146105, 0, 0.887499988, 0)
clear.Size = UDim2.new(0, 84, 0, 30)
clear.Font = Enum.Font.Arial
clear.Text = "Clear"
clear.TextColor3 = Color3.fromRGB(255, 255, 255)
clear.TextSize = 14.000
clear.MouseButton1Click:Connect(function()
    Source.Text = ""
end)

scripthub.Name = "scripthub"
scripthub.Parent = MainFrame
scripthub.BackgroundColor3 = Color3.fromRGB(104, 104, 104)
scripthub.BackgroundTransparency = 0.800
scripthub.BorderSizePixel = 0
scripthub.Position = UDim2.new(0.871768773, 0, 0.887499988, 0)
scripthub.Size = UDim2.new(0, 79, 0, 30)
scripthub.Font = Enum.Font.Arial
scripthub.Text = "Script Hub"
scripthub.TextColor3 = Color3.fromRGB(255, 255, 255)
scripthub.TextSize = 14.000
scripthub.MouseButton1Click:Connect(function()
    scripthub_2.Visible = true
end)

Attach.Name = "Attach"
Attach.Parent = MainFrame
Attach.BackgroundColor3 = Color3.fromRGB(104, 104, 104)
Attach.BackgroundTransparency = 0.800
Attach.BorderSizePixel = 0
Attach.Position = UDim2.new(0.741144657, 0, 0.887499988, 0)
Attach.Size = UDim2.new(0, 84, 0, 30)
Attach.Font = Enum.Font.Arial
Attach.Text = "Attach"
Attach.TextColor3 = Color3.fromRGB(255, 255, 255)
Attach.TextSize = 14.000
Attach.MouseButton1Click:Connect(function()
    print("hi")
    if injected == true then
        title.Text = "Synapse X - vRBX (already injected!)"
        wait(1)
        title.Text = "Synapse X - vRBX"
    end
    if injected == false then
        title.Text = "Synapse X - vRBX (checking...)"
        wait(0.1)
        title.Text = "Synapse X - vRBX (injecting...)"
        wait(1.5)
        title.Text = "Synapse X - vRBX (checking whitelist...)"
        wait(0.8)
        title.Text = "Synapse X - vRBX (scanning...)"
        wait(0.3)
        title.Text = "Synapse X - vRBX (ready!)"
        wait(0.5)
        title.Text = "Synapse X - vRBX"
        injected = true
    end
end)

title_2.Name = "title"
title_2.Parent = MainFrame
title_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
title_2.BackgroundTransparency = 1.000
title_2.Position = UDim2.new(0.00870821718, 0, 0, 0)
title_2.Size = UDim2.new(0, 18, 0, 24)
title_2.ZIndex = 14
title_2.Image = "http://www.roblox.com/asset/?id=7641125882"
title_2.ImageRectSize = Vector2.new(138, 167)

scripthub_2.Name = "scripthub"
scripthub_2.Parent = SynapseXreal
scripthub_2.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
scripthub_2.BorderSizePixel = 0
scripthub_2.Position = UDim2.new(0.433135211, 0, 0.502979755, 0)
scripthub_2.Size = UDim2.new(0, 290, 0, 305)
scripthub_2.Visible = false
scripthub_2.ZIndex = 100

bar_2.Name = "bar"
bar_2.Parent = scripthub_2
bar_2.BackgroundColor3 = Color3.fromRGB(94, 94, 94)
bar_2.BackgroundTransparency = 0.800
bar_2.BorderSizePixel = 0
bar_2.Position = UDim2.new(0, 0, -0.0029638072, 0)
bar_2.Size = UDim2.new(0, 290, 0, 25)

select.Name = "select"
select.Parent = scripthub_2
select.BackgroundColor3 = Color3.fromRGB(21, 21, 21)
select.BorderSizePixel = 0
select.Position = UDim2.new(0.0299979374, 0, 0.104918033, 0)
select.Size = UDim2.new(0, 82, 0, 264)
select.ZIndex = 110

dex.Name = "dex"
dex.Parent = select
dex.BackgroundColor3 = Color3.fromRGB(0, 32, 61)
dex.BackgroundTransparency = 1.000
dex.BorderColor3 = Color3.fromRGB(0, 0, 49)
dex.BorderSizePixel = 0
dex.Position = UDim2.new(0.0121960752, 0, -1.49011612e-08, 0)
dex.Size = UDim2.new(0, 80, 0, 18)
dex.Font = Enum.Font.SourceSans
dex.Text = " Dark Dex"
dex.TextColor3 = Color3.fromRGB(255, 255, 255)
dex.TextSize = 14.000
dex.TextXAlignment = Enum.TextXAlignment.Left
dex.ZIndex = 110
dex.MouseButton1Click:Connect(function()
    scriptselected = "dex"
end)

esp.Name = "esp"
esp.Parent = select
esp.BackgroundColor3 = Color3.fromRGB(0, 32, 61)
esp.BackgroundTransparency = 1.000
esp.BorderColor3 = Color3.fromRGB(0, 0, 49)
esp.BorderSizePixel = 0
esp.Position = UDim2.new(0.0121960752, 0, 0.0681818053, 0)
esp.Size = UDim2.new(0, 80, 0, 18)
esp.Font = Enum.Font.SourceSans
esp.Text = " Unnamed ESP"
esp.TextColor3 = Color3.fromRGB(255, 255, 255)
esp.TextSize = 14.000
esp.TextXAlignment = Enum.TextXAlignment.Left
esp.ZIndex = 110
esp.MouseButton1Click:Connect(function()
    scriptselected = "esp"
end)

spy.Name = "spy"
spy.Parent = select
spy.BackgroundColor3 = Color3.fromRGB(0, 32, 61)
spy.BackgroundTransparency = 1.000
spy.BorderColor3 = Color3.fromRGB(0, 0, 49)
spy.BorderSizePixel = 0
spy.Position = UDim2.new(0.0121960752, 0, 0.136363626, 0)
spy.Size = UDim2.new(0, 80, 0, 18)
spy.Font = Enum.Font.SourceSans
spy.Text = " Remote Spy"
spy.TextColor3 = Color3.fromRGB(255, 255, 255)
spy.TextSize = 14.000
spy.TextXAlignment = Enum.TextXAlignment.Left
spy.ZIndex = 110
spy.MouseButton1Click:Connect(function()
    scriptselected = "spy"
end)

dumper.Name = "dumper"
dumper.Parent = select
dumper.BackgroundColor3 = Color3.fromRGB(0, 32, 61)
dumper.BackgroundTransparency = 1.000
dumper.BorderColor3 = Color3.fromRGB(0, 0, 49)
dumper.BorderSizePixel = 0
dumper.Position = UDim2.new(0.0121960752, 0, 0.204545438, 0)
dumper.Size = UDim2.new(0, 80, 0, 18)
dumper.Font = Enum.Font.SourceSans
dumper.Text = " SaveInstance"
dumper.TextColor3 = Color3.fromRGB(255, 255, 255)
dumper.TextSize = 14.000
dumper.TextXAlignment = Enum.TextXAlignment.Left
dumper.ZIndex = 110
dumper.MouseButton1Click:Connect(function()
    scriptselected = "dumper"
end)

desc.Name = "desc"
desc.Parent = scripthub_2
desc.BackgroundColor3 = Color3.fromRGB(21, 21, 21)
desc.BorderSizePixel = 0
desc.Position = UDim2.new(0.340342641, 0, 0.613114715, 0)
desc.Size = UDim2.new(0, 184, 0, 69)
desc.ZIndex = 110

descri.Name = "descri"
descri.Parent = desc
descri.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
descri.BackgroundTransparency = 1.000
descri.BorderSizePixel = 0
descri.Position = UDim2.new(0.0112334546, 0, 0, 0)
descri.Size = UDim2.new(0, 181, 0, 69)
descri.Font = Enum.Font.SourceSans
descri.Text = ""
descri.TextColor3 = Color3.fromRGB(255, 255, 255)
descri.TextSize = 15.000
descri.TextWrapped = true
descri.TextXAlignment = Enum.TextXAlignment.Left
descri.TextYAlignment = Enum.TextYAlignment.Top
descri.ZIndex = 125

title_3.Name = "title"
title_3.Parent = scripthub_2
title_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
title_3.BackgroundTransparency = 1.000
title_3.Position = UDim2.new(0.161097407, 0, -0.000307376496, 0)
title_3.Size = UDim2.new(0, 200, 0, 22)
title_3.Font = Enum.Font.SourceSans
title_3.Text = "Synapse X - Script Hub"
title_3.TextColor3 = Color3.fromRGB(255, 255, 255)
title_3.TextSize = 16.000
title_3.ZIndex = 110

execute_2.Name = "execute"
execute_2.Parent = scripthub_2
execute_2.BackgroundColor3 = Color3.fromRGB(104, 104, 104)
execute_2.BackgroundTransparency = 0.800
execute_2.BorderSizePixel = 0
execute_2.Position = UDim2.new(0.34057343, 0, 0.871106505, 0)
execute_2.Size = UDim2.new(0, 92, 0, 30)
execute_2.Font = Enum.Font.Arial
execute_2.Text = "Execute"
execute_2.TextColor3 = Color3.fromRGB(255, 255, 255)
execute_2.TextSize = 14.000
execute_2.ZIndex = 110
execute_2.MouseButton1Click:Connect(function()
    if injected == true then
        if scriptselected == "dex" then
            loadstring(game:HttpGet("https://pastebin.com/raw/J8AX35Fg"))()
        end
        if scriptselected == "spy" then
            loadstring(game:HttpGet("https://pastebin.com/raw/u62hTuwR"))()
        end
        if scriptselected == "dumper" then
            saveinstance()
        end
        if scriptselected == "esp" then
            loadstring(game:HttpGet("https://raw.githubusercontent.com/ic3w0lf22/Unnamed-ESP/master/UnnamedESP.lua"))()
        end
        if scriptselected == "none" then
        end
    end
    if injected == false then
        execute_2.Text = "Not Attached!"
        wait(1)
        execute_2.Text = "Execute"
    end
end)

close.Name = "close"
close.Parent = scripthub_2
close.BackgroundColor3 = Color3.fromRGB(104, 104, 104)
close.BackgroundTransparency = 0.800
close.BorderSizePixel = 0
close.Position = UDim2.new(0.685180664, 0, 0.871106505, 0)
close.Size = UDim2.new(0, 84, 0, 30)
close.Font = Enum.Font.Arial
close.Text = "Close"
close.TextColor3 = Color3.fromRGB(255, 255, 255)
close.TextSize = 14.000
close.ZIndex = 110
close.MouseButton1Click:Connect(function()
    scriptselected = "none"
    scripthub_2.Visible = false
end)

title_4.Name = "title"
title_4.Parent = scripthub_2
title_4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
title_4.BackgroundTransparency = 1.000
title_4.Position = UDim2.new(0.00870821718, 0, 0, 0)
title_4.Size = UDim2.new(0, 18, 0, 24)
title_4.ZIndex = 110
title_4.Image = "http://www.roblox.com/asset/?id=7641125882"
title_4.ImageRectSize = Vector2.new(138, 167)

-- Scripts:

local function SYHNK_fake_script() -- ImageLabel.LocalScript 
    local script = Instance.new('LocalScript', ImageLabel)
    local lua_keywords = {"and", "break", "do", "else", "elseif", "end", "false", "for", "function", "goto", "if", "in", "local", "nil", "not", "or", "repeat", "return", "then", "true", "until", "while"}
    local global_env = {"getrawmetatable", "game", "workspace", "script", "math", "string", "table", "print", "wait", "BrickColor", "Color3", "next", "pairs", "ipairs", "select", "unpack", "Instance", "Vector2", "Vector3", "CFrame", "Ray", "UDim2", "Enum", "assert", "error", "warn", "tick", "loadstring", "_G", "shared", "getfenv", "setfenv", "newproxy", "setmetatable", "getmetatable", "os", "debug", "pcall", "ypcall", "xpcall", "rawequal", "rawset", "rawget", "tonumber", "tostring", "type", "typeof", "_VERSION", "coroutine", "delay", "require", "spawn", "LoadLibrary", "settings", "stats", "time", "UserSettings", "version", "Axes", "ColorSequence", "Faces", "ColorSequenceKeypoint", "NumberRange", "NumberSequence", "NumberSequenceKeypoint", "gcinfo", "elapsedTime", "collectgarbage", "PhysicalProperties", "Rect", "Region3", "Region3int16", "UDim", "Vector2int16", "Vector3int16"}
    local Source = script.Parent.EditorFrame.Source
    local Lines = Source.Parent.Lines
    local Highlight = function(string, keywords)
        local K = {}
        local S = string
        local Token =
            {
                ["="] = true,
                ["."] = true,
                [","] = true,
                ["("] = true,
                [")"] = true,
                ["["] = true,
                ["]"] = true,
                ["{"] = true,
                ["}"] = true,
                [":"] = true,
                ["*"] = true,
                ["/"] = true,
                ["+"] = true,
                ["-"] = true,
                ["%"] = true,
                [";"] = true,
                ["~"] = true
            }
        for i, v in pairs(keywords) do
            K[v] = true
        end
        S = S:gsub(".", function(c)
            if Token[c] ~= nil then
                return "\32"
            else
                return c
            end
        end)
        S = S:gsub("%S+", function(c)
            if K[c] ~= nil then
                return c
            else
                return (" "):rep(#c)
            end
        end)
        return S
    end
    local hTokens = function(string)
        local Token =
            {
                ["="] = true,
                ["."] = true,
                [","] = true,
                ["("] = true,
                [")"] = true,
                ["["] = true,
                ["]"] = true,
                ["{"] = true,
                ["}"] = true,
                [":"] = true,
                ["*"] = true,
                ["/"] = true,
                ["+"] = true,
                ["-"] = true,
                ["%"] = true,
                [";"] = true,
                ["~"] = true
            }
        local A = ""
        string:gsub(".", function(c)
            if Token[c] ~= nil then
                A = A .. c
            elseif c == "\n" then
                A = A .. "\n"
            elseif c == "\t" then
                A = A .. "\t"
            else
                A = A .. "\32"
            end
        end)
        return A
    end

    local strings = function(string)
        local highlight = ""
        local quote = false
        string:gsub(".", function(c)
            if quote == false and c == "\"" then
                quote = true
            elseif quote == true and c == "\"" then
                quote = false
            end
            if quote == false and c == "\"" then
                highlight = highlight .. "\""
            elseif c == "\n" then
                highlight = highlight .. "\n"
            elseif c == "\t" then
                highlight = highlight .. "\t"
            elseif quote == true then
                highlight = highlight .. c
            elseif quote == false then
                highlight = highlight .. "\32"
            end
        end)
        return highlight
    end
    local comments = function(string)
        local ret = ""
        string:gsub("[^\r\n]+", function(c)
            local comm = false
            local i = 0
            c:gsub(".", function(n)
                i = i + 1
                if c:sub(i, i + 1) == "--" then
                    comm = true
                end
                if comm == true then
                    ret = ret .. n
                else
                    ret = ret .. "\32"
                end
            end)
            ret = ret
        end)
        return ret
    end
    local numbers = function(string)
        local A = ""
        string:gsub(".", function(c)
            if tonumber(c) ~= nil then
                A = A .. c
            elseif c == "\n" then
                A = A .. "\n"
            elseif c == "\t" then
                A = A .. "\t"
            else
                A = A .. "\32"
            end
        end)
        return A
    end
    local highlight_source = function(type)
        if type == "Text" then
            Source.Text = Source.Text:gsub("\13", "")
            Source.Text = Source.Text:gsub("\t", "      ")
            local s = Source.Text
            Source.Keywords_.Text = Highlight(s, lua_keywords)
            Source.Globals_.Text = Highlight(s, global_env)
            Source.RemoteHighlight_.Text = Highlight(s, {"FireServer", "fireServer", "InvokeServer", "invokeServer"})
            Source.Tokens_.Text = hTokens(s)
            Source.Numbers_.Text = numbers(s)
            Source.Strings_.Text = strings(s)
            local lin = 1
            s:gsub("\n", function()
                lin = lin + 1
            end)
            Lines.Text = ""
            for i = 1, lin do
                Lines.Text = Lines.Text .. i .. "\n"
            end
        end
    end
    highlight_source("Text")
    Source.Changed:Connect(highlight_source)
end
coroutine.wrap(SYHNK_fake_script)()
local function AMNA_fake_script() -- MainFrame.Dragging 
    local script = Instance.new('LocalScript', MainFrame)

    local UserInputService = game:GetService("UserInputService")

    local gui = script.Parent

    local dragging
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        gui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end

    gui.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = gui.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    gui.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)
end
coroutine.wrap(AMNA_fake_script)()
local function VEUJFP_fake_script() -- scripthub_2.Dragging 
    local script = Instance.new('LocalScript', scripthub_2)

    local UserInputService = game:GetService("UserInputService")

    local gui = script.Parent

    local dragging
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        gui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end

    gui.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = gui.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    gui.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)
end
coroutine.wrap(VEUJFP_fake_script)()
while true do
    wait(0.01)
    if scripthub_2.Visible == true then
        if scriptselected == "none" then
            descri.Text = ""
        end
        if scriptselected == "dex" then
            descri.Text = "A version of the popular Dex explorer with patches specifically for Synapse X."
        end
        if scriptselected == "esp" then
            descri.Text = "ESP Made by ic3w0lf using the Drawing API."
        end
        if scriptselected == "spy" then
            descri.Text = "Allows you to view RemoteEvents and RemoteFunctions called."
        end
        if scriptselected == "dumper" then
            descri.Text = "Dumps the place as a .rbxl file in your workspace folder."
        end
    end
end
end)
Scripts:NewButton("RemoteSpy", "Execute the RemoteSpy", function()
    --[[
    SimpleSpy v2.2 SOURCE

    SimpleSpy is a lightweight penetration testing tool that logs remote calls.

    Credits:
        exx - basically everything
        Frosty - GUI to Lua
]]

-- sheruts down the previous instance of SimpleSpy
if _G.SimpleSpyExecuted and type(_G.SimpleSpyShutdown) == "function" then
	print(pcall(_G.SimpleSpyShutdown))
end

local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local Highlight =
	loadstring(
		game:HttpGet("https://github.com/exxtremestuffs/SimpleSpySource/raw/master/highlight.lua")
	)()

---- GENERATED (kinda sorta mostly) BY GUI to LUA ----

-- Instances:

local SimpleSpy2 = Instance.new("ScreenGui")
local Background = Instance.new("Frame")
local LeftPanel = Instance.new("Frame")
local LogList = Instance.new("ScrollingFrame")
local UIListLayout = Instance.new("UIListLayout")
local RemoteTemplate = Instance.new("Frame")
local ColorBar = Instance.new("Frame")
local Text = Instance.new("TextLabel")
local Button = Instance.new("TextButton")
local RightPanel = Instance.new("Frame")
local CodeBox = Instance.new("Frame")
local ScrollingFrame = Instance.new("ScrollingFrame")
local UIGridLayout = Instance.new("UIGridLayout")
local FunctionTemplate = Instance.new("Frame")
local ColorBar_2 = Instance.new("Frame")
local Text_2 = Instance.new("TextLabel")
local Button_2 = Instance.new("TextButton")
local TopBar = Instance.new("Frame")
local Simple = Instance.new("TextButton")
local CloseButton = Instance.new("TextButton")
local ImageLabel = Instance.new("ImageLabel")
local MaximizeButton = Instance.new("TextButton")
local ImageLabel_2 = Instance.new("ImageLabel")
local MinimizeButton = Instance.new("TextButton")
local ImageLabel_3 = Instance.new("ImageLabel")
local ToolTip = Instance.new("Frame")
local TextLabel = Instance.new("TextLabel")

--Properties:

SimpleSpy2.Name = "SimpleSpy2"
SimpleSpy2.ResetOnSpawn = false

Background.Name = "Background"
Background.Parent = SimpleSpy2
Background.BackgroundColor3 = Color3.new(1, 1, 1)
Background.BackgroundTransparency = 1
Background.Position = UDim2.new(0, 500, 0, 200)
Background.Size = UDim2.new(0, 450, 0, 268)

LeftPanel.Name = "LeftPanel"
LeftPanel.Parent = Background
LeftPanel.BackgroundColor3 = Color3.fromRGB(53, 52, 55)
LeftPanel.BorderSizePixel = 0
LeftPanel.Position = UDim2.new(0, 0, 0, 19)
LeftPanel.Size = UDim2.new(0, 131, 0, 249)

LogList.Name = "LogList"
LogList.Parent = LeftPanel
LogList.Active = true
LogList.BackgroundColor3 = Color3.new(1, 1, 1)
LogList.BackgroundTransparency = 1
LogList.BorderSizePixel = 0
LogList.Position = UDim2.new(0, 0, 0, 9)
LogList.Size = UDim2.new(0, 131, 0, 232)
LogList.CanvasSize = UDim2.new(0, 0, 0, 0)
LogList.ScrollBarThickness = 4

UIListLayout.Parent = LogList
UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder

RemoteTemplate.Name = "RemoteTemplate"
RemoteTemplate.Parent = LogList
RemoteTemplate.BackgroundColor3 = Color3.new(1, 1, 1)
RemoteTemplate.BackgroundTransparency = 1
RemoteTemplate.Size = UDim2.new(0, 117, 0, 27)

ColorBar.Name = "ColorBar"
ColorBar.Parent = RemoteTemplate
ColorBar.BackgroundColor3 = Color3.fromRGB(255, 242, 0)
ColorBar.BorderSizePixel = 0
ColorBar.Position = UDim2.new(0, 0, 0, 1)
ColorBar.Size = UDim2.new(0, 7, 0, 18)
ColorBar.ZIndex = 2

Text.Name = "Text"
Text.Parent = RemoteTemplate
Text.BackgroundColor3 = Color3.new(1, 1, 1)
Text.BackgroundTransparency = 1
Text.Position = UDim2.new(0, 12, 0, 1)
Text.Size = UDim2.new(0, 105, 0, 18)
Text.ZIndex = 2
Text.Font = Enum.Font.SourceSans
Text.Text = "TEXT"
Text.TextColor3 = Color3.new(1, 1, 1)
Text.TextSize = 14
Text.TextXAlignment = Enum.TextXAlignment.Left
Text.TextWrapped = true

Button.Name = "Button"
Button.Parent = RemoteTemplate
Button.BackgroundColor3 = Color3.new(0, 0, 0)
Button.BackgroundTransparency = 0.75
Button.BorderColor3 = Color3.new(1, 1, 1)
Button.Position = UDim2.new(0, 0, 0, 1)
Button.Size = UDim2.new(0, 117, 0, 18)
Button.AutoButtonColor = false
Button.Font = Enum.Font.SourceSans
Button.Text = ""
Button.TextColor3 = Color3.new(0, 0, 0)
Button.TextSize = 14

RightPanel.Name = "RightPanel"
RightPanel.Parent = Background
RightPanel.BackgroundColor3 = Color3.fromRGB(37, 36, 38)
RightPanel.BorderSizePixel = 0
RightPanel.Position = UDim2.new(0, 131, 0, 19)
RightPanel.Size = UDim2.new(0, 319, 0, 249)

CodeBox.Name = "CodeBox"
CodeBox.Parent = RightPanel
CodeBox.BackgroundColor3 = Color3.new(0.0823529, 0.0745098, 0.0784314)
CodeBox.BorderSizePixel = 0
CodeBox.Size = UDim2.new(0, 319, 0, 119)

ScrollingFrame.Parent = RightPanel
ScrollingFrame.Active = true
ScrollingFrame.BackgroundColor3 = Color3.new(1, 1, 1)
ScrollingFrame.BackgroundTransparency = 1
ScrollingFrame.Position = UDim2.new(0, 0, 0.5, 0)
ScrollingFrame.Size = UDim2.new(1, 0, 0.5, -9)
ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
ScrollingFrame.ScrollBarThickness = 4

UIGridLayout.Parent = ScrollingFrame
UIGridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
UIGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
UIGridLayout.CellPadding = UDim2.new(0, 0, 0, 0)
UIGridLayout.CellSize = UDim2.new(0, 94, 0, 27)

FunctionTemplate.Name = "FunctionTemplate"
FunctionTemplate.Parent = ScrollingFrame
FunctionTemplate.BackgroundColor3 = Color3.new(1, 1, 1)
FunctionTemplate.BackgroundTransparency = 1
FunctionTemplate.Size = UDim2.new(0, 117, 0, 23)

ColorBar_2.Name = "ColorBar"
ColorBar_2.Parent = FunctionTemplate
ColorBar_2.BackgroundColor3 = Color3.new(1, 1, 1)
ColorBar_2.BorderSizePixel = 0
ColorBar_2.Position = UDim2.new(0, 7, 0, 10)
ColorBar_2.Size = UDim2.new(0, 7, 0, 18)
ColorBar_2.ZIndex = 3

Text_2.Name = "Text"
Text_2.Parent = FunctionTemplate
Text_2.BackgroundColor3 = Color3.new(1, 1, 1)
Text_2.BackgroundTransparency = 1
Text_2.Position = UDim2.new(0, 19, 0, 10)
Text_2.Size = UDim2.new(0, 69, 0, 18)
Text_2.ZIndex = 2
Text_2.Font = Enum.Font.SourceSans
Text_2.Text = "TEXT"
Text_2.TextColor3 = Color3.new(1, 1, 1)
Text_2.TextSize = 14
Text_2.TextStrokeColor3 = Color3.new(0.145098, 0.141176, 0.14902)
Text_2.TextXAlignment = Enum.TextXAlignment.Left
Text_2.TextWrapped = true

Button_2.Name = "Button"
Button_2.Parent = FunctionTemplate
Button_2.BackgroundColor3 = Color3.new(0, 0, 0)
Button_2.BackgroundTransparency = 0.69999998807907
Button_2.BorderColor3 = Color3.new(1, 1, 1)
Button_2.Position = UDim2.new(0, 7, 0, 10)
Button_2.Size = UDim2.new(0, 80, 0, 18)
Button_2.AutoButtonColor = false
Button_2.Font = Enum.Font.SourceSans
Button_2.Text = ""
Button_2.TextColor3 = Color3.new(0, 0, 0)
Button_2.TextSize = 14

TopBar.Name = "TopBar"
TopBar.Parent = Background
TopBar.BackgroundColor3 = Color3.fromRGB(37, 35, 38)
TopBar.BorderSizePixel = 0
TopBar.Size = UDim2.new(0, 450, 0, 19)

Simple.Name = "Simple"
Simple.Parent = TopBar
Simple.BackgroundColor3 = Color3.new(1, 1, 1)
Simple.AutoButtonColor = false
Simple.BackgroundTransparency = 1
Simple.Position = UDim2.new(0, 5, 0, 0)
Simple.Size = UDim2.new(0, 57, 0, 18)
Simple.Font = Enum.Font.SourceSansBold
Simple.Text = "SimpleSpy"
Simple.TextColor3 = Color3.new(1, 1, 1)
Simple.TextSize = 14
Simple.TextXAlignment = Enum.TextXAlignment.Left

CloseButton.Name = "CloseButton"
CloseButton.Parent = TopBar
CloseButton.BackgroundColor3 = Color3.new(0.145098, 0.141176, 0.14902)
CloseButton.BorderSizePixel = 0
CloseButton.Position = UDim2.new(1, -19, 0, 0)
CloseButton.Size = UDim2.new(0, 19, 0, 19)
CloseButton.Font = Enum.Font.SourceSans
CloseButton.Text = ""
CloseButton.TextColor3 = Color3.new(0, 0, 0)
CloseButton.TextSize = 14

ImageLabel.Parent = CloseButton
ImageLabel.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel.BackgroundTransparency = 1
ImageLabel.Position = UDim2.new(0, 5, 0, 5)
ImageLabel.Size = UDim2.new(0, 9, 0, 9)
ImageLabel.Image = "http://www.roblox.com/asset/?id=5597086202"

MaximizeButton.Name = "MaximizeButton"
MaximizeButton.Parent = TopBar
MaximizeButton.BackgroundColor3 = Color3.new(0.145098, 0.141176, 0.14902)
MaximizeButton.BorderSizePixel = 0
MaximizeButton.Position = UDim2.new(1, -38, 0, 0)
MaximizeButton.Size = UDim2.new(0, 19, 0, 19)
MaximizeButton.Font = Enum.Font.SourceSans
MaximizeButton.Text = ""
MaximizeButton.TextColor3 = Color3.new(0, 0, 0)
MaximizeButton.TextSize = 14

ImageLabel_2.Parent = MaximizeButton
ImageLabel_2.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel_2.BackgroundTransparency = 1
ImageLabel_2.Position = UDim2.new(0, 5, 0, 5)
ImageLabel_2.Size = UDim2.new(0, 9, 0, 9)
ImageLabel_2.Image = "http://www.roblox.com/asset/?id=5597108117"

MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Parent = TopBar
MinimizeButton.BackgroundColor3 = Color3.new(0.145098, 0.141176, 0.14902)
MinimizeButton.BorderSizePixel = 0
MinimizeButton.Position = UDim2.new(1, -57, 0, 0)
MinimizeButton.Size = UDim2.new(0, 19, 0, 19)
MinimizeButton.Font = Enum.Font.SourceSans
MinimizeButton.Text = ""
MinimizeButton.TextColor3 = Color3.new(0, 0, 0)
MinimizeButton.TextSize = 14

ImageLabel_3.Parent = MinimizeButton
ImageLabel_3.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel_3.BackgroundTransparency = 1
ImageLabel_3.Position = UDim2.new(0, 5, 0, 5)
ImageLabel_3.Size = UDim2.new(0, 9, 0, 9)
ImageLabel_3.Image = "http://www.roblox.com/asset/?id=5597105827"

ToolTip.Name = "ToolTip"
ToolTip.Parent = SimpleSpy2
ToolTip.BackgroundColor3 = Color3.fromRGB(26, 26, 26)
ToolTip.BackgroundTransparency = 0.1
ToolTip.BorderColor3 = Color3.new(1, 1, 1)
ToolTip.Size = UDim2.new(0, 200, 0, 50)
ToolTip.ZIndex = 3
ToolTip.Visible = false

TextLabel.Parent = ToolTip
TextLabel.BackgroundColor3 = Color3.new(1, 1, 1)
TextLabel.BackgroundTransparency = 1
TextLabel.Position = UDim2.new(0, 2, 0, 2)
TextLabel.Size = UDim2.new(0, 196, 0, 46)
TextLabel.ZIndex = 3
TextLabel.Font = Enum.Font.SourceSans
TextLabel.Text = "This is some slightly longer text."
TextLabel.TextColor3 = Color3.new(1, 1, 1)
TextLabel.TextSize = 14
TextLabel.TextWrapped = true
TextLabel.TextXAlignment = Enum.TextXAlignment.Left
TextLabel.TextYAlignment = Enum.TextYAlignment.Top

-------------------------------------------------------------------------------
-- init
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ContentProvider = game:GetService("ContentProvider")
local TextService = game:GetService("TextService")
local Mouse

local selectedColor = Color3.new(0.321569, 0.333333, 1)
local deselectedColor = Color3.new(0.8, 0.8, 0.8)
--- So things are descending
local layoutOrderNum = 999999999
--- Whether or not the gui is closing
local mainClosing = false
--- Whether or not the gui is closed (defaults to false)
local closed = false
--- Whether or not the sidebar is closing
local sideClosing = false
--- Whether or not the sidebar is closed (defaults to true but opens automatically on remote selection)
local sideClosed = false
--- Whether or not the code box is maximized (defaults to false)
local maximized = false
--- The event logs to be read from
local logs = {}
--- The event currently selected.Log (defaults to nil)
local selected = nil
--- The blacklist (can be a string name or the Remote Instance)
local blacklist = {}
--- The block list (can be a string name or the Remote Instance)
local blocklist = {}
--- Whether or not to add getNil function
local getNil = false
--- Array of remotes (and original functions) connected to
local connectedRemotes = {}
--- True = hookfunction, false = namecall
local toggle = false
local gm
local original
--- used to prevent recursives
local prevTables = {}
--- holds logs (for deletion)
local remoteLogs = {}
--- used for hookfunction
local remoteEvent = Instance.new("RemoteEvent")
--- used for hookfunction
local remoteFunction = Instance.new("RemoteFunction")
local originalEvent = remoteEvent.FireServer
local originalFunction = remoteFunction.InvokeServer
--- the maximum amount of remotes allowed in logs
_G.SIMPLESPYCONFIG_MaxRemotes = 500
--- how many spaces to indent
local indent = 4
--- used for task scheduler
local scheduled = {}
--- RBXScriptConnect of the task scheduler
local schedulerconnect
local SimpleSpy = {}
local topstr = ""
local bottomstr = ""
local remotesFadeIn
local rightFadeIn
local codebox
local p
local getnilrequired = false

-- autoblock variables
local autoblock = false
local history = {}
local excluding = {}

-- function info variables
local funcEnabled = true

-- remote hooking/connecting api variables
local remoteSignals = {}
local remoteHooks = {}

-- original mouse icon
local oldIcon

-- if mouse inside gui
local mouseInGui = false

-- handy array of RBXScriptConnections to disconnect on shutdown
local connections = {}

-- whether or not SimpleSpy uses 'getcallingscript()' to get the script (default is false because detection)
local useGetCallingScript = false

--- used to enable/disable SimpleSpy's keyToString for remotes
local keyToString = false

-- determines whether return values are recorded
local recordReturnValues = false

-- functions

--- Converts arguments to a string and generates code that calls the specified method with them, recommended to be used in conjunction with ValueToString (method must be a string, e.g. `game:GetService("ReplicatedStorage").Remote.remote:FireServer`)
--- @param method string
--- @param args any[]
--- @return string
function SimpleSpy:ArgsToString(method, args)
	assert(typeof(method) == "string", "string expected, got " .. typeof(method))
	assert(typeof(args) == "table", "table expected, got " .. typeof(args))
	return v2v({ args = args }) .. "\n\n" .. method .. "(unpack(args))"
end

--- Converts a value to variables with the specified index as the variable name (if nil/invalid then the name will be assigned automatically)
--- @param t any[]
--- @return string
function SimpleSpy:TableToVars(t)
	assert(typeof(t) == "table", "table expected, got " .. typeof(t))
	return v2v(t)
end

--- Converts a value to a variable with the specified `variablename` (if nil/invalid then the name will be assigned automatically)
--- @param value any
--- @return string
function SimpleSpy:ValueToVar(value, variablename)
	assert(variablename == nil or typeof(variablename) == "string", "string expected, got " .. typeof(variablename))
	if not variablename then
		variablename = 1
	end
	return v2v({ [variablename] = value })
end

--- Converts any value to a string, cannot preserve function contents
--- @param value any
--- @return string
function SimpleSpy:ValueToString(value)
	return v2s(value)
end

--- Generates the simplespy function info
--- @param func function
--- @return string
function SimpleSpy:GetFunctionInfo(func)
	assert(typeof(func) == "function", "Instance expected, got " .. typeof(func))
	warn("Function info currently unavailable due to crashing in Synapse X")
	return v2v({ functionInfo = {
		info = debug.getinfo(func),
		constants = debug.getconstants(func),
	} })
end

--- Gets the ScriptSignal for a specified remote being fired
--- @param remote Instance
function SimpleSpy:GetRemoteFiredSignal(remote)
	assert(typeof(remote) == "Instance", "Instance expected, got " .. typeof(remote))
	if not remoteSignals[remote] then
		remoteSignals[remote] = newSignal()
	end
	return remoteSignals[remote]
end

--- Allows for direct hooking of remotes **THIS CAN BE VERY DANGEROUS**
--- @param remote Instance
--- @param f function
function SimpleSpy:HookRemote(remote, f)
	assert(typeof(remote) == "Instance", "Instance expected, got " .. typeof(remote))
	assert(typeof(f) == "function", "function expected, got " .. typeof(f))
	remoteHooks[remote] = f
end

--- Blocks the specified remote instance/string
--- @param remote any
function SimpleSpy:BlockRemote(remote)
	assert(
		typeof(remote) == "Instance" or typeof(remote) == "string",
		"Instance | string expected, got " .. typeof(remote)
	)
	blocklist[remote] = true
end

--- Excludes the specified remote from logs (instance/string)
--- @param remote any
function SimpleSpy:ExcludeRemote(remote)
	assert(
		typeof(remote) == "Instance" or typeof(remote) == "string",
		"Instance | string expected, got " .. typeof(remote)
	)
	blacklist[remote] = true
end

--- Creates a new ScriptSignal that can be connected to and fired
--- @return table
function newSignal()
	local connected = {}
	return {
		Connect = function(self, f)
			assert(connected, "Signal is closed")
			connected[tostring(f)] = f
			return {
				Connected = true,
				Disconnect = function(self)
					if not connected then
						warn("Signal is already closed")
					end
					self.Connected = false
					connected[tostring(f)] = nil
				end,
			}
		end,
		Wait = function(self)
			local thread = coroutine.running()
			local connection
			connection = self:Connect(function()
				connection:Disconnect()
				if coroutine.status(thread) == "suspended" then
					coroutine.resume(thread)
				end
			end)
			coroutine.yield()
		end,
		Fire = function(self, ...)
			for _, f in pairs(connected) do
				coroutine.wrap(f)(...)
			end
		end,
	}
end

--- Prevents remote spam from causing lag (clears logs after `_G.SIMPLESPYCONFIG_MaxRemotes` or 500 remotes)
function clean()
	local max = _G.SIMPLESPYCONFIG_MaxRemotes
	if not typeof(max) == "number" and math.floor(max) ~= max then
		max = 500
	end
	if #remoteLogs > max then
		for i = 100, #remoteLogs do
			local v = remoteLogs[i]
			if typeof(v[1]) == "RBXScriptConnection" then
				v[1]:Disconnect()
			end
			if typeof(v[2]) == "Instance" then
				v[2]:Destroy()
			end
		end
		local newLogs = {}
		for i = 1, 100 do
			table.insert(newLogs, remoteLogs[i])
		end
		remoteLogs = newLogs
	end
end

--- Scales the ToolTip to fit containing text
function scaleToolTip()
	local size = TextService:GetTextSize(
		TextLabel.Text,
		TextLabel.TextSize,
		TextLabel.Font,
		Vector2.new(196, math.huge)
	)
	TextLabel.Size = UDim2.new(0, size.X, 0, size.Y)
	ToolTip.Size = UDim2.new(0, size.X + 4, 0, size.Y + 4)
end

--- Executed when the toggle button (the SimpleSpy logo) is hovered over
function onToggleButtonHover()
	if not toggle then
		TweenService:Create(Simple, TweenInfo.new(0.5), { TextColor3 = Color3.fromRGB(252, 51, 51) }):Play()
	else
		TweenService:Create(Simple, TweenInfo.new(0.5), { TextColor3 = Color3.fromRGB(68, 206, 91) }):Play()
	end
end

--- Executed when the toggle button is unhovered over
function onToggleButtonUnhover()
	TweenService:Create(Simple, TweenInfo.new(0.5), { TextColor3 = Color3.fromRGB(255, 255, 255) }):Play()
end

--- Executed when the X button is hovered over
function onXButtonHover()
	TweenService:Create(CloseButton, TweenInfo.new(0.2), { BackgroundColor3 = Color3.fromRGB(255, 60, 60) }):Play()
end

--- Executed when the X button is unhovered over
function onXButtonUnhover()
	TweenService:Create(CloseButton, TweenInfo.new(0.2), { BackgroundColor3 = Color3.fromRGB(37, 36, 38) }):Play()
end

--- Toggles the remote spy method (when button clicked)
function onToggleButtonClick()
	if toggle then
		TweenService:Create(Simple, TweenInfo.new(0.5), { TextColor3 = Color3.fromRGB(252, 51, 51) }):Play()
	else
		TweenService:Create(Simple, TweenInfo.new(0.5), { TextColor3 = Color3.fromRGB(68, 206, 91) }):Play()
	end
	toggleSpyMethod()
end

--- Reconnects bringBackOnResize if the current viewport changes and also connects it initially
function connectResize()
	local lastCam = workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(bringBackOnResize)
	workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		lastCam:Disconnect()
		if workspace.CurrentCamera then
			lastCam = workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(bringBackOnResize)
		end
	end)
end

--- Brings gui back if it gets lost offscreen (connected to the camera viewport changing)
function bringBackOnResize()
	validateSize()
	if sideClosed then
		minimizeSize()
	else
		maximizeSize()
	end
	local currentX = Background.AbsolutePosition.X
	local currentY = Background.AbsolutePosition.Y
	local viewportSize = workspace.CurrentCamera.ViewportSize
	if (currentX < 0) or (currentX > (viewportSize.X - (sideClosed and 131 or Background.AbsoluteSize.X))) then
		if currentX < 0 then
			currentX = 0
		else
			currentX = viewportSize.X - (sideClosed and 131 or Background.AbsoluteSize.X)
		end
	end
	if (currentY < 0) or (currentY > (viewportSize.Y - (closed and 19 or Background.AbsoluteSize.Y) - 36)) then
		if currentY < 0 then
			currentY = 0
		else
			currentY = viewportSize.Y - (closed and 19 or Background.AbsoluteSize.Y) - 36
		end
	end
	TweenService.Create(
		TweenService,
		Background,
		TweenInfo.new(0.1),
		{ Position = UDim2.new(0, currentX, 0, currentY) }
	):Play()
end

--- Drags gui (so long as mouse is held down)
--- @param input InputObject
function onBarInput(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		local lastPos = UserInputService.GetMouseLocation(UserInputService)
		local mainPos = Background.AbsolutePosition
		local offset = mainPos - lastPos
		local currentPos = offset + lastPos
		RunService.BindToRenderStep(RunService, "drag", 1, function()
			local newPos = UserInputService.GetMouseLocation(UserInputService)
			if newPos ~= lastPos then
				local currentX = (offset + newPos).X
				local currentY = (offset + newPos).Y
				local viewportSize = workspace.CurrentCamera.ViewportSize
				if
					(currentX < 0 and currentX < currentPos.X)
					or (
						currentX > (viewportSize.X - (sideClosed and 131 or TopBar.AbsoluteSize.X))
						and currentX > currentPos.X
					)
				then
					if currentX < 0 then
						currentX = 0
					else
						currentX = viewportSize.X - (sideClosed and 131 or TopBar.AbsoluteSize.X)
					end
				end
				if
					(currentY < 0 and currentY < currentPos.Y)
					or (
						currentY > (viewportSize.Y - (closed and 19 or Background.AbsoluteSize.Y) - 36)
						and currentY > currentPos.Y
					)
				then
					if currentY < 0 then
						currentY = 0
					else
						currentY = viewportSize.Y - (closed and 19 or Background.AbsoluteSize.Y) - 36
					end
				end
				currentPos = Vector2.new(currentX, currentY)
				lastPos = newPos
				TweenService.Create(
					TweenService,
					Background,
					TweenInfo.new(0.1),
					{ Position = UDim2.new(0, currentPos.X, 0, currentPos.Y) }
				):Play()
			end
			-- if input.UserInputState ~= Enum.UserInputState.Begin then
			--     RunService.UnbindFromRenderStep(RunService, "drag")
			-- end
		end)
		table.insert(
			connections,
			UserInputService.InputEnded:Connect(function(inputE)
				if input == inputE then
					RunService:UnbindFromRenderStep("drag")
				end
			end)
		)
	end
end

--- Fades out the table of elements (and makes them invisible), returns a function to make them visible again
function fadeOut(elements)
	local data = {}
	for _, v in pairs(elements) do
		if typeof(v) == "Instance" and v:IsA("GuiObject") and v.Visible then
			coroutine.wrap(function()
				data[v] = {
					BackgroundTransparency = v.BackgroundTransparency,
				}
				TweenService:Create(v, TweenInfo.new(0.5), { BackgroundTransparency = 1 }):Play()
				if v:IsA("TextBox") or v:IsA("TextButton") or v:IsA("TextLabel") then
					data[v].TextTransparency = v.TextTransparency
					TweenService:Create(v, TweenInfo.new(0.5), { TextTransparency = 1 }):Play()
				elseif v:IsA("ImageButton") or v:IsA("ImageLabel") then
					data[v].ImageTransparency = v.ImageTransparency
					TweenService:Create(v, TweenInfo.new(0.5), { ImageTransparency = 1 }):Play()
				end
				wait(0.5)
				v.Visible = false
				for i, x in pairs(data[v]) do
					v[i] = x
				end
				data[v] = true
			end)()
		end
	end
	return function()
		for i, _ in pairs(data) do
			coroutine.wrap(function()
				local properties = {
					BackgroundTransparency = i.BackgroundTransparency,
				}
				i.BackgroundTransparency = 1
				TweenService
					:Create(i, TweenInfo.new(0.5), { BackgroundTransparency = properties.BackgroundTransparency })
					:Play()
				if i:IsA("TextBox") or i:IsA("TextButton") or i:IsA("TextLabel") then
					properties.TextTransparency = i.TextTransparency
					i.TextTransparency = 1
					TweenService
						:Create(i, TweenInfo.new(0.5), { TextTransparency = properties.TextTransparency })
						:Play()
				elseif i:IsA("ImageButton") or i:IsA("ImageLabel") then
					properties.ImageTransparency = i.ImageTransparency
					i.ImageTransparency = 1
					TweenService
						:Create(i, TweenInfo.new(0.5), { ImageTransparency = properties.ImageTransparency })
						:Play()
				end
				i.Visible = true
			end)()
		end
	end
end

--- Expands and minimizes the gui (closed is the toggle boolean)
function toggleMinimize(override)
	if mainClosing and not override or maximized then
		return
	end
	mainClosing = true
	closed = not closed
	if closed then
		if not sideClosed then
			toggleSideTray(true)
		end
		LeftPanel.Visible = true
		TweenService:Create(LeftPanel, TweenInfo.new(0.5), { Size = UDim2.new(0, 131, 0, 0) }):Play()
		wait(0.5)
		remotesFadeIn = fadeOut(LeftPanel:GetDescendants())
		wait(0.5)
	else
		TweenService:Create(LeftPanel, TweenInfo.new(0.5), { Size = UDim2.new(0, 131, 0, 249) }):Play()
		wait(0.5)
		if remotesFadeIn then
			remotesFadeIn()
			remotesFadeIn = nil
		end
		bringBackOnResize()
	end
	mainClosing = false
end

--- Expands and minimizes the sidebar (sideClosed is the toggle boolean)
function toggleSideTray(override)
	if sideClosing and not override or maximized then
		return
	end
	sideClosing = true
	sideClosed = not sideClosed
	if sideClosed then
		rightFadeIn = fadeOut(RightPanel:GetDescendants())
		wait(0.5)
		minimizeSize(0.5)
		wait(0.5)
		RightPanel.Visible = false
	else
		if closed then
			toggleMinimize(true)
		end
		RightPanel.Visible = true
		maximizeSize(0.5)
		wait(0.5)
		if rightFadeIn then
			rightFadeIn()
		end
		bringBackOnResize()
	end
	sideClosing = false
end

--- Expands code box to fit screen for more convenient viewing
function toggleMaximize()
	if not sideClosed and not maximized then
		maximized = true
		local disable = Instance.new("TextButton")
		local prevSize = UDim2.new(0, CodeBox.AbsoluteSize.X, 0, CodeBox.AbsoluteSize.Y)
		local prevPos = UDim2.new(0, CodeBox.AbsolutePosition.X, 0, CodeBox.AbsolutePosition.Y)
		disable.Size = UDim2.new(1, 0, 1, 0)
		disable.BackgroundColor3 = Color3.new()
		disable.BorderSizePixel = 0
		disable.Text = 0
		disable.ZIndex = 3
		disable.BackgroundTransparency = 1
		disable.AutoButtonColor = false
		CodeBox.ZIndex = 4
		CodeBox.Position = prevPos
		CodeBox.Size = prevSize
		TweenService
			:Create(
				CodeBox,
				TweenInfo.new(0.5),
				{ Size = UDim2.new(0.5, 0, 0.5, 0), Position = UDim2.new(0.25, 0, 0.25, 0) }
			)
			:Play()
		TweenService:Create(disable, TweenInfo.new(0.5), { BackgroundTransparency = 0.5 }):Play()
		disable.MouseButton1Click:Connect(function()
			if
				UserInputService:GetMouseLocation().Y + 36 >= CodeBox.AbsolutePosition.Y
				and UserInputService:GetMouseLocation().Y + 36 <= CodeBox.AbsolutePosition.Y + CodeBox.AbsoluteSize.Y
				and UserInputService:GetMouseLocation().X >= CodeBox.AbsolutePosition.X
				and UserInputService:GetMouseLocation().X <= CodeBox.AbsolutePosition.X + CodeBox.AbsoluteSize.X
			then
				return
			end
			TweenService:Create(CodeBox, TweenInfo.new(0.5), { Size = prevSize, Position = prevPos }):Play()
			TweenService:Create(disable, TweenInfo.new(0.5), { BackgroundTransparency = 1 }):Play()
			maximized = false
			wait(0.5)
			disable:Destroy()
			CodeBox.Size = UDim2.new(1, 0, 0.5, 0)
			CodeBox.Position = UDim2.new(0, 0, 0, 0)
			CodeBox.ZIndex = 0
		end)
	end
end

--- Checks if cursor is within resize range
--- @param p Vector2
function isInResizeRange(p)
	local relativeP = p - Background.AbsolutePosition
	local range = 5
	if
		relativeP.X >= TopBar.AbsoluteSize.X - range
		and relativeP.Y >= Background.AbsoluteSize.Y - range
		and relativeP.X <= TopBar.AbsoluteSize.X
		and relativeP.Y <= Background.AbsoluteSize.Y
	then
		return true, "B"
	elseif relativeP.X >= TopBar.AbsoluteSize.X - range and relativeP.X <= Background.AbsoluteSize.X then
		return true, "X"
	elseif relativeP.Y >= Background.AbsoluteSize.Y - range and relativeP.Y <= Background.AbsoluteSize.Y then
		return true, "Y"
	end
	return false
end

--- Checks if cursor is within dragging range
--- @param p Vector2
function isInDragRange(p)
	local relativeP = p - Background.AbsolutePosition
	if
		relativeP.X <= TopBar.AbsoluteSize.X - CloseButton.AbsoluteSize.X * 3
		and relativeP.X >= 0
		and relativeP.Y <= TopBar.AbsoluteSize.Y
		and relativeP.Y >= 0
	then
		return true
	end
	return false
end

--- Called when mouse enters SimpleSpy
function mouseEntered()
	local existingCursor = SimpleSpy2:FindFirstChild("Cursor")
	while existingCursor do
		existingCursor:Destroy()
		existingCursor = SimpleSpy2:FindFirstChild("Cursor")
	end
	local customCursor = Instance.new("ImageLabel")
	customCursor.Name = "Cursor"
	customCursor.Size = UDim2.fromOffset(200, 200)
	customCursor.ZIndex = 1e5
	customCursor.BackgroundTransparency = 1
	customCursor.Image = ""
	customCursor.Parent = SimpleSpy2
	UserInputService.OverrideMouseIconBehavior = Enum.OverrideMouseIconBehavior.ForceHide
	RunService:BindToRenderStep("SIMPLESPY_CURSOR", 1, function()
		if mouseInGui and _G.SimpleSpyExecuted then
			local mouseLocation = UserInputService:GetMouseLocation() - Vector2.new(0, 36)
			customCursor.Position = UDim2.fromOffset(
				mouseLocation.X - customCursor.AbsoluteSize.X / 2,
				mouseLocation.Y - customCursor.AbsoluteSize.Y / 2
			)
			local inRange, type = isInResizeRange(mouseLocation)
			if inRange and not sideClosed and not closed then
				customCursor.Image = type == "B" and "rbxassetid://6065821980"
					or type == "X" and "rbxassetid://6065821086"
					or type == "Y" and "rbxassetid://6065821596"
			elseif inRange and not closed and type == "Y" or type == "B" then
				customCursor.Image = "rbxassetid://6065821596"
			elseif customCursor.Image ~= "rbxassetid://6065775281" then
				customCursor.Image = "rbxassetid://6065775281"
			end
		else
			UserInputService.OverrideMouseIconBehavior = Enum.OverrideMouseIconBehavior.None
			customCursor:Destroy()
			RunService:UnbindFromRenderStep("SIMPLESPY_CURSOR")
		end
	end)
end

--- Called when mouse moves
function mouseMoved()
	local mousePos = UserInputService:GetMouseLocation() - Vector2.new(0, 36)
	if
		not closed
		and mousePos.X >= TopBar.AbsolutePosition.X
		and mousePos.X <= TopBar.AbsolutePosition.X + TopBar.AbsoluteSize.X
		and mousePos.Y >= Background.AbsolutePosition.Y
		and mousePos.Y <= Background.AbsolutePosition.Y + Background.AbsoluteSize.Y
	then
		if not mouseInGui then
			mouseInGui = true
			mouseEntered()
		end
	else
		mouseInGui = false
	end
end

--- Adjusts the ui elements to the 'Maximized' size
function maximizeSize(speed)
	if not speed then
		speed = 0.05
	end
	TweenService
		:Create(
			LeftPanel,
			TweenInfo.new(speed),
			{ Size = UDim2.fromOffset(LeftPanel.AbsoluteSize.X, Background.AbsoluteSize.Y - TopBar.AbsoluteSize.Y) }
		)
		:Play()
	TweenService
		:Create(RightPanel, TweenInfo.new(speed), {
			Size = UDim2.fromOffset(
				Background.AbsoluteSize.X - LeftPanel.AbsoluteSize.X,
				Background.AbsoluteSize.Y - TopBar.AbsoluteSize.Y
			),
		})
		:Play()
	TweenService
		:Create(
			TopBar,
			TweenInfo.new(speed),
			{ Size = UDim2.fromOffset(Background.AbsoluteSize.X, TopBar.AbsoluteSize.Y) }
		)
		:Play()
	TweenService
		:Create(ScrollingFrame, TweenInfo.new(speed), {
			Size = UDim2.fromOffset(Background.AbsoluteSize.X - LeftPanel.AbsoluteSize.X, 110),
			Position = UDim2.fromOffset(0, Background.AbsoluteSize.Y - 119 - TopBar.AbsoluteSize.Y),
		})
		:Play()
	TweenService
		:Create(CodeBox, TweenInfo.new(speed), {
			Size = UDim2.fromOffset(
				Background.AbsoluteSize.X - LeftPanel.AbsoluteSize.X,
				Background.AbsoluteSize.Y - 119 - TopBar.AbsoluteSize.Y
			),
		})
		:Play()
	TweenService
		:Create(
			LogList,
			TweenInfo.new(speed),
			{ Size = UDim2.fromOffset(LogList.AbsoluteSize.X, Background.AbsoluteSize.Y - TopBar.AbsoluteSize.Y - 18) }
		)
		:Play()
end

--- Adjusts the ui elements to close the side
function minimizeSize(speed)
	if not speed then
		speed = 0.05
	end
	TweenService
		:Create(
			LeftPanel,
			TweenInfo.new(speed),
			{ Size = UDim2.fromOffset(LeftPanel.AbsoluteSize.X, Background.AbsoluteSize.Y - TopBar.AbsoluteSize.Y) }
		)
		:Play()
	TweenService
		:Create(
			RightPanel,
			TweenInfo.new(speed),
			{ Size = UDim2.fromOffset(0, Background.AbsoluteSize.Y - TopBar.AbsoluteSize.Y) }
		)
		:Play()
	TweenService
		:Create(
			TopBar,
			TweenInfo.new(speed),
			{ Size = UDim2.fromOffset(LeftPanel.AbsoluteSize.X, TopBar.AbsoluteSize.Y) }
		)
		:Play()
	TweenService
		:Create(ScrollingFrame, TweenInfo.new(speed), {
			Size = UDim2.fromOffset(0, 119),
			Position = UDim2.fromOffset(0, Background.AbsoluteSize.Y - 119 - TopBar.AbsoluteSize.Y),
		})
		:Play()
	TweenService
		:Create(
			CodeBox,
			TweenInfo.new(speed),
			{ Size = UDim2.fromOffset(0, Background.AbsoluteSize.Y - 119 - TopBar.AbsoluteSize.Y) }
		)
		:Play()
	TweenService
		:Create(
			LogList,
			TweenInfo.new(speed),
			{ Size = UDim2.fromOffset(LogList.AbsoluteSize.X, Background.AbsoluteSize.Y - TopBar.AbsoluteSize.Y - 18) }
		)
		:Play()
end

--- Ensures size is within screensize limitations
function validateSize()
	local x, y = Background.AbsoluteSize.X, Background.AbsoluteSize.Y
	local screenSize = workspace.CurrentCamera.ViewportSize
	if x + Background.AbsolutePosition.X > screenSize.X then
		if screenSize.X - Background.AbsolutePosition.X >= 450 then
			x = screenSize.X - Background.AbsolutePosition.X
		else
			x = 450
		end
	elseif y + Background.AbsolutePosition.Y > screenSize.Y then
		if screenSize.X - Background.AbsolutePosition.Y >= 268 then
			y = screenSize.Y - Background.AbsolutePosition.Y
		else
			y = 268
		end
	end
	Background.Size = UDim2.fromOffset(x, y)
end

--- Called on user input while mouse in 'Background' frame
--- @param input InputObject
function backgroundUserInput(input)
	local mousePos = UserInputService:GetMouseLocation() - Vector2.new(0, 36)
	local inResizeRange, type = isInResizeRange(mousePos)
	if input.UserInputType == Enum.UserInputType.MouseButton1 and inResizeRange then
		local lastPos = UserInputService:GetMouseLocation()
		local offset = Background.AbsoluteSize - lastPos
		local currentPos = lastPos + offset
		RunService:BindToRenderStep("SIMPLESPY_RESIZE", 1, function()
			local newPos = UserInputService:GetMouseLocation()
			if newPos ~= lastPos then
				local currentX = (newPos + offset).X
				local currentY = (newPos + offset).Y
				if currentX < 450 then
					currentX = 450
				end
				if currentY < 268 then
					currentY = 268
				end
				currentPos = Vector2.new(currentX, currentY)
				Background.Size = UDim2.fromOffset(
					(not sideClosed and not closed and (type == "X" or type == "B")) and currentPos.X
						or Background.AbsoluteSize.X,
					(--[[(not sideClosed or currentPos.X <= LeftPanel.AbsolutePosition.X + LeftPanel.AbsoluteSize.X) and]]not closed and (type == "Y" or type == "B"))
							and currentPos.Y
						or Background.AbsoluteSize.Y
				)
				validateSize()
				if sideClosed then
					minimizeSize()
				else
					maximizeSize()
				end
				lastPos = newPos
			end
		end)
		table.insert(
			connections,
			UserInputService.InputEnded:Connect(function(inputE)
				if input == inputE then
					RunService:UnbindFromRenderStep("SIMPLESPY_RESIZE")
				end
			end)
		)
	elseif isInDragRange(mousePos) then
		onBarInput(input)
	end
end

--- Gets the player an instance is descended from
function getPlayerFromInstance(instance)
	for _, v in pairs(Players:GetPlayers()) do
		if v.Character and (instance:IsDescendantOf(v.Character) or instance == v.Character) then
			return v
		end
	end
end

--- Runs on MouseButton1Click of an event frame
function eventSelect(frame)
	if selected and selected.Log and selected.Log.Button then
		TweenService
			:Create(selected.Log.Button, TweenInfo.new(0.5), { BackgroundColor3 = Color3.fromRGB(0, 0, 0) })
			:Play()
		selected = nil
	end
	for _, v in pairs(logs) do
		if frame == v.Log then
			selected = v
		end
	end
	if selected and selected.Log then
		TweenService
			:Create(frame.Button, TweenInfo.new(0.5), { BackgroundColor3 = Color3.fromRGB(92, 126, 229) })
			:Play()
		codebox:setRaw(selected.GenScript)
	end
	if sideClosed then
		toggleSideTray()
	end
end

--- Updates the canvas size to fit the current amount of function buttons
function updateFunctionCanvas()
	ScrollingFrame.CanvasSize = UDim2.fromOffset(UIGridLayout.AbsoluteContentSize.X, UIGridLayout.AbsoluteContentSize.Y)
end

--- Updates the canvas size to fit the amount of current remotes
function updateRemoteCanvas()
	LogList.CanvasSize = UDim2.fromOffset(UIListLayout.AbsoluteContentSize.X, UIListLayout.AbsoluteContentSize.Y)
end

--- Allows for toggling of the tooltip and easy setting of le description
--- @param enable boolean
--- @param text string
function makeToolTip(enable, text)
	if enable then
		if ToolTip.Visible then
			ToolTip.Visible = false
			RunService:UnbindFromRenderStep("ToolTip")
		end
		local first = true
		RunService:BindToRenderStep("ToolTip", 1, function()
			local topLeft = Vector2.new(Mouse.X + 20, Mouse.Y + 20)
			local bottomRight = topLeft + ToolTip.AbsoluteSize
			if topLeft.X < 0 then
				topLeft = Vector2.new(0, topLeft.Y)
			elseif bottomRight.X > workspace.CurrentCamera.ViewportSize.X then
				topLeft = Vector2.new(workspace.CurrentCamera.ViewportSize.X - ToolTip.AbsoluteSize.X, topLeft.Y)
			end
			if topLeft.Y < 0 then
				topLeft = Vector2.new(topLeft.X, 0)
			elseif bottomRight.Y > workspace.CurrentCamera.ViewportSize.Y - 35 then
				topLeft = Vector2.new(topLeft.X, workspace.CurrentCamera.ViewportSize.Y - ToolTip.AbsoluteSize.Y - 35)
			end
			if topLeft.X <= Mouse.X and topLeft.Y <= Mouse.Y then
				topLeft = Vector2.new(Mouse.X - ToolTip.AbsoluteSize.X - 2, Mouse.Y - ToolTip.AbsoluteSize.Y - 2)
			end
			if first then
				ToolTip.Position = UDim2.fromOffset(topLeft.X, topLeft.Y)
				first = false
			else
				ToolTip:TweenPosition(UDim2.fromOffset(topLeft.X, topLeft.Y), "Out", "Linear", 0.1)
			end
		end)
		TextLabel.Text = text
		ToolTip.Visible = true
	else
		if ToolTip.Visible then
			ToolTip.Visible = false
			RunService:UnbindFromRenderStep("ToolTip")
		end
	end
end

--- Creates new function button (below codebox)
--- @param name string
---@param description function
---@param onClick function
function newButton(name, description, onClick)
	local button = FunctionTemplate:Clone()
	button.Text.Text = name
	button.Button.MouseEnter:Connect(function()
		makeToolTip(true, description())
	end)
	button.Button.MouseLeave:Connect(function()
		makeToolTip(false)
	end)
	button.AncestryChanged:Connect(function()
		makeToolTip(false)
	end)
	button.Button.MouseButton1Click:Connect(function(...)
		onClick(button, ...)
	end)
	button.Parent = ScrollingFrame
	updateFunctionCanvas()
end

--- Adds new Remote to logs
--- @param name string The name of the remote being logged
--- @param type string The type of the remote being logged (either 'function' or 'event')
--- @param args any
--- @param remote any
--- @param function_info string
--- @param blocked any
function newRemote(type, name, args, remote, function_info, blocked, src, returnValue)
	local remoteFrame = RemoteTemplate:Clone()
	remoteFrame.Text.Text = string.sub(name, 1, 50)
	remoteFrame.ColorBar.BackgroundColor3 = type == "event" and Color3.new(255, 242, 0) or Color3.fromRGB(99, 86, 245)
	local id = Instance.new("IntValue")
	id.Name = "ID"
	id.Value = #logs + 1
	id.Parent = remoteFrame
	local weakRemoteTable = setmetatable({ remote = remote }, { __mode = "v" })
	local log = {
		Name = name,
		Function = function_info,
		Remote = weakRemoteTable,
		Log = remoteFrame,
		Blocked = blocked,
		Source = src,
		GenScript = "-- Generating, please wait... (click to reload)\n-- (If this message persists, the remote args are likely extremely long)",
		ReturnValue = returnValue,
	}
	logs[#logs + 1] = log
	schedule(function()
		log.GenScript = genScript(remote, args)
		if blocked then
			logs[#logs].GenScript = "-- THIS REMOTE WAS PREVENTED FROM FIRING THE SERVER BY SIMPLESPY\n\n"
				.. logs[#logs].GenScript
		end
	end)
	local connect = remoteFrame.Button.MouseButton1Click:Connect(function()
		eventSelect(remoteFrame)
	end)
	if layoutOrderNum < 1 then
		layoutOrderNum = 999999999
	end
	remoteFrame.LayoutOrder = layoutOrderNum
	layoutOrderNum = layoutOrderNum - 1
	remoteFrame.Parent = LogList
	table.insert(remoteLogs, 1, { connect, remoteFrame })
	clean()
	updateRemoteCanvas()
end

--- Generates a script from the provided arguments (first has to be remote path)
function genScript(remote, args)
	prevTables = {}
	local gen = ""
	if #args > 0 then
		if not pcall(function()
			gen = v2v({ args = args }) .. "\n"
		end) then
			gen = gen
				.. "-- TableToString failure! Reverting to legacy functionality (results may vary)\nlocal args = {"
			if
				not pcall(function()
					for i, v in pairs(args) do
						if type(i) ~= "Instance" and type(i) ~= "userdata" then
							gen = gen .. "\n    [object] = "
						elseif type(i) == "string" then
							gen = gen .. '\n    ["' .. i .. '"] = '
						elseif type(i) == "userdata" and typeof(i) ~= "Instance" then
							gen = gen .. "\n    [" .. string.format("nil --[[%s]]", typeof(v)) .. ")] = "
						elseif type(i) == "userdata" then
							gen = gen .. "\n    [game." .. i:GetFullName() .. ")] = "
						end
						if type(v) ~= "Instance" and type(v) ~= "userdata" then
							gen = gen .. "object"
						elseif type(v) == "string" then
							gen = gen .. '"' .. v .. '"'
						elseif type(v) == "userdata" and typeof(v) ~= "Instance" then
							gen = gen .. string.format("nil --[[%s]]", typeof(v))
						elseif type(v) == "userdata" then
							gen = gen .. "game." .. v:GetFullName()
						end
					end
					gen = gen .. "\n}\n\n"
				end)
			then
				gen = gen .. "}\n-- Legacy tableToString failure! Unable to decompile."
			end
		end
		if not remote:IsDescendantOf(game) and not getnilrequired then
			gen = "function getNil(name,class) for _,v in pairs(getnilinstances())do if v.ClassName==class and v.Name==name then return v;end end end\n\n"
				.. gen
		end
		if remote:IsA("RemoteEvent") then
			gen = gen .. v2s(remote) .. ":FireServer(unpack(args))"
		elseif remote:IsA("RemoteFunction") then
			gen = gen .. v2s(remote) .. ":InvokeServer(unpack(args))"
		end
	else
		if remote:IsA("RemoteEvent") then
			gen = gen .. v2s(remote) .. ":FireServer()"
		elseif remote:IsA("RemoteFunction") then
			gen = gen .. v2s(remote) .. ":InvokeServer()"
		end
	end
	gen = "-- Script generated by SimpleSpy - credits to exx#9394\n\n" .. gen
	prevTables = {}
	return gen
end

--- value-to-string: value, string (out), level (indentation), parent table, var name, is from tovar
function v2s(v, l, p, n, vtv, i, pt, path, tables, tI)
	if not tI then
		tI = { 0 }
	else
		tI[1] += 1
	end
	if typeof(v) == "number" then
		if v == math.huge then
			return "math.huge"
		elseif tostring(v):match("nan") then
			return "0/0 --[[NaN]]"
		end
		return tostring(v)
	elseif typeof(v) == "boolean" then
		return tostring(v)
	elseif typeof(v) == "string" then
		return formatstr(v, l)
	elseif typeof(v) == "function" then
		return f2s(v)
	elseif typeof(v) == "table" then
		return t2s(v, l, p, n, vtv, i, pt, path, tables, tI)
	elseif typeof(v) == "Instance" then
		return i2p(v)
	elseif typeof(v) == "userdata" then
		return "newproxy(true)"
	elseif type(v) == "userdata" then
		return u2s(v)
	elseif type(v) == "vector" then
		return string.format("Vector3.new(%s, %s, %s)", v2s(v.X), v2s(v.Y), v2s(v.Z))
	else
		return "nil --[[" .. typeof(v) .. "]]"
	end
end

--- value-to-variable
--- @param t any
function v2v(t)
	topstr = ""
	bottomstr = ""
	getnilrequired = false
	local ret = ""
	local count = 1
	for i, v in pairs(t) do
		if type(i) == "string" and i:match("^[%a_]+[%w_]*$") then
			ret = ret .. "local " .. i .. " = " .. v2s(v, nil, nil, i, true) .. "\n"
		elseif tostring(i):match("^[%a_]+[%w_]*$") then
			ret = ret
				.. "local "
				.. tostring(i):lower()
				.. "_"
				.. tostring(count)
				.. " = "
				.. v2s(v, nil, nil, tostring(i):lower() .. "_" .. tostring(count), true)
				.. "\n"
		else
			ret = ret
				.. "local "
				.. type(v)
				.. "_"
				.. tostring(count)
				.. " = "
				.. v2s(v, nil, nil, type(v) .. "_" .. tostring(count), true)
				.. "\n"
		end
		count = count + 1
	end
	if getnilrequired then
		topstr = "function getNil(name,class) for _,v in pairs(getnilinstances())do if v.ClassName==class and v.Name==name then return v;end end end\n"
			.. topstr
	end
	if #topstr > 0 then
		ret = topstr .. "\n" .. ret
	end
	if #bottomstr > 0 then
		ret = ret .. bottomstr
	end
	return ret
end

--- table-to-string
--- @param t table
--- @param l number
--- @param p table
--- @param n string
--- @param vtv boolean
--- @param i any
--- @param pt table
--- @param path string
--- @param tables table
--- @param tI table
function t2s(t, l, p, n, vtv, i, pt, path, tables, tI)
	local globalIndex = table.find(getgenv(), t) -- checks if table is a global
	if type(globalIndex) == "string" then
		return globalIndex
	end
	if not tI then
		tI = { 0 }
	end
	if not path then -- sets path to empty string (so it doesn't have to manually provided every time)
		path = ""
	end
	if not l then -- sets the level to 0 (for indentation) and tables for logging tables it already serialized
		l = 0
		tables = {}
	end
	if not p then -- p is the previous table but doesn't really matter if it's the first
		p = t
	end
	for _, v in pairs(tables) do -- checks if the current table has been serialized before
		if n and rawequal(v, t) then
			bottomstr = bottomstr
				.. "\n"
				.. tostring(n)
				.. tostring(path)
				.. " = "
				.. tostring(n)
				.. tostring(({ v2p(v, p) })[2])
			return "{} --[[DUPLICATE]]"
		end
	end
	table.insert(tables, t) -- logs table to past tables
	local s = "{" -- start of serialization
	local size = 0
	l = l + indent -- set indentation level
	for k, v in pairs(t) do -- iterates over table
		size = size + 1 -- changes size for max limit
		if size > (_G.SimpleSpyMaxTableSize or 1000) then
			s = s
				.. "\n"
				.. string.rep(" ", l)
				.. "-- MAXIMUM TABLE SIZE REACHED, CHANGE '_G.SimpleSpyMaxTableSize' TO ADJUST MAXIMUM SIZE "
			break
		end
		if rawequal(k, t) then -- checks if the table being iterated over is being used as an index within itself (yay, lua)
			bottomstr = bottomstr
				.. "\n"
				.. tostring(n)
				.. tostring(path)
				.. "["
				.. tostring(n)
				.. tostring(path)
				.. "]"
				.. " = "
				.. (
					rawequal(v, k) and tostring(n) .. tostring(path)
					or v2s(v, l, p, n, vtv, k, t, path .. "[" .. tostring(n) .. tostring(path) .. "]", tables)
				)
			size -= 1
			continue
		end
		local currentPath = "" -- initializes the path of 'v' within 't'
		if type(k) == "string" and k:match("^[%a_]+[%w_]*$") then -- cleanly handles table path generation (for the first half)
			currentPath = "." .. k
		else
			currentPath = "[" .. k2s(k, l, p, n, vtv, k, t, path .. currentPath, tables, tI) .. "]"
		end
		if size % 100 == 0 then
			scheduleWait()
		end
		-- actually serializes the member of the table
		s = s
			.. "\n"
			.. string.rep(" ", l)
			.. "["
			.. k2s(k, l, p, n, vtv, k, t, path .. currentPath, tables, tI)
			.. "] = "
			.. v2s(v, l, p, n, vtv, k, t, path .. currentPath, tables, tI)
			.. ","
	end
	if #s > 1 then -- removes the last comma because it looks nicer (no way to tell if it's done 'till it's done so...)
		s = s:sub(1, #s - 1)
	end
	if size > 0 then -- cleanly indents the last curly bracket
		s = s .. "\n" .. string.rep(" ", l - indent)
	end
	return s .. "}"
end

--- key-to-string
function k2s(v, ...)
	if keyToString then
		if typeof(v) == "userdata" and getrawmetatable(v) then
			return string.format(
				'"<void> (%s)" --[[Potentially hidden data (tostring in SimpleSpy:HookRemote/GetRemoteFiredSignal at your own risk)]]',
				safetostring(v)
			)
		elseif typeof(v) == "userdata" then
			return string.format('"<void> (%s)"', safetostring(v))
		elseif type(v) == "userdata" and typeof(v) ~= "Instance" then
			return string.format('"<%s> (%s)"', typeof(v), tostring(v))
		elseif type(v) == "function" then
			return string.format('"<Function> (%s)"', tostring(v))
		end
	end
	return v2s(v, ...)
end

--- function-to-string
function f2s(f)
	for k, x in pairs(getgenv()) do
		local isgucci, gpath
		if rawequal(x, f) then
			isgucci, gpath = true, ""
		elseif type(x) == "table" then
			isgucci, gpath = v2p(f, x)
		end
		if isgucci and type(k) ~= "function" then
			if type(k) == "string" and k:match("^[%a_]+[%w_]*$") then
				return k .. gpath
			else
				return "getgenv()[" .. v2s(k) .. "]" .. gpath
			end
		end
	end
	if funcEnabled and debug.getinfo(f).name:match("^[%a_]+[%w_]*$") then
		return "function()end --[[" .. debug.getinfo(f).name .. "]]"
	end
	return "function()end --[[" .. tostring(f) .. "]]"
end

--- instance-to-path
--- @param i userdata
function i2p(i)
	local player = getplayer(i)
	local parent = i
	local out = ""
	if parent == nil then
		return "nil"
	elseif player then
		while true do
			if parent and parent == player.Character then
				if player == Players.LocalPlayer then
					return 'game:GetService("Players").LocalPlayer.Character' .. out
				else
					return i2p(player) .. ".Character" .. out
				end
			else
				if parent.Name:match("[%a_]+[%w+]*") ~= parent.Name then
					out = ":FindFirstChild(" .. formatstr(parent.Name) .. ")" .. out
				else
					out = "." .. parent.Name .. out
				end
			end
			parent = parent.Parent
		end
	elseif parent ~= game then
		while true do
			if parent and parent.Parent == game then
				local service = game:FindService(parent.ClassName)
				if service then
					if parent.ClassName == "Workspace" then
						return "workspace" .. out
					else
						return 'game:GetService("' .. service.ClassName .. '")' .. out
					end
				else
					if parent.Name:match("[%a_]+[%w_]*") then
						return "game." .. parent.Name .. out
					else
						return "game:FindFirstChild(" .. formatstr(parent.Name) .. ")" .. out
					end
				end
			elseif parent.Parent == nil then
				getnilrequired = true
				return "getNil(" .. formatstr(parent.Name) .. ', "' .. parent.ClassName .. '")' .. out
			elseif parent == Players.LocalPlayer then
				out = ".LocalPlayer" .. out
			else
				if parent.Name:match("[%a_]+[%w_]*") ~= parent.Name then
					out = ":FindFirstChild(" .. formatstr(parent.Name) .. ")" .. out
				else
					out = "." .. parent.Name .. out
				end
			end
			parent = parent.Parent
		end
	else
		return "game"
	end
end

--- userdata-to-string: userdata
--- @param u userdata
function u2s(u)
	if typeof(u) == "TweenInfo" then
		-- TweenInfo
		return "TweenInfo.new("
			.. tostring(u.Time)
			.. ", Enum.EasingStyle."
			.. tostring(u.EasingStyle)
			.. ", Enum.EasingDirection."
			.. tostring(u.EasingDirection)
			.. ", "
			.. tostring(u.RepeatCount)
			.. ", "
			.. tostring(u.Reverses)
			.. ", "
			.. tostring(u.DelayTime)
			.. ")"
	elseif typeof(u) == "Ray" then
		-- Ray
		return "Ray.new(" .. u2s(u.Origin) .. ", " .. u2s(u.Direction) .. ")"
	elseif typeof(u) == "NumberSequence" then
		-- NumberSequence
		local ret = "NumberSequence.new("
		for i, v in pairs(u.KeyPoints) do
			ret = ret .. tostring(v)
			if i < #u.Keypoints then
				ret = ret .. ", "
			end
		end
		return ret .. ")"
	elseif typeof(u) == "DockWidgetPluginGuiInfo" then
		-- DockWidgetPluginGuiInfo
		return "DockWidgetPluginGuiInfo.new(Enum.InitialDockState" .. tostring(u) .. ")"
	elseif typeof(u) == "ColorSequence" then
		-- ColorSequence
		local ret = "ColorSequence.new("
		for i, v in pairs(u.KeyPoints) do
			ret = ret .. "Color3.new(" .. tostring(v) .. ")"
			if i < #u.Keypoints then
				ret = ret .. ", "
			end
		end
		return ret .. ")"
	elseif typeof(u) == "BrickColor" then
		-- BrickColor
		return "BrickColor.new(" .. tostring(u.Number) .. ")"
	elseif typeof(u) == "NumberRange" then
		-- NumberRange
		return "NumberRange.new(" .. tostring(u.Min) .. ", " .. tostring(u.Max) .. ")"
	elseif typeof(u) == "Region3" then
		-- Region3
		local center = u.CFrame.Position
		local size = u.CFrame.Size
		local vector1 = center - size / 2
		local vector2 = center + size / 2
		return "Region3.new(" .. u2s(vector1) .. ", " .. u2s(vector2) .. ")"
	elseif typeof(u) == "Faces" then
		-- Faces
		local faces = {}
		if u.Top then
			table.insert(faces, "Enum.NormalId.Top")
		end
		if u.Bottom then
			table.insert(faces, "Enum.NormalId.Bottom")
		end
		if u.Left then
			table.insert(faces, "Enum.NormalId.Left")
		end
		if u.Right then
			table.insert(faces, "Enum.NormalId.Right")
		end
		if u.Back then
			table.insert(faces, "Enum.NormalId.Back")
		end
		if u.Front then
			table.insert(faces, "Enum.NormalId.Front")
		end
		return "Faces.new(" .. table.concat(faces, ", ") .. ")"
	elseif typeof(u) == "EnumItem" then
		return tostring(u)
	elseif typeof(u) == "Enums" then
		return "Enum"
	elseif typeof(u) == "Enum" then
		return "Enum." .. tostring(u)
	elseif typeof(u) == "RBXScriptSignal" then
		return "nil --[[RBXScriptSignal]]"
	elseif typeof(u) == "Vector3" then
		return string.format("Vector3.new(%s, %s, %s)", v2s(u.X), v2s(u.Y), v2s(u.Z))
	elseif typeof(u) == "CFrame" then
		local xAngle, yAngle, zAngle = u:ToEulerAnglesXYZ()
		return string.format(
			"CFrame.new(%s, %s, %s) * CFrame.Angles(%s, %s, %s)",
			v2s(u.X),
			v2s(u.Y),
			v2s(u.Z),
			v2s(xAngle),
			v2s(yAngle),
			v2s(zAngle)
		)
	elseif typeof(u) == "DockWidgetPluginGuiInfo" then
		return string.format(
			"DockWidgetPluginGuiInfo(%s, %s, %s, %s, %s, %s, %s)",
			"Enum.InitialDockState.Right",
			v2s(u.InitialEnabled),
			v2s(u.InitialEnabledShouldOverrideRestore),
			v2s(u.FloatingXSize),
			v2s(u.FloatingYSize),
			v2s(u.MinWidth),
			v2s(u.MinHeight)
		)
	elseif typeof(u) == "PathWaypoint" then
		return string.format("PathWaypoint.new(%s, %s)", v2s(u.Position), v2s(u.Action))
	elseif typeof(u) == "UDim" then
		return string.format("UDim.new(%s, %s)", v2s(u.Scale), v2s(u.Offset))
	elseif typeof(u) == "UDim2" then
		return string.format(
			"UDim2.new(%s, %s, %s, %s)",
			v2s(u.X.Scale),
			v2s(u.X.Offset),
			v2s(u.Y.Scale),
			v2s(u.Y.Offset)
		)
	elseif typeof(u) == "Rect" then
		return string.format("Rect.new(%s, %s)", v2s(u.Min), v2s(u.Max))
	else
		return string.format("nil --[[%s]]", typeof(u))
	end
end

--- Gets the player an instance is descended from
function getplayer(instance)
	for _, v in pairs(Players:GetPlayers()) do
		if v.Character and (instance:IsDescendantOf(v.Character) or instance == v.Character) then
			return v
		end
	end
end

--- value-to-path (in table)
function v2p(x, t, path, prev)
	if not path then
		path = ""
	end
	if not prev then
		prev = {}
	end
	if rawequal(x, t) then
		return true, ""
	end
	for i, v in pairs(t) do
		if rawequal(v, x) then
			if type(i) == "string" and i:match("^[%a_]+[%w_]*$") then
				return true, (path .. "." .. i)
			else
				return true, (path .. "[" .. v2s(i) .. "]")
			end
		end
		if type(v) == "table" then
			local duplicate = false
			for _, y in pairs(prev) do
				if rawequal(y, v) then
					duplicate = true
				end
			end
			if not duplicate then
				table.insert(prev, t)
				local found
				found, p = v2p(x, v, path, prev)
				if found then
					if type(i) == "string" and i:match("^[%a_]+[%w_]*$") then
						return true, "." .. i .. p
					else
						return true, "[" .. v2s(i) .. "]" .. p
					end
				end
			end
		end
	end
	return false, ""
end

--- format s: string, byte encrypt (for weird symbols)
function formatstr(s, indentation)
	if not indentation then
		indentation = 0
	end
	local handled, reachedMax = handlespecials(s, indentation)
	return '"'
		.. handled
		.. '"'
		.. (
			reachedMax
				and " --[[ MAXIMUM STRING SIZE REACHED, CHANGE '_G.SimpleSpyMaxStringSize' TO ADJUST MAXIMUM SIZE ]]"
			or ""
		)
end

--- Adds \'s to the text as a replacement to whitespace chars and other things because string.format can't yayeet
function handlespecials(value, indentation)
	local buildStr = {}
	local i = 1
	local char = string.sub(value, i, i)
	local indentStr
	while char ~= "" do
		if char == '"' then
			buildStr[i] = '\\"'
		elseif char == "\\" then
			buildStr[i] = "\\\\"
		elseif char == "\n" then
			buildStr[i] = "\\n"
		elseif char == "\t" then
			buildStr[i] = "\\t"
		elseif string.byte(char) > 126 or string.byte(char) < 32 then
			buildStr[i] = string.format("\\%d", string.byte(char))
		else
			buildStr[i] = char
		end
		i = i + 1
		char = string.sub(value, i, i)
		if i % 200 == 0 then
			indentStr = indentStr or string.rep(" ", indentation + indent)
			table.move({ '"\n', indentStr, '... "' }, 1, 3, i, buildStr)
			i += 3
		end
	end
	return table.concat(buildStr)
end

-- safe (ish) tostring
function safetostring(v: any)
	if typeof(v) == "userdata" or type(v) == "table" then
		local mt = getrawmetatable(v)
		local badtostring = mt and rawget(mt, "__tostring")
		if mt and badtostring then
			rawset(mt, "__tostring", nil)
			local out = tostring(v)
			rawset(mt, "__tostring", badtostring)
			return out
		end
	end
	return tostring(v)
end

--- finds script from 'src' from getinfo, returns nil if not found
--- @param src string
function getScriptFromSrc(src)
	local realPath
	local runningTest
	--- @type number
	local s, e
	local match = false
	if src:sub(1, 1) == "=" then
		realPath = game
		s = 2
	else
		runningTest = src:sub(2, e and e - 1 or -1)
		for _, v in pairs(getnilinstances()) do
			if v.Name == runningTest then
				realPath = v
				break
			end
		end
		s = #runningTest + 1
	end
	if realPath then
		e = src:sub(s, -1):find("%.")
		local i = 0
		repeat
			i += 1
			if not e then
				runningTest = src:sub(s, -1)
				local test = realPath.FindFirstChild(realPath, runningTest)
				if test then
					realPath = test
				end
				match = true
			else
				runningTest = src:sub(s, e)
				local test = realPath.FindFirstChild(realPath, runningTest)
				local yeOld = e
				if test then
					realPath = test
					s = e + 2
					e = src:sub(e + 2, -1):find("%.")
					e = e and e + yeOld or e
				else
					e = src:sub(e + 2, -1):find("%.")
					e = e and e + yeOld or e
				end
			end
		until match or i >= 50
	end
	return realPath
end

--- schedules the provided function (and calls it with any args after)
function schedule(f, ...)
	table.insert(scheduled, { f, ... })
end

--- yields the current thread until the scheduler gives the ok
function scheduleWait()
	local thread = coroutine.running()
	schedule(function()
		coroutine.resume(thread)
	end)
	coroutine.yield()
end

--- the big (well tbh small now) boi task scheduler himself, handles p much anything as quicc as possible
function taskscheduler()
	if not toggle then
		scheduled = {}
		return
	end
	if #scheduled > 1000 then
		table.remove(scheduled, #scheduled)
	end
	if #scheduled > 0 then
		local currentf = scheduled[1]
		table.remove(scheduled, 1)
		if type(currentf) == "table" and type(currentf[1]) == "function" then
			pcall(unpack(currentf))
		end
	end
end

--- Handles remote logs
function remoteHandler(hookfunction, methodName, remote, args, funcInfo, calling, returnValue)
	local validInstance, validClass = pcall(function()
		return remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")
	end)
	if validInstance and validClass then
		local func = funcInfo.func
		if not calling then
			_, calling = pcall(getScriptFromSrc, funcInfo.source)
		end
		coroutine.wrap(function()
			if remoteSignals[remote] then
				remoteSignals[remote]:Fire(args)
			end
		end)()
		if autoblock then
			if excluding[remote] then
				return
			end
			if not history[remote] then
				history[remote] = { badOccurances = 0, lastCall = tick() }
			end
			if tick() - history[remote].lastCall < 1 then
				history[remote].badOccurances += 1
				return
			else
				history[remote].badOccurances = 0
			end
			if history[remote].badOccurances > 3 then
				excluding[remote] = true
				return
			end
			history[remote].lastCall = tick()
		end
		local functionInfoStr
		local src
		if func and islclosure(func) then
			local functionInfo = {}
			functionInfo.info = funcInfo
			pcall(function()
				functionInfo.constants = debug.getconstants(func)
			end)
			pcall(function()
				functionInfoStr = v2v({ functionInfo = functionInfo })
			end)
			pcall(function()
				if type(calling) == "userdata" then
					src = calling
				end
			end)
		end
		if methodName:lower() == "fireserver" then
			newRemote(
				"event",
				remote.Name,
				args,
				remote,
				functionInfoStr,
				(blocklist[remote] or blocklist[remote.Name]),
				src
			)
		elseif methodName:lower() == "invokeserver" then
			newRemote(
				"function",
				remote.Name,
				args,
				remote,
				functionInfoStr,
				(blocklist[remote] or blocklist[remote.Name]),
				src,
				returnValue
			)
		end
	end
end

--- Used for hookfunction
function hookRemote(remoteType, remote, ...)
	if typeof(remote) == "Instance" then
		local args = { ... }
		local validInstance, remoteName = pcall(function()
			return remote.Name
		end)
		if validInstance and not (blacklist[remote] or blacklist[remoteName]) then
			local funcInfo = {}
			local calling
			if funcEnabled then
				funcInfo = debug.getinfo(4) or funcInfo
				calling = useGetCallingScript and getcallingscript() or nil
			end
			if recordReturnValues and remoteType == "RemoteFunction" then
				local thread = coroutine.running()
				local args = { ... }
				task.defer(function()
					local returnValue
					if remoteHooks[remote] then
						args = { remoteHooks[remote](unpack(args)) }
						returnValue = originalFunction(remote, unpack(args))
					else
						returnValue = originalFunction(remote, unpack(args))
					end
					schedule(
						remoteHandler,
						true,
						remoteType == "RemoteEvent" and "fireserver" or "invokeserver",
						remote,
						args,
						funcInfo,
						calling,
						returnValue
					)
					if blocklist[remote] or blocklist[remoteName] then
						coroutine.resume(thread)
					else
						coroutine.resume(thread, unpack(returnValue))
					end
				end)
			else
				schedule(
					remoteHandler,
					true,
					remoteType == "RemoteEvent" and "fireserver" or "invokeserver",
					remote,
					args,
					funcInfo,
					calling
				)
				if blocklist[remote] or blocklist[remoteName] then
					return
				end
			end
		end
	end
	if recordReturnValues and remoteType == "RemoteFunction" then
		return coroutine.yield()
	elseif remoteType == "RemoteEvent" then
		if remoteHooks[remote] then
			return originalEvent(remote, remoteHooks[remote](...))
		end
		return originalEvent(remote, ...)
	else
		if remoteHooks[remote] then
			return originalFunction(remote, remoteHooks[remote](...))
		end
		return originalFunction(remote, ...)
	end
end

local newnamecall = newcclosure(function(remote, ...)
	if typeof(remote) == "Instance" then
		local args = { ... }
		local methodName = getnamecallmethod()
		local validInstance, remoteName = pcall(function()
			return remote.Name
		end)
		if
			validInstance
			and (methodName == "FireServer" or methodName == "fireServer" or methodName == "InvokeServer" or methodName == "invokeServer")
			and not (blacklist[remote] or blacklist[remoteName])
		then
			local funcInfo = {}
			local calling
			if funcEnabled then
				funcInfo = debug.getinfo(3) or funcInfo
				calling = useGetCallingScript and getcallingscript() or nil
			end
			if recordReturnValues and (methodName == "InvokeServer" or methodName == "invokeServer") then
				local namecallThread = coroutine.running()
				local args = { ... }
				task.defer(function()
					local returnValue
					setnamecallmethod(methodName)
					if remoteHooks[remote] then
						args = { remoteHooks[remote](unpack(args)) }
						returnValue = { original(remote, unpack(args)) }
					else
						returnValue = { original(remote, unpack(args)) }
					end
					coroutine.resume(namecallThread, unpack(returnValue))
					coroutine.wrap(function()
						schedule(remoteHandler, false, methodName, remote, args, funcInfo, calling, returnValue)
					end)()
				end)
			else
				coroutine.wrap(function()
					schedule(remoteHandler, false, methodName, remote, args, funcInfo, calling)
				end)()
			end
		end
		if recordReturnValues and (methodName == "InvokeServer" or methodName == "invokeServer") then
			return coroutine.yield()
		elseif
			validInstance
			and (methodName == "FireServer" or methodName == "fireServer" or methodName == "InvokeServer" or methodName == "invokeServer")
			and (blocklist[remote] or blocklist[remoteName])
		then
			return nil
		elseif
			(not recordReturnValues or methodName ~= "InvokeServer" or methodName ~= "invokeServer")
			and validInstance
			and (methodName == "FireServer" or methodName == "fireServer" or methodName == "InvokeServer" or methodName == "invokeServer")
			and remoteHooks[remote]
		then
			return original(remote, remoteHooks[remote](...))
		else
			return original(remote, ...)
		end
	end
	return original(remote, ...)
end, original)

local newFireServer = newcclosure(function(...)
	return hookRemote("RemoteEvent", ...)
end, originalEvent)

local newInvokeServer = newcclosure(function(...)
	return hookRemote("RemoteFunction", ...)
end, originalFunction)

--- Toggles on and off the remote spy
function toggleSpy()
	if not toggle then
		if hookmetamethod then
			local oldNamecall = hookmetamethod(game, "__namecall", newnamecall)
			original = original or function(...)
				return oldNamecall(...)
			end
			_G.OriginalNamecall = original
		else
			gm = gm or getrawmetatable(game)
			original = original or function(...)
				return gm.__namecall(...)
			end
			setreadonly(gm, false)
			if not original then
				warn("SimpleSpy: namecall method not found!")
				onToggleButtonClick()
				return
			end
			gm.__namecall = newnamecall
			setreadonly(gm, true)
		end
		originalEvent = hookfunction(remoteEvent.FireServer, newFireServer)
		originalFunction = hookfunction(remoteFunction.InvokeServer, newInvokeServer)
	else
		if hookmetamethod then
			if original then
				hookmetamethod(game, "__namecall", original)
			end
		else
			gm = gm or getrawmetatable(game)
			setreadonly(gm, false)
			gm.__namecall = original
			setreadonly(gm, true)
		end
		hookfunction(remoteEvent.FireServer, originalEvent)
		hookfunction(remoteFunction.InvokeServer, originalFunction)
	end
end

--- Toggles between the two remotespy methods (hookfunction currently = disabled)
function toggleSpyMethod()
	toggleSpy()
	toggle = not toggle
end

--- Shuts down the remote spy
function shutdown()
	if schedulerconnect then
		schedulerconnect:Disconnect()
	end
	for _, connection in pairs(connections) do
		coroutine.wrap(function()
			connection:Disconnect()
		end)()
	end
	SimpleSpy2:Destroy()
	hookfunction(remoteEvent.FireServer, originalEvent)
	hookfunction(remoteFunction.InvokeServer, originalFunction)
	if hookmetamethod then
		if original then
			hookmetamethod(game, "__namecall", original)
		end
	else
		gm = gm or getrawmetatable(game)
		setreadonly(gm, false)
		gm.__namecall = original
		setreadonly(gm, true)
	end
	_G.SimpleSpyExecuted = false
end

-- main
if not _G.SimpleSpyExecuted then
	local succeeded, err = pcall(function()
		if not RunService:IsClient() then
			error("SimpleSpy cannot run on the server!")
		end
		if
			not hookfunction
			or not getrawmetatable
			or getrawmetatable and not getrawmetatable(game).__namecall
			or not setreadonly
		then
			local missing = {}
			if not hookfunction then
				table.insert(missing, "hookfunction")
			end
			if not getrawmetatable then
				table.insert(missing, "getrawmetatable")
			end
			if getrawmetatable and not getrawmetatable(game).__namecall then
				table.insert(missing, "getrawmetatable(game).__namecall")
			end
			if not setreadonly then
				table.insert(missing, "setreadonly")
			end
			shutdown()
			error(
				"This environment does not support method hooks!\n(Your exploit is not capable of running SimpleSpy)\nMissing: "
					.. table.concat(missing, ", ")
			)
		end
		_G.SimpleSpyShutdown = shutdown
		ContentProvider:PreloadAsync({
			"rbxassetid://6065821980",
			"rbxassetid://6065774948",
			"rbxassetid://6065821086",
			"rbxassetid://6065821596",
			ImageLabel,
			ImageLabel_2,
			ImageLabel_3,
		})
		-- if gethui then funcEnabled = false end
		onToggleButtonClick()
		RemoteTemplate.Parent = nil
		FunctionTemplate.Parent = nil
		codebox = Highlight.new(CodeBox)
		codebox:setRaw("")
		getgenv().SimpleSpy = SimpleSpy
		getgenv().getNil = function(name, class)
			for _, v in pairs(getnilinstances()) do
				if v.ClassName == class and v.Name == name then
					return v
				end
			end
		end
		TextLabel:GetPropertyChangedSignal("Text"):Connect(scaleToolTip)
		-- TopBar.InputBegan:Connect(onBarInput)
		MinimizeButton.MouseButton1Click:Connect(toggleMinimize)
		MaximizeButton.MouseButton1Click:Connect(toggleSideTray)
		Simple.MouseButton1Click:Connect(onToggleButtonClick)
		CloseButton.MouseEnter:Connect(onXButtonHover)
		CloseButton.MouseLeave:Connect(onXButtonUnhover)
		Simple.MouseEnter:Connect(onToggleButtonHover)
		Simple.MouseLeave:Connect(onToggleButtonUnhover)
		CloseButton.MouseButton1Click:Connect(shutdown)
		table.insert(connections, UserInputService.InputBegan:Connect(backgroundUserInput))
		connectResize()
		SimpleSpy2.Enabled = true
		coroutine.wrap(function()
			wait(1)
			onToggleButtonUnhover()
		end)()
		schedulerconnect = RunService.Heartbeat:Connect(taskscheduler)
		if syn and syn.protect_gui then
			pcall(syn.protect_gui, SimpleSpy2)
		end
		bringBackOnResize()
		SimpleSpy2.Parent = --[[gethui and gethui() or]]
			CoreGui
		_G.SimpleSpyExecuted = true
		if not Players.LocalPlayer then
			Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
		end
		Mouse = Players.LocalPlayer:GetMouse()
		oldIcon = Mouse.Icon
		table.insert(connections, Mouse.Move:Connect(mouseMoved))
	end)
	if not succeeded then
		warn(
			"A fatal error has occured, SimpleSpy was unable to launch properly.\nPlease DM this error message to @exx#9394:\n\n"
				.. tostring(err)
		)
		SimpleSpy2:Destroy()
		hookfunction(remoteEvent.FireServer, originalEvent)
		hookfunction(remoteFunction.InvokeServer, originalFunction)
		if hookmetamethod then
			if original then
				hookmetamethod(game, "__namecall", original)
			end
		else
			setreadonly(gm, false)
			gm.__namecall = original
			setreadonly(gm, true)
		end
		return
	end
else
	SimpleSpy2:Destroy()
	return
end

----- ADD ONS ----- (easily add or remove additonal functionality to the RemoteSpy!)
--[[
    Some helpful things:
        - add your function in here, and create buttons for them through the 'newButton' function
        - the first argument provided is the TextButton the player clicks to run the function
        - generated scripts are generated when the namecall is initially fired and saved in remoteFrame objects
        - blacklisted remotes will be ignored directly in namecall (less lag)
        - the properties of a 'remoteFrame' object:
            {
                Name: (string) The name of the Remote
                GenScript: (string) The generated script that appears in the codebox (generated when namecall fired)
                Source: (Instance (LocalScript)) The script that fired/invoked the remote
                Remote: (Instance (RemoteEvent) | Instance (RemoteFunction)) The remote that was fired/invoked
                Log: (Instance (TextButton)) The button being used for the remote (same as 'selected.Log')
            }
        - globals list: (contact @exx#9394 for more information or if you have suggestions for more to be added)
            - closed: (boolean) whether or not the GUI is currently minimized
            - logs: (table[remoteFrame]) full of remoteFrame objects (properties listed above)
            - selected: (remoteFrame) the currently selected remoteFrame (properties listed above)
            - blacklist: (string[] | Instance[] (RemoteEvent) | Instance[] (RemoteFunction)) an array of blacklisted names and remotes
            - codebox: (Instance (TextBox)) the textbox that holds all the code- cleared often
]]
-- Copies the contents of the codebox
newButton("Copy Code", function()
	return "Click to copy code"
end, function()
	setclipboard(codebox:getString())
	TextLabel.Text = "Copied successfully!"
end)

--- Copies the source script (that fired the remote)
newButton("Copy Remote", function()
	return "Click to copy the path of the remote"
end, function()
	if selected then
		setclipboard(v2s(selected.Remote.remote))
		TextLabel.Text = "Copied!"
	end
end)

-- Executes the contents of the codebox through loadstring
newButton("Run Code", function()
	return "Click to execute code"
end, function()
	local orText = "Click to execute code"
	TextLabel.Text = "Executing..."
	local succeeded = pcall(function()
		return loadstring(codebox:getString())()
	end)
	if succeeded then
		TextLabel.Text = "Executed successfully!"
	else
		TextLabel.Text = "Execution error!"
	end
end)

--- Gets the calling script (not super reliable but w/e)
newButton("Get Script", function()
	return "Click to copy calling script to clipboard\nWARNING: Not super reliable, nil == could not find"
end, function()
	if selected then
		setclipboard(SimpleSpy:ValueToString(selected.Source))
		TextLabel.Text = "Done!"
	end
end)

--- Decompiles the script that fired the remote and puts it in the code box
newButton("Function Info", function()
	return "Click to view calling function information"
end, function()
	if selected then
		if selected.Function then
			codebox:setRaw(
				"-- Calling function info\n-- Generated by the SimpleSpy serializer\n\n" .. tostring(selected.Function)
			)
		end
		TextLabel.Text = "Done! Function info generated by the SimpleSpy Serializer."
	end
end)

--- Clears the Remote logs
newButton("Clr Logs", function()
	return "Click to clear logs"
end, function()
	TextLabel.Text = "Clearing..."
	logs = {}
	for _, v in pairs(LogList:GetChildren()) do
		if not v:IsA("UIListLayout") then
			v:Destroy()
		end
	end
	codebox:setRaw("")
	selected = nil
	TextLabel.Text = "Logs cleared!"
end)

--- Excludes the selected.Log Remote from the RemoteSpy
newButton("Exclude (i)", function()
	return "Click to exclude this Remote.\nExcluding a remote makes SimpleSpy ignore it, but it will continue to be usable."
end, function()
	if selected then
		blacklist[selected.Remote.remote] = true
		TextLabel.Text = "Excluded!"
	end
end)

--- Excludes all Remotes that share the same name as the selected.Log remote from the RemoteSpy
newButton("Exclude (n)", function()
	return "Click to exclude all remotes with this name.\nExcluding a remote makes SimpleSpy ignore it, but it will continue to be usable."
end, function()
	if selected then
		blacklist[selected.Name] = true
		TextLabel.Text = "Excluded!"
	end
end)

--- clears blacklist
newButton("Clr Blacklist", function()
	return "Click to clear the blacklist.\nExcluding a remote makes SimpleSpy ignore it, but it will continue to be usable."
end, function()
	blacklist = {}
	TextLabel.Text = "Blacklist cleared!"
end)

--- Prevents the selected.Log Remote from firing the server (still logged)
newButton("Block (i)", function()
	return "Click to stop this remote from firing.\nBlocking a remote won't remove it from SimpleSpy logs, but it will not continue to fire the server."
end, function()
	if selected then
		if selected.Remote.remote then
			blocklist[selected.Remote.remote] = true
			TextLabel.Text = "Excluded!"
		else
			TextLabel.Text = "Error! Instance may no longer exist, try using Block (n)."
		end
	end
end)

--- Prevents all remotes from firing that share the same name as the selected.Log remote from the RemoteSpy (still logged)
newButton("Block (n)", function()
	return "Click to stop remotes with this name from firing.\nBlocking a remote won't remove it from SimpleSpy logs, but it will not continue to fire the server."
end, function()
	if selected then
		blocklist[selected.Name] = true
		TextLabel.Text = "Excluded!"
	end
end)

--- clears blacklist
newButton("Clr Blocklist", function()
	return "Click to stop blocking remotes.\nBlocking a remote won't remove it from SimpleSpy logs, but it will not continue to fire the server."
end, function()
	blocklist = {}
	TextLabel.Text = "Blocklist cleared!"
end)

--- Attempts to decompile the source script
newButton("Decompile", function()
	return "Attempts to decompile source script\nWARNING: Not super reliable, nil == could not find"
end, function()
	if selected then
		if selected.Source then
			codebox:setRaw(decompile(selected.Source))
			TextLabel.Text = "Done!"
		else
			TextLabel.Text = "Source not found!"
		end
	end
end)

newButton("Disable Info", function()
	return string.format(
		"[%s] Toggle function info (because it can cause lag in some games)",
		funcEnabled and "ENABLED" or "DISABLED"
	)
end, function()
	funcEnabled = not funcEnabled
	TextLabel.Text = string.format(
		"[%s] Toggle function info (because it can cause lag in some games)",
		funcEnabled and "ENABLED" or "DISABLED"
	)
end)

newButton("Autoblock", function()
	return string.format(
		"[%s] [BETA] Intelligently detects and excludes spammy remote calls from logs",
		autoblock and "ENABLED" or "DISABLED"
	)
end, function()
	autoblock = not autoblock
	TextLabel.Text = string.format(
		"[%s] [BETA] Intelligently detects and excludes spammy remote calls from logs",
		autoblock and "ENABLED" or "DISABLED"
	)
	history = {}
	excluding = {}
end)

newButton("CallingScript", function()
	return string.format(
		"[%s] [UNSAFE] Uses 'getcallingscript' to get calling script for Decompile and GetScript. Much more reliable, but opens up SimpleSpy to detection and/or instability.",
		useGetCallingScript and "ENABLED" or "DISABLED"
	)
end, function()
	useGetCallingScript = not useGetCallingScript
	TextLabel.Text = string.format(
		"[%s] [UNSAFE] Uses 'getcallingscript' to get calling script for Decompile and GetScript. Much more reliable, but opens up SimpleSpy to detection and/or instability.",
		useGetCallingScript and "ENABLED" or "DISABLED"
	)
end)

newButton("KeyToString", function()
	return string.format(
		"[%s] [BETA] Uses an experimental new function to replicate Roblox's behavior when a non-primitive type is used as a key in a table. Still in development and may not properly reflect tostringed (empty) userdata.",
		keyToString and "ENABLED" or "DISABLED"
	)
end, function()
	keyToString = not keyToString
	TextLabel.Text = string.format(
		"[%s] [BETA] Uses an experimental new function to replicate Roblox's behavior when a non-primitive type is used as a key in a table. Still in development and may not properly reflect tostringed (empty) userdata.",
		keyToString and "ENABLED" or "DISABLED"
	)
end)

newButton("ToggleReturnValues", function()
	return string.format(
		"[%s] [EXPERIMENTAL] Enables recording of return values for 'GetReturnValue'\n\nUse this method at your own risk, as it could be detectable.",
		recordReturnValues and "ENABLED" or "DISABLED"
	)
end, function()
	recordReturnValues = not recordReturnValues
	TextLabel.Text = string.format(
		"[%s] [EXPERIMENTAL] Enables recording of return values for 'GetReturnValue'\n\nUse this method at your own risk, as it could be detectable.",
		recordReturnValues and "ENABLED" or "DISABLED"
	)
end)

newButton("GetReturnValue", function()
	return "[Experimental] If 'ReturnValues' is enabled, this will show the recorded return value for the RemoteFunction (if available)."
end, function()
	if selected then
		codebox:setRaw(SimpleSpy:ValueToVar(selected.ReturnValue, "returnValue"))
	end
end)
end)

Scripts:NewButton("Dex V4", "Execute the Dex V4", function()
    loadstring(game:GetObjects("rbxassetid://418957341")[1].Source)()
end)

Scripts:NewButton("FE Admin", "FE Admin", function()
    loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
end)

Scripts:NewSlider("FOV Changer", "FOV Changer.", 120, 70, function(s) -- 500 (MaxValue) | 0 (MinValue)
    workspace.CurrentCamera.FieldOfView = s
end)


Tab7:NewKeybind("ToggleUI Key", "ToggleUI Key.", Enum.KeyCode.F, function()
	Library:ToggleUI()
end)

Tab56:NewLabel("Created By The FBI")
Tab56:NewLabel("UI Library Used: Kavo UI Library")
Tab56:NewButton("Copy the Discord Profile Link", "Copy the Profile Link", function()
    setclipboard("discordapp.com/users/997643751927336970")
end)

Tab56:NewButton("Copy the Script Link", "Copy the Script Link", function()
    setclipboard("https://scriptblox.com/script/Universal-Script-Dark-Universal-ScriptHub-6207")
end)

Tab56:NewButton("Copy the Kavo UI Link", "Copy the Kavo UI Link.", function()
    setclipboard("https://xheptcofficial.gitbook.io/kavo-library/")
end)